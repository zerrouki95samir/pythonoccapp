# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _CSLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_CSLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_CSLib')
    _CSLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_CSLib', [dirname(__file__)])
        except ImportError:
            import _CSLib
            return _CSLib
        try:
            _mod = imp.load_module('_CSLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _CSLib = swig_import_helper()
    del swig_import_helper
else:
    import _CSLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CSLib.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_CSLib.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_CSLib.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_CSLib.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_CSLib.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_CSLib.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_CSLib.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_CSLib.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_CSLib.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_CSLib.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_CSLib.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_CSLib.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_CSLib.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_CSLib.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_CSLib.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_CSLib.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_CSLib.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _CSLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.gp
import OCC.Standard
import OCC.TColgp
import OCC.MMgt
import OCC.TCollection
import OCC.math
import OCC.TColStd

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

CSLib_Done = _CSLib.CSLib_Done
CSLib_D1uIsNull = _CSLib.CSLib_D1uIsNull
CSLib_D1vIsNull = _CSLib.CSLib_D1vIsNull
CSLib_D1IsNull = _CSLib.CSLib_D1IsNull
CSLib_D1uD1vRatioIsNull = _CSLib.CSLib_D1uD1vRatioIsNull
CSLib_D1vD1uRatioIsNull = _CSLib.CSLib_D1vD1uRatioIsNull
CSLib_D1uIsParallelD1v = _CSLib.CSLib_D1uIsParallelD1v
CSLib_Singular = _CSLib.CSLib_Singular
CSLib_Defined = _CSLib.CSLib_Defined
CSLib_InfinityOfSolutions = _CSLib.CSLib_InfinityOfSolutions
CSLib_D1NuIsNull = _CSLib.CSLib_D1NuIsNull
CSLib_D1NvIsNull = _CSLib.CSLib_D1NvIsNull
CSLib_D1NIsNull = _CSLib.CSLib_D1NIsNull
CSLib_D1NuNvRatioIsNull = _CSLib.CSLib_D1NuNvRatioIsNull
CSLib_D1NvNuRatioIsNull = _CSLib.CSLib_D1NvNuRatioIsNull
CSLib_D1NuIsParallelD1Nv = _CSLib.CSLib_D1NuIsParallelD1Nv
class cslib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Normal(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * The following functions computes the normal to a surface inherits FunctionWithDerivative from math //! Computes the normal direction of a surface as the cross product between D1U and D1V. If D1U has null length or D1V has null length or D1U and D1V are parallel the normal is undefined. To check that D1U and D1V are colinear the sinus of the angle between D1U and D1V is computed and compared with SinTol. The normal is computed if Status == Done else the Status gives the reason why the computation has failed.

        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :param SinTol:
        :type SinTol: float
        :param Status:
        :type Status: CSLib_DerivativeStatus &
        :param Normal:
        :type Normal: gp_Dir
        :rtype: void

        * If there is a singularity on the surface the previous method cannot compute the local normal. This method computes an approched normal direction of a surface. It does a limited development and needs the second derivatives on the surface as input data. It computes the normal as follow : N(u, v) = D1U ^ D1V N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps with Eps->0 so we can have the equivalence N ~ dN/du + dN/dv. DNu = ||DN/du|| and DNv = ||DN/dv|| //! . if DNu IsNull (DNu <= Resolution from gp) the answer Done = True the normal direction is given by DN/dv . if DNv IsNull (DNv <= Resolution from gp) the answer Done = True the normal direction is given by DN/du . if the two directions DN/du and DN/dv are parallel Done = True the normal direction is given either by DN/du or DN/dv. To check that the two directions are colinear the sinus of the angle between these directions is computed and compared with SinTol. . if DNu/DNv or DNv/DNu is lower or equal than Real Epsilon Done = False, the normal is undefined . if DNu IsNull and DNv is Null Done = False, there is an indetermination and we should do a limited developpement at order 2 (it means that we cannot omit Eps). . if DNu Is not Null and DNv Is not Null Done = False, there are an infinity of normals at the considered point on the surface.

        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :param D2U:
        :type D2U: gp_Vec
        :param D2V:
        :type D2V: gp_Vec
        :param D2UV:
        :type D2UV: gp_Vec
        :param SinTol:
        :type SinTol: float
        :param Done:
        :type Done: bool
        :param Status:
        :type Status: CSLib_NormalStatus &
        :param Normal:
        :type Normal: gp_Dir
        :rtype: void

        * Computes the normal direction of a surface as the cross product between D1U and D1V.

        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :param MagTol:
        :type MagTol: float
        :param Status:
        :type Status: CSLib_NormalStatus &
        :param Normal:
        :type Normal: gp_Dir
        :rtype: void

        * find the first order k0 of deriviative of NUV where: foreach order < k0 all the derivatives of NUV are null all the derivatives of NUV corresponding to the order k0 are collinear and have the same sens. In this case, normal at U,V is unique.

        :param MaxOrder:
        :type MaxOrder: int
        :param DerNUV:
        :type DerNUV: TColgp_Array2OfVec
        :param MagTol:
        :type MagTol: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param Umin:
        :type Umin: float
        :param Umax:
        :type Umax: float
        :param Vmin:
        :type Vmin: float
        :param Vmax:
        :type Vmax: float
        :param Status:
        :type Status: CSLib_NormalStatus &
        :param Normal:
        :type Normal: gp_Dir
        :param OrderU:
        :type OrderU: int &
        :param OrderV:
        :type OrderV: int &
        :rtype: void

        """
        return _CSLib.cslib_Normal(*args)

    Normal = staticmethod(Normal)

    def DNNUV(*args) -> "gp_Vec":
        """
        * -- Computes the derivative of order Nu in the -- direction U and Nv in the direction V of the not -- normalized normal vector at the point P(U,V) The array DerSurf contain the derivative (i,j) of the surface for i=0,Nu+1 ; j=0,Nv+1

        :param Nu:
        :type Nu: int
        :param Nv:
        :type Nv: int
        :param DerSurf:
        :type DerSurf: TColgp_Array2OfVec
        :rtype: gp_Vec

        * Computes the derivatives of order Nu in the direction Nu and Nv in the direction Nv of the not normalized vector N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) DerSurf1 are the derivatives of S1

        :param Nu:
        :type Nu: int
        :param Nv:
        :type Nv: int
        :param DerSurf1:
        :type DerSurf1: TColgp_Array2OfVec
        :param DerSurf2:
        :type DerSurf2: TColgp_Array2OfVec
        :rtype: gp_Vec

        """
        return _CSLib.cslib_DNNUV(*args)

    DNNUV = staticmethod(DNNUV)

    def DNNormal(*args) -> "gp_Vec":
        """
        * -- Computes the derivative of order Nu in the -- direction U and Nv in the direction V of the normalized normal vector at the point P(U,V) array DerNUV contain the derivative (i+Iduref,j+Idvref) of D1U ^ D1V for i=0,Nu ; j=0,Nv Iduref and Idvref correspond to a derivative of D1U ^ D1V which can be used to compute the normalized normal vector. In the regular cases , Iduref=Idvref=0.

        :param Nu:
        :type Nu: int
        :param Nv:
        :type Nv: int
        :param DerNUV:
        :type DerNUV: TColgp_Array2OfVec
        :param Iduref: default value is 0
        :type Iduref: int
        :param Idvref: default value is 0
        :type Idvref: int
        :rtype: gp_Vec

        """
        return _CSLib.cslib_DNNormal(*args)

    DNNormal = staticmethod(DNNormal)

    __repr__ = _dumps_object


    def __init__(self):
        _CSLib.cslib_swiginit(self, _CSLib.new_cslib())
    __swig_destroy__ = _CSLib.delete_cslib
cslib_swigregister = _CSLib.cslib_swigregister
cslib_swigregister(cslib)

def cslib_Normal(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * The following functions computes the normal to a surface inherits FunctionWithDerivative from math //! Computes the normal direction of a surface as the cross product between D1U and D1V. If D1U has null length or D1V has null length or D1U and D1V are parallel the normal is undefined. To check that D1U and D1V are colinear the sinus of the angle between D1U and D1V is computed and compared with SinTol. The normal is computed if Status == Done else the Status gives the reason why the computation has failed.

    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :param SinTol:
    :type SinTol: float
    :param Status:
    :type Status: CSLib_DerivativeStatus &
    :param Normal:
    :type Normal: gp_Dir
    :rtype: void

    * If there is a singularity on the surface the previous method cannot compute the local normal. This method computes an approched normal direction of a surface. It does a limited development and needs the second derivatives on the surface as input data. It computes the normal as follow : N(u, v) = D1U ^ D1V N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps with Eps->0 so we can have the equivalence N ~ dN/du + dN/dv. DNu = ||DN/du|| and DNv = ||DN/dv|| //! . if DNu IsNull (DNu <= Resolution from gp) the answer Done = True the normal direction is given by DN/dv . if DNv IsNull (DNv <= Resolution from gp) the answer Done = True the normal direction is given by DN/du . if the two directions DN/du and DN/dv are parallel Done = True the normal direction is given either by DN/du or DN/dv. To check that the two directions are colinear the sinus of the angle between these directions is computed and compared with SinTol. . if DNu/DNv or DNv/DNu is lower or equal than Real Epsilon Done = False, the normal is undefined . if DNu IsNull and DNv is Null Done = False, there is an indetermination and we should do a limited developpement at order 2 (it means that we cannot omit Eps). . if DNu Is not Null and DNv Is not Null Done = False, there are an infinity of normals at the considered point on the surface.

    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :param D2U:
    :type D2U: gp_Vec
    :param D2V:
    :type D2V: gp_Vec
    :param D2UV:
    :type D2UV: gp_Vec
    :param SinTol:
    :type SinTol: float
    :param Done:
    :type Done: bool
    :param Status:
    :type Status: CSLib_NormalStatus &
    :param Normal:
    :type Normal: gp_Dir
    :rtype: void

    * Computes the normal direction of a surface as the cross product between D1U and D1V.

    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :param MagTol:
    :type MagTol: float
    :param Status:
    :type Status: CSLib_NormalStatus &
    :param Normal:
    :type Normal: gp_Dir
    :rtype: void

    * find the first order k0 of deriviative of NUV where: foreach order < k0 all the derivatives of NUV are null all the derivatives of NUV corresponding to the order k0 are collinear and have the same sens. In this case, normal at U,V is unique.

    :param MaxOrder:
    :type MaxOrder: int
    :param DerNUV:
    :type DerNUV: TColgp_Array2OfVec
    :param MagTol:
    :type MagTol: float
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param Umin:
    :type Umin: float
    :param Umax:
    :type Umax: float
    :param Vmin:
    :type Vmin: float
    :param Vmax:
    :type Vmax: float
    :param Status:
    :type Status: CSLib_NormalStatus &
    :param Normal:
    :type Normal: gp_Dir
    :param OrderU:
    :type OrderU: int &
    :param OrderV:
    :type OrderV: int &
    :rtype: void

    """
    return _CSLib.cslib_Normal(*args)

def cslib_DNNUV(*args) -> "gp_Vec":
    """
    * -- Computes the derivative of order Nu in the -- direction U and Nv in the direction V of the not -- normalized normal vector at the point P(U,V) The array DerSurf contain the derivative (i,j) of the surface for i=0,Nu+1 ; j=0,Nv+1

    :param Nu:
    :type Nu: int
    :param Nv:
    :type Nv: int
    :param DerSurf:
    :type DerSurf: TColgp_Array2OfVec
    :rtype: gp_Vec

    * Computes the derivatives of order Nu in the direction Nu and Nv in the direction Nv of the not normalized vector N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) DerSurf1 are the derivatives of S1

    :param Nu:
    :type Nu: int
    :param Nv:
    :type Nv: int
    :param DerSurf1:
    :type DerSurf1: TColgp_Array2OfVec
    :param DerSurf2:
    :type DerSurf2: TColgp_Array2OfVec
    :rtype: gp_Vec

    """
    return _CSLib.cslib_DNNUV(*args)

def cslib_DNNormal(*args) -> "gp_Vec":
    """
    * -- Computes the derivative of order Nu in the -- direction U and Nv in the direction V of the normalized normal vector at the point P(U,V) array DerNUV contain the derivative (i+Iduref,j+Idvref) of D1U ^ D1V for i=0,Nu ; j=0,Nv Iduref and Idvref correspond to a derivative of D1U ^ D1V which can be used to compute the normalized normal vector. In the regular cases , Iduref=Idvref=0.

    :param Nu:
    :type Nu: int
    :param Nv:
    :type Nv: int
    :param DerNUV:
    :type DerNUV: TColgp_Array2OfVec
    :param Iduref: default value is 0
    :type Iduref: int
    :param Idvref: default value is 0
    :type Idvref: int
    :rtype: gp_Vec

    """
    return _CSLib.cslib_DNNormal(*args)

class CSLib_Class2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param TP:
        :type TP: TColgp_Array1OfPnt2d
        :param aTolu:
        :type aTolu: float
        :param aTolv:
        :type aTolv: float
        :param umin:
        :type umin: float
        :param vmin:
        :type vmin: float
        :param umax:
        :type umax: float
        :param vmax:
        :type vmax: float
        :rtype: None

        """
        _CSLib.CSLib_Class2d_swiginit(self, _CSLib.new_CSLib_Class2d(*args))

    def SiDans(self, *args) -> "Standard_Integer":
        """
        :param P:
        :type P: gp_Pnt2d
        :rtype: int

        """
        return _CSLib.CSLib_Class2d_SiDans(self, *args)


    def SiDans_OnMode(self, *args) -> "Standard_Integer":
        """
        :param P:
        :type P: gp_Pnt2d
        :param Tol:
        :type Tol: float
        :rtype: int

        """
        return _CSLib.CSLib_Class2d_SiDans_OnMode(self, *args)


    def InternalSiDans(self, *args) -> "Standard_Integer":
        """
        :param X:
        :type X: float
        :param Y:
        :type Y: float
        :rtype: int

        """
        return _CSLib.CSLib_Class2d_InternalSiDans(self, *args)


    def InternalSiDansOuOn(self, *args) -> "Standard_Integer":
        """
        :param X:
        :type X: float
        :param Y:
        :type Y: float
        :rtype: int

        """
        return _CSLib.CSLib_Class2d_InternalSiDansOuOn(self, *args)


    def Copy(self, *args) -> "CSLib_Class2d const &":
        """
        :param Other:
        :type Other: CSLib_Class2d &
        :rtype: CSLib_Class2d

        """
        return _CSLib.CSLib_Class2d_Copy(self, *args)


    def Set(self, *args) -> "CSLib_Class2d const &":
        """
        :param Other:
        :type Other: CSLib_Class2d &
        :rtype: CSLib_Class2d

        """
        return _CSLib.CSLib_Class2d_Set(self, *args)


    def Destroy(self, *args) -> "void":
        """
        :rtype: None

        """
        return _CSLib.CSLib_Class2d_Destroy(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _CSLib.delete_CSLib_Class2d
CSLib_Class2d.SiDans = new_instancemethod(_CSLib.CSLib_Class2d_SiDans, None, CSLib_Class2d)
CSLib_Class2d.SiDans_OnMode = new_instancemethod(_CSLib.CSLib_Class2d_SiDans_OnMode, None, CSLib_Class2d)
CSLib_Class2d.InternalSiDans = new_instancemethod(_CSLib.CSLib_Class2d_InternalSiDans, None, CSLib_Class2d)
CSLib_Class2d.InternalSiDansOuOn = new_instancemethod(_CSLib.CSLib_Class2d_InternalSiDansOuOn, None, CSLib_Class2d)
CSLib_Class2d.Copy = new_instancemethod(_CSLib.CSLib_Class2d_Copy, None, CSLib_Class2d)
CSLib_Class2d.Set = new_instancemethod(_CSLib.CSLib_Class2d_Set, None, CSLib_Class2d)
CSLib_Class2d.Destroy = new_instancemethod(_CSLib.CSLib_Class2d_Destroy, None, CSLib_Class2d)
CSLib_Class2d_swigregister = _CSLib.CSLib_Class2d_swigregister
CSLib_Class2d_swigregister(CSLib_Class2d)

class CSLib_NormalPolyDef(OCC.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param k0:
        :type k0: int
        :param li:
        :type li: TColStd_Array1OfReal &
        :rtype: None

        """
        _CSLib.CSLib_NormalPolyDef_swiginit(self, _CSLib.new_CSLib_NormalPolyDef(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _CSLib.delete_CSLib_NormalPolyDef
CSLib_NormalPolyDef_swigregister = _CSLib.CSLib_NormalPolyDef_swigregister
CSLib_NormalPolyDef_swigregister(CSLib_NormalPolyDef)



