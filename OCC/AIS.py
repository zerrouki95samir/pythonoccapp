# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _AIS.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_AIS')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_AIS')
    _AIS = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_AIS', [dirname(__file__)])
        except ImportError:
            import _AIS
            return _AIS
        try:
            _mod = imp.load_module('_AIS', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _AIS = swig_import_helper()
    del swig_import_helper
else:
    import _AIS
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _AIS.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_AIS.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_AIS.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_AIS.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_AIS.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_AIS.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_AIS.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_AIS.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_AIS.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_AIS.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_AIS.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_AIS.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_AIS.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_AIS.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_AIS.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_AIS.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_AIS.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _AIS.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.TopoDS
import OCC.MMgt
import OCC.Standard
import OCC.TCollection
import OCC.TopLoc
import OCC.gp
import OCC.TopAbs
import OCC.Geom
import OCC.GeomAbs
import OCC.TColgp
import OCC.TColStd
import OCC.Bnd
import OCC.Prs3d
import OCC.Quantity
import OCC.Aspect
import OCC.Graphic3d
import OCC.Image
import OCC.NCollection
import OCC.OSD
import OCC.HLRAlgo
import OCC.TopTools
import OCC.Message
import OCC.Poly
import OCC.TShort
import OCC.SelectMgr
import OCC.PrsMgr
import OCC.V3d
import OCC.Visual3d
import OCC.StdSelect
import OCC.Select3D
import OCC.SelectBasics
import OCC.DsgPrs

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

AIS_CM_All = _AIS.AIS_CM_All
AIS_CM_Interactive = _AIS.AIS_CM_Interactive
AIS_CM_Filters = _AIS.AIS_CM_Filters
AIS_CM_StandardModes = _AIS.AIS_CM_StandardModes
AIS_CM_TemporaryShapePrs = _AIS.AIS_CM_TemporaryShapePrs
AIS_CS_None = _AIS.AIS_CS_None
AIS_CS_Connection = _AIS.AIS_CS_Connection
AIS_CS_Transform = _AIS.AIS_CS_Transform
AIS_CS_Both = _AIS.AIS_CS_Both
AIS_DSM_All = _AIS.AIS_DSM_All
AIS_DSM_Line = _AIS.AIS_DSM_Line
AIS_DSM_Text = _AIS.AIS_DSM_Text
AIS_WireFrame = _AIS.AIS_WireFrame
AIS_Shaded = _AIS.AIS_Shaded
AIS_DSS_No = _AIS.AIS_DSS_No
AIS_DSS_Before = _AIS.AIS_DSS_Before
AIS_DSS_After = _AIS.AIS_DSS_After
AIS_DS_Displayed = _AIS.AIS_DS_Displayed
AIS_DS_Erased = _AIS.AIS_DS_Erased
AIS_DS_Temporary = _AIS.AIS_DS_Temporary
AIS_DS_None = _AIS.AIS_DS_None
AIS_KOD_NONE = _AIS.AIS_KOD_NONE
AIS_KOD_LENGTH = _AIS.AIS_KOD_LENGTH
AIS_KOD_PLANEANGLE = _AIS.AIS_KOD_PLANEANGLE
AIS_KOD_SOLIDANGLE = _AIS.AIS_KOD_SOLIDANGLE
AIS_KOD_AREA = _AIS.AIS_KOD_AREA
AIS_KOD_VOLUME = _AIS.AIS_KOD_VOLUME
AIS_KOD_MASS = _AIS.AIS_KOD_MASS
AIS_KOD_TIME = _AIS.AIS_KOD_TIME
AIS_KOD_RADIUS = _AIS.AIS_KOD_RADIUS
AIS_KOD_DIAMETER = _AIS.AIS_KOD_DIAMETER
AIS_KOD_CHAMF2D = _AIS.AIS_KOD_CHAMF2D
AIS_KOD_CHAMF3D = _AIS.AIS_KOD_CHAMF3D
AIS_KOD_OFFSET = _AIS.AIS_KOD_OFFSET
AIS_KOD_ELLIPSERADIUS = _AIS.AIS_KOD_ELLIPSERADIUS
AIS_KOI_None = _AIS.AIS_KOI_None
AIS_KOI_Datum = _AIS.AIS_KOI_Datum
AIS_KOI_Shape = _AIS.AIS_KOI_Shape
AIS_KOI_Object = _AIS.AIS_KOI_Object
AIS_KOI_Relation = _AIS.AIS_KOI_Relation
AIS_KOI_Dimension = _AIS.AIS_KOI_Dimension
AIS_KOS_Plane = _AIS.AIS_KOS_Plane
AIS_KOS_Cylinder = _AIS.AIS_KOS_Cylinder
AIS_KOS_Cone = _AIS.AIS_KOS_Cone
AIS_KOS_Sphere = _AIS.AIS_KOS_Sphere
AIS_KOS_Torus = _AIS.AIS_KOS_Torus
AIS_KOS_Revolution = _AIS.AIS_KOS_Revolution
AIS_KOS_Extrusion = _AIS.AIS_KOS_Extrusion
AIS_KOS_OtherSurface = _AIS.AIS_KOS_OtherSurface
AIS_TOU_LENGTH = _AIS.AIS_TOU_LENGTH
AIS_TOU_SURFACE = _AIS.AIS_TOU_SURFACE
AIS_TOU_VOLUME = _AIS.AIS_TOU_VOLUME
AIS_TOU_PLANE_ANGLE = _AIS.AIS_TOU_PLANE_ANGLE
AIS_TOU_SOLID_ANGLE = _AIS.AIS_TOU_SOLID_ANGLE
AIS_TOU_MASS = _AIS.AIS_TOU_MASS
AIS_TOU_FORCE = _AIS.AIS_TOU_FORCE
AIS_TOU_TIME = _AIS.AIS_TOU_TIME
AIS_SS_Added = _AIS.AIS_SS_Added
AIS_SS_Removed = _AIS.AIS_SS_Removed
AIS_SS_NotDone = _AIS.AIS_SS_NotDone
AIS_SD_None = _AIS.AIS_SD_None
AIS_SD_Point = _AIS.AIS_SD_Point
AIS_SD_Axis = _AIS.AIS_SD_Axis
AIS_SD_Trihedron = _AIS.AIS_SD_Trihedron
AIS_SD_PlaneTrihedron = _AIS.AIS_SD_PlaneTrihedron
AIS_SD_Line = _AIS.AIS_SD_Line
AIS_SD_Circle = _AIS.AIS_SD_Circle
AIS_SD_Plane = _AIS.AIS_SD_Plane
AIS_SOD_Error = _AIS.AIS_SOD_Error
AIS_SOD_Nothing = _AIS.AIS_SOD_Nothing
AIS_SOD_AllBad = _AIS.AIS_SOD_AllBad
AIS_SOD_Selected = _AIS.AIS_SOD_Selected
AIS_SOD_OnlyOneDetected = _AIS.AIS_SOD_OnlyOneDetected
AIS_SOD_OnlyOneGood = _AIS.AIS_SOD_OnlyOneGood
AIS_SOD_SeveralGood = _AIS.AIS_SOD_SeveralGood
AIS_SOP_Error = _AIS.AIS_SOP_Error
AIS_SOP_NothingSelected = _AIS.AIS_SOP_NothingSelected
AIS_SOP_Removed = _AIS.AIS_SOP_Removed
AIS_SOP_OneSelected = _AIS.AIS_SOP_OneSelected
AIS_SOP_SeveralSelected = _AIS.AIS_SOP_SeveralSelected
AIS_TOA_Line = _AIS.AIS_TOA_Line
AIS_TOA_Dimension = _AIS.AIS_TOA_Dimension
AIS_TOA_Wire = _AIS.AIS_TOA_Wire
AIS_TOA_Plane = _AIS.AIS_TOA_Plane
AIS_TOA_Vector = _AIS.AIS_TOA_Vector
AIS_TOA_UIso = _AIS.AIS_TOA_UIso
AIS_TOA_VIso = _AIS.AIS_TOA_VIso
AIS_TOA_Free = _AIS.AIS_TOA_Free
AIS_TOA_UnFree = _AIS.AIS_TOA_UnFree
AIS_TOA_Section = _AIS.AIS_TOA_Section
AIS_TOA_Hidden = _AIS.AIS_TOA_Hidden
AIS_TOA_Seen = _AIS.AIS_TOA_Seen
AIS_TOA_FirstAxis = _AIS.AIS_TOA_FirstAxis
AIS_TOA_SecondAxis = _AIS.AIS_TOA_SecondAxis
AIS_TOA_ThirdAxis = _AIS.AIS_TOA_ThirdAxis
AIS_TOAX_Unknown = _AIS.AIS_TOAX_Unknown
AIS_TOAX_XAxis = _AIS.AIS_TOAX_XAxis
AIS_TOAX_YAxis = _AIS.AIS_TOAX_YAxis
AIS_TOAX_ZAxis = _AIS.AIS_TOAX_ZAxis
AIS_TOD_Unknown = _AIS.AIS_TOD_Unknown
AIS_TOD_Horizontal = _AIS.AIS_TOD_Horizontal
AIS_TOD_Vertical = _AIS.AIS_TOD_Vertical
AIS_TOI_IsoU = _AIS.AIS_TOI_IsoU
AIS_TOI_IsoV = _AIS.AIS_TOI_IsoV
AIS_TOI_Both = _AIS.AIS_TOI_Both
AIS_TOPL_Unknown = _AIS.AIS_TOPL_Unknown
AIS_TOPL_XYPlane = _AIS.AIS_TOPL_XYPlane
AIS_TOPL_XZPlane = _AIS.AIS_TOPL_XZPlane
AIS_TOPL_YZPlane = _AIS.AIS_TOPL_YZPlane
class ais(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nearest(*args) -> "Standard_Boolean":
        """
        * Returns the nearest point in a shape. This is used by several classes in calculation of dimensions.

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aPoint:
        :type aPoint: gp_Pnt
        :rtype: gp_Pnt

        * returns the nearest point on the line.

        :param theLine:
        :type theLine: gp_Lin
        :param thePoint:
        :type thePoint: gp_Pnt
        :rtype: gp_Pnt

        * For the given point finds nearest point on the curve, returns True if found point is belongs to the curve and False otherwise.

        :param theCurve:
        :type theCurve: Handle_Geom_Curve &
        :param thePoint:
        :type thePoint: gp_Pnt
        :param theFirstPoint:
        :type theFirstPoint: gp_Pnt
        :param theLastPoint:
        :type theLastPoint: gp_Pnt
        :param theNearestPoint:
        :type theNearestPoint: gp_Pnt
        :rtype: bool

        """
        return _AIS.ais_Nearest(*args)

    Nearest = staticmethod(Nearest)

    def Farest(*args) -> "gp_Pnt":
        """
        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aPoint:
        :type aPoint: gp_Pnt
        :rtype: gp_Pnt

        """
        return _AIS.ais_Farest(*args)

    Farest = staticmethod(Farest)

    def ComputeGeomCurve(*args) -> "Standard_Boolean &":
        """
        * Checks if aCurve belongs to aPlane; if not, projects aCurve in aPlane and returns aCurve; Return True if ok

        :param aCurve:
        :type aCurve: Handle_Geom_Curve &
        :param first1:
        :type first1: float
        :param last1:
        :type last1: float
        :param FirstPnt1:
        :type FirstPnt1: gp_Pnt
        :param LastPnt1:
        :type LastPnt1: gp_Pnt
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :param isOnPlane:
        :type isOnPlane: bool
        :rtype: bool

        """
        return _AIS.ais_ComputeGeomCurve(*args)

    ComputeGeomCurve = staticmethod(ComputeGeomCurve)

    def ComputeGeometry(*args) -> "Standard_Boolean &":
        """
        * Used by 2d Relation only Computes the 3d geometry of <anEdge> in the current WorkingPlane and the extremities if any Return True if ok.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theCurve:
        :type theCurve: Handle_Geom_Curve &
        :param theFirstPnt:
        :type theFirstPnt: gp_Pnt
        :param theLastPnt:
        :type theLastPnt: gp_Pnt
        :rtype: bool

        * Used by dimensions only. Computes the 3d geometry of <anEdge>. Return True if ok.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theCurve:
        :type theCurve: Handle_Geom_Curve &
        :param theFirstPnt:
        :type theFirstPnt: gp_Pnt
        :param theLastPnt:
        :type theLastPnt: gp_Pnt
        :param theIsInfinite:
        :type theIsInfinite: bool
        :rtype: bool

        * Used by 2d Relation only Computes the 3d geometry of <anEdge> in the current WorkingPlane and the extremities if any. If <aCurve> is not in the current plane, <extCurve> contains the not projected curve associated to <anEdge>. If <anEdge> is infinite, <isinfinite> = true and the 2 parameters <FirstPnt> and <LastPnt> have no signification. Return True if ok.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theCurve:
        :type theCurve: Handle_Geom_Curve &
        :param theFirstPnt:
        :type theFirstPnt: gp_Pnt
        :param theLastPnt:
        :type theLastPnt: gp_Pnt
        :param theExtCurve:
        :type theExtCurve: Handle_Geom_Curve &
        :param theIsInfinite:
        :type theIsInfinite: bool
        :param theIsOnPlane:
        :type theIsOnPlane: bool
        :param thePlane:
        :type thePlane: Handle_Geom_Plane &
        :rtype: bool

        * Used by 2d Relation only Computes the 3d geometry of <anEdge> in the current WorkingPlane and the extremities if any Return True if ok.

        :param theFirstEdge:
        :type theFirstEdge: TopoDS_Edge &
        :param theSecondEdge:
        :type theSecondEdge: TopoDS_Edge &
        :param theFirstCurve:
        :type theFirstCurve: Handle_Geom_Curve &
        :param theSecondCurve:
        :type theSecondCurve: Handle_Geom_Curve &
        :param theFirstPnt1:
        :type theFirstPnt1: gp_Pnt
        :param theLastPnt1:
        :type theLastPnt1: gp_Pnt
        :param theFirstPnt2:
        :type theFirstPnt2: gp_Pnt
        :param theLastPnt2:
        :type theLastPnt2: gp_Pnt
        :param thePlane:
        :type thePlane: Handle_Geom_Plane &
        :rtype: bool

        * Used by dimensions only.Computes the 3d geometry of<anEdge1> and <anEdge2> and checks if they are infinite.

        :param theFirstEdge:
        :type theFirstEdge: TopoDS_Edge &
        :param theSecondEdge:
        :type theSecondEdge: TopoDS_Edge &
        :param theFirstCurve:
        :type theFirstCurve: Handle_Geom_Curve &
        :param theSecondCurve:
        :type theSecondCurve: Handle_Geom_Curve &
        :param theFirstPnt1:
        :type theFirstPnt1: gp_Pnt
        :param theLastPnt1:
        :type theLastPnt1: gp_Pnt
        :param theFirstPnt2:
        :type theFirstPnt2: gp_Pnt
        :param theLastPnt2:
        :type theLastPnt2: gp_Pnt
        :param theIsinfinite1:
        :type theIsinfinite1: bool
        :param theIsinfinite2:
        :type theIsinfinite2: bool
        :rtype: bool

        * Used by 2d Relation only Computes the 3d geometry of<anEdge1> and <anEdge2> in the current Plane and the extremities if any. Return in ExtCurve the 3d curve (not projected in the plane) of the first edge if <indexExt> =1 or of the 2nd edge if <indexExt> = 2. If <indexExt> = 0, ExtCurve is Null. if there is an edge external to the plane, <isinfinite> is true if this edge is infinite. So, the extremities of it are not significant. Return True if ok

        :param theFirstEdge:
        :type theFirstEdge: TopoDS_Edge &
        :param theSecondEdge:
        :type theSecondEdge: TopoDS_Edge &
        :param theExtIndex:
        :type theExtIndex: int &
        :param theFirstCurve:
        :type theFirstCurve: Handle_Geom_Curve &
        :param theSecondCurve:
        :type theSecondCurve: Handle_Geom_Curve &
        :param theFirstPnt1:
        :type theFirstPnt1: gp_Pnt
        :param theLastPnt1:
        :type theLastPnt1: gp_Pnt
        :param theFirstPnt2:
        :type theFirstPnt2: gp_Pnt
        :param theLastPnt2:
        :type theLastPnt2: gp_Pnt
        :param theExtCurve:
        :type theExtCurve: Handle_Geom_Curve &
        :param theIsinfinite1:
        :type theIsinfinite1: bool
        :param theIsinfinite2:
        :type theIsinfinite2: bool
        :param thePlane:
        :type thePlane: Handle_Geom_Plane &
        :rtype: bool

        :param aVertex:
        :type aVertex: TopoDS_Vertex &
        :param point:
        :type point: gp_Pnt
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :param isOnPlane:
        :type isOnPlane: bool
        :rtype: bool

        """
        return _AIS.ais_ComputeGeometry(*args)

    ComputeGeometry = staticmethod(ComputeGeometry)

    def GetPlaneFromFace(*args) -> "Standard_Real &":
        """
        * Tryes to get Plane from Face. Returns Surface of Face in aSurf. Returns Standard_True and Plane of Face in aPlane in following cases: Face is Plane, Offset of Plane, Extrusion of Line and Offset of Extrusion of Line Returns pure type of Surface which can be: Plane, Cylinder, Cone, Sphere, Torus, SurfaceOfRevolution, SurfaceOfExtrusion

        :param aFace:
        :type aFace: TopoDS_Face &
        :param aPlane:
        :type aPlane: gp_Pln
        :param aSurf:
        :type aSurf: Handle_Geom_Surface &
        :param aSurfType:
        :type aSurfType: AIS_KindOfSurface &
        :param Offset:
        :type Offset: float &
        :rtype: bool

        """
        return _AIS.ais_GetPlaneFromFace(*args)

    GetPlaneFromFace = staticmethod(GetPlaneFromFace)

    def InitFaceLength(*args) -> "Standard_Real &":
        """
        :param aFace:
        :type aFace: TopoDS_Face &
        :param aPlane:
        :type aPlane: gp_Pln
        :param aSurface:
        :type aSurface: Handle_Geom_Surface &
        :param aSurfaceType:
        :type aSurfaceType: AIS_KindOfSurface &
        :param anOffset:
        :type anOffset: float &
        :rtype: void

        """
        return _AIS.ais_InitFaceLength(*args)

    InitFaceLength = staticmethod(InitFaceLength)

    def InitLengthBetweenCurvilinearFaces(*args) -> "void":
        """
        * Finds attachment points on two curvilinear faces for length dimension. @param thePlaneDir [in] the direction on the dimension plane to compute the plane automatically. It will not be taken into account if plane is defined by user.

        :param theFirstFace:
        :type theFirstFace: TopoDS_Face &
        :param theSecondFace:
        :type theSecondFace: TopoDS_Face &
        :param theFirstSurf:
        :type theFirstSurf: Handle_Geom_Surface &
        :param theSecondSurf:
        :type theSecondSurf: Handle_Geom_Surface &
        :param theFirstAttach:
        :type theFirstAttach: gp_Pnt
        :param theSecondAttach:
        :type theSecondAttach: gp_Pnt
        :param theDirOnPlane:
        :type theDirOnPlane: gp_Dir
        :rtype: void

        """
        return _AIS.ais_InitLengthBetweenCurvilinearFaces(*args)

    InitLengthBetweenCurvilinearFaces = staticmethod(InitLengthBetweenCurvilinearFaces)

    def InitAngleBetweenPlanarFaces(*args) -> "Standard_Boolean":
        """
        * Finds three points for the angle dimension between two planes.

        :param theFirstFace:
        :type theFirstFace: TopoDS_Face &
        :param theSecondFace:
        :type theSecondFace: TopoDS_Face &
        :param theCenter:
        :type theCenter: gp_Pnt
        :param theFirstAttach:
        :type theFirstAttach: gp_Pnt
        :param theSecondAttach:
        :type theSecondAttach: gp_Pnt
        :param theIsFirstPointSet: default value is Standard_False
        :type theIsFirstPointSet: bool
        :rtype: bool

        """
        return _AIS.ais_InitAngleBetweenPlanarFaces(*args)

    InitAngleBetweenPlanarFaces = staticmethod(InitAngleBetweenPlanarFaces)

    def InitAngleBetweenCurvilinearFaces(*args) -> "Standard_Boolean":
        """
        * Finds three points for the angle dimension between two curvilinear surfaces.

        :param theFirstFace:
        :type theFirstFace: TopoDS_Face &
        :param theSecondFace:
        :type theSecondFace: TopoDS_Face &
        :param theFirstSurfType:
        :type theFirstSurfType: AIS_KindOfSurface
        :param theSecondSurfType:
        :type theSecondSurfType: AIS_KindOfSurface
        :param theCenter:
        :type theCenter: gp_Pnt
        :param theFirstAttach:
        :type theFirstAttach: gp_Pnt
        :param theSecondAttach:
        :type theSecondAttach: gp_Pnt
        :param theIsFirstPointSet: default value is Standard_False
        :type theIsFirstPointSet: bool
        :rtype: bool

        """
        return _AIS.ais_InitAngleBetweenCurvilinearFaces(*args)

    InitAngleBetweenCurvilinearFaces = staticmethod(InitAngleBetweenCurvilinearFaces)

    def ProjectPointOnPlane(*args) -> "gp_Pnt":
        """
        :param aPoint:
        :type aPoint: gp_Pnt
        :param aPlane:
        :type aPlane: gp_Pln
        :rtype: gp_Pnt

        """
        return _AIS.ais_ProjectPointOnPlane(*args)

    ProjectPointOnPlane = staticmethod(ProjectPointOnPlane)

    def ProjectPointOnLine(*args) -> "gp_Pnt":
        """
        :param aPoint:
        :type aPoint: gp_Pnt
        :param aLine:
        :type aLine: gp_Lin
        :rtype: gp_Pnt

        """
        return _AIS.ais_ProjectPointOnLine(*args)

    ProjectPointOnLine = staticmethod(ProjectPointOnLine)

    def TranslatePointToBound(*args) -> "gp_Pnt":
        """
        :param aPoint:
        :type aPoint: gp_Pnt
        :param aDir:
        :type aDir: gp_Dir
        :param aBndBox:
        :type aBndBox: Bnd_Box &
        :rtype: gp_Pnt

        """
        return _AIS.ais_TranslatePointToBound(*args)

    TranslatePointToBound = staticmethod(TranslatePointToBound)

    def InDomain(*args) -> "Standard_Boolean":
        """
        * returns True if point with anAttachPar is in domain of arc

        :param aFirstPar:
        :type aFirstPar: float
        :param aLastPar:
        :type aLastPar: float
        :param anAttachPar:
        :type anAttachPar: float
        :rtype: bool

        """
        return _AIS.ais_InDomain(*args)

    InDomain = staticmethod(InDomain)

    def NearestApex(*args) -> "Standard_Boolean &":
        """
        * computes nearest to ellipse arc apex

        :param elips:
        :type elips: gp_Elips
        :param pApex:
        :type pApex: gp_Pnt
        :param nApex:
        :type nApex: gp_Pnt
        :param fpara:
        :type fpara: float
        :param lpara:
        :type lpara: float
        :param IsInDomain:
        :type IsInDomain: bool
        :rtype: gp_Pnt

        """
        return _AIS.ais_NearestApex(*args)

    NearestApex = staticmethod(NearestApex)

    def DistanceFromApex(*args) -> "Standard_Real":
        """
        * computes length of ellipse arc in parametric units

        :param elips:
        :type elips: gp_Elips
        :param Apex:
        :type Apex: gp_Pnt
        :param par:
        :type par: float
        :rtype: float

        """
        return _AIS.ais_DistanceFromApex(*args)

    DistanceFromApex = staticmethod(DistanceFromApex)

    def ComputeProjEdgePresentation(*args) -> "void":
        """
        :param aPres:
        :type aPres: Handle_Prs3d_Presentation &
        :param aDrawer:
        :type aDrawer: Handle_AIS_Drawer &
        :param anEdge:
        :type anEdge: TopoDS_Edge &
        :param ProjCurve:
        :type ProjCurve: Handle_Geom_Curve &
        :param FirstP:
        :type FirstP: gp_Pnt
        :param LastP:
        :type LastP: gp_Pnt
        :param aColor: default value is Quantity_NOC_PURPLE
        :type aColor: Quantity_NameOfColor
        :param aWidth: default value is 2
        :type aWidth: float
        :param aProjTOL: default value is Aspect_TOL_DASH
        :type aProjTOL: Aspect_TypeOfLine
        :param aCallTOL: default value is Aspect_TOL_DOT
        :type aCallTOL: Aspect_TypeOfLine
        :rtype: void

        """
        return _AIS.ais_ComputeProjEdgePresentation(*args)

    ComputeProjEdgePresentation = staticmethod(ComputeProjEdgePresentation)

    def ComputeProjVertexPresentation(*args) -> "void":
        """
        :param aPres:
        :type aPres: Handle_Prs3d_Presentation &
        :param aDrawer:
        :type aDrawer: Handle_AIS_Drawer &
        :param aVertex:
        :type aVertex: TopoDS_Vertex &
        :param ProjPoint:
        :type ProjPoint: gp_Pnt
        :param aColor: default value is Quantity_NOC_PURPLE
        :type aColor: Quantity_NameOfColor
        :param aWidth: default value is 2
        :type aWidth: float
        :param aProjTOM: default value is Aspect_TOM_PLUS
        :type aProjTOM: Aspect_TypeOfMarker
        :param aCallTOL: default value is Aspect_TOL_DOT
        :type aCallTOL: Aspect_TypeOfLine
        :rtype: void

        """
        return _AIS.ais_ComputeProjVertexPresentation(*args)

    ComputeProjVertexPresentation = staticmethod(ComputeProjVertexPresentation)

    __repr__ = _dumps_object


    def __init__(self):
        _AIS.ais_swiginit(self, _AIS.new_ais())
    __swig_destroy__ = _AIS.delete_ais
ais_swigregister = _AIS.ais_swigregister
ais_swigregister(ais)

def ais_Nearest(*args) -> "Standard_Boolean":
    """
    * Returns the nearest point in a shape. This is used by several classes in calculation of dimensions.

    :param aShape:
    :type aShape: TopoDS_Shape &
    :param aPoint:
    :type aPoint: gp_Pnt
    :rtype: gp_Pnt

    * returns the nearest point on the line.

    :param theLine:
    :type theLine: gp_Lin
    :param thePoint:
    :type thePoint: gp_Pnt
    :rtype: gp_Pnt

    * For the given point finds nearest point on the curve, returns True if found point is belongs to the curve and False otherwise.

    :param theCurve:
    :type theCurve: Handle_Geom_Curve &
    :param thePoint:
    :type thePoint: gp_Pnt
    :param theFirstPoint:
    :type theFirstPoint: gp_Pnt
    :param theLastPoint:
    :type theLastPoint: gp_Pnt
    :param theNearestPoint:
    :type theNearestPoint: gp_Pnt
    :rtype: bool

    """
    return _AIS.ais_Nearest(*args)

def ais_Farest(*args) -> "gp_Pnt":
    """
    :param aShape:
    :type aShape: TopoDS_Shape &
    :param aPoint:
    :type aPoint: gp_Pnt
    :rtype: gp_Pnt

    """
    return _AIS.ais_Farest(*args)

def ais_ComputeGeomCurve(*args) -> "Standard_Boolean &":
    """
    * Checks if aCurve belongs to aPlane; if not, projects aCurve in aPlane and returns aCurve; Return True if ok

    :param aCurve:
    :type aCurve: Handle_Geom_Curve &
    :param first1:
    :type first1: float
    :param last1:
    :type last1: float
    :param FirstPnt1:
    :type FirstPnt1: gp_Pnt
    :param LastPnt1:
    :type LastPnt1: gp_Pnt
    :param aPlane:
    :type aPlane: Handle_Geom_Plane &
    :param isOnPlane:
    :type isOnPlane: bool
    :rtype: bool

    """
    return _AIS.ais_ComputeGeomCurve(*args)

def ais_ComputeGeometry(*args) -> "Standard_Boolean &":
    """
    * Used by 2d Relation only Computes the 3d geometry of <anEdge> in the current WorkingPlane and the extremities if any Return True if ok.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theCurve:
    :type theCurve: Handle_Geom_Curve &
    :param theFirstPnt:
    :type theFirstPnt: gp_Pnt
    :param theLastPnt:
    :type theLastPnt: gp_Pnt
    :rtype: bool

    * Used by dimensions only. Computes the 3d geometry of <anEdge>. Return True if ok.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theCurve:
    :type theCurve: Handle_Geom_Curve &
    :param theFirstPnt:
    :type theFirstPnt: gp_Pnt
    :param theLastPnt:
    :type theLastPnt: gp_Pnt
    :param theIsInfinite:
    :type theIsInfinite: bool
    :rtype: bool

    * Used by 2d Relation only Computes the 3d geometry of <anEdge> in the current WorkingPlane and the extremities if any. If <aCurve> is not in the current plane, <extCurve> contains the not projected curve associated to <anEdge>. If <anEdge> is infinite, <isinfinite> = true and the 2 parameters <FirstPnt> and <LastPnt> have no signification. Return True if ok.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theCurve:
    :type theCurve: Handle_Geom_Curve &
    :param theFirstPnt:
    :type theFirstPnt: gp_Pnt
    :param theLastPnt:
    :type theLastPnt: gp_Pnt
    :param theExtCurve:
    :type theExtCurve: Handle_Geom_Curve &
    :param theIsInfinite:
    :type theIsInfinite: bool
    :param theIsOnPlane:
    :type theIsOnPlane: bool
    :param thePlane:
    :type thePlane: Handle_Geom_Plane &
    :rtype: bool

    * Used by 2d Relation only Computes the 3d geometry of <anEdge> in the current WorkingPlane and the extremities if any Return True if ok.

    :param theFirstEdge:
    :type theFirstEdge: TopoDS_Edge &
    :param theSecondEdge:
    :type theSecondEdge: TopoDS_Edge &
    :param theFirstCurve:
    :type theFirstCurve: Handle_Geom_Curve &
    :param theSecondCurve:
    :type theSecondCurve: Handle_Geom_Curve &
    :param theFirstPnt1:
    :type theFirstPnt1: gp_Pnt
    :param theLastPnt1:
    :type theLastPnt1: gp_Pnt
    :param theFirstPnt2:
    :type theFirstPnt2: gp_Pnt
    :param theLastPnt2:
    :type theLastPnt2: gp_Pnt
    :param thePlane:
    :type thePlane: Handle_Geom_Plane &
    :rtype: bool

    * Used by dimensions only.Computes the 3d geometry of<anEdge1> and <anEdge2> and checks if they are infinite.

    :param theFirstEdge:
    :type theFirstEdge: TopoDS_Edge &
    :param theSecondEdge:
    :type theSecondEdge: TopoDS_Edge &
    :param theFirstCurve:
    :type theFirstCurve: Handle_Geom_Curve &
    :param theSecondCurve:
    :type theSecondCurve: Handle_Geom_Curve &
    :param theFirstPnt1:
    :type theFirstPnt1: gp_Pnt
    :param theLastPnt1:
    :type theLastPnt1: gp_Pnt
    :param theFirstPnt2:
    :type theFirstPnt2: gp_Pnt
    :param theLastPnt2:
    :type theLastPnt2: gp_Pnt
    :param theIsinfinite1:
    :type theIsinfinite1: bool
    :param theIsinfinite2:
    :type theIsinfinite2: bool
    :rtype: bool

    * Used by 2d Relation only Computes the 3d geometry of<anEdge1> and <anEdge2> in the current Plane and the extremities if any. Return in ExtCurve the 3d curve (not projected in the plane) of the first edge if <indexExt> =1 or of the 2nd edge if <indexExt> = 2. If <indexExt> = 0, ExtCurve is Null. if there is an edge external to the plane, <isinfinite> is true if this edge is infinite. So, the extremities of it are not significant. Return True if ok

    :param theFirstEdge:
    :type theFirstEdge: TopoDS_Edge &
    :param theSecondEdge:
    :type theSecondEdge: TopoDS_Edge &
    :param theExtIndex:
    :type theExtIndex: int &
    :param theFirstCurve:
    :type theFirstCurve: Handle_Geom_Curve &
    :param theSecondCurve:
    :type theSecondCurve: Handle_Geom_Curve &
    :param theFirstPnt1:
    :type theFirstPnt1: gp_Pnt
    :param theLastPnt1:
    :type theLastPnt1: gp_Pnt
    :param theFirstPnt2:
    :type theFirstPnt2: gp_Pnt
    :param theLastPnt2:
    :type theLastPnt2: gp_Pnt
    :param theExtCurve:
    :type theExtCurve: Handle_Geom_Curve &
    :param theIsinfinite1:
    :type theIsinfinite1: bool
    :param theIsinfinite2:
    :type theIsinfinite2: bool
    :param thePlane:
    :type thePlane: Handle_Geom_Plane &
    :rtype: bool

    :param aVertex:
    :type aVertex: TopoDS_Vertex &
    :param point:
    :type point: gp_Pnt
    :param aPlane:
    :type aPlane: Handle_Geom_Plane &
    :param isOnPlane:
    :type isOnPlane: bool
    :rtype: bool

    """
    return _AIS.ais_ComputeGeometry(*args)

def ais_GetPlaneFromFace(*args) -> "Standard_Real &":
    """
    * Tryes to get Plane from Face. Returns Surface of Face in aSurf. Returns Standard_True and Plane of Face in aPlane in following cases: Face is Plane, Offset of Plane, Extrusion of Line and Offset of Extrusion of Line Returns pure type of Surface which can be: Plane, Cylinder, Cone, Sphere, Torus, SurfaceOfRevolution, SurfaceOfExtrusion

    :param aFace:
    :type aFace: TopoDS_Face &
    :param aPlane:
    :type aPlane: gp_Pln
    :param aSurf:
    :type aSurf: Handle_Geom_Surface &
    :param aSurfType:
    :type aSurfType: AIS_KindOfSurface &
    :param Offset:
    :type Offset: float &
    :rtype: bool

    """
    return _AIS.ais_GetPlaneFromFace(*args)

def ais_InitFaceLength(*args) -> "Standard_Real &":
    """
    :param aFace:
    :type aFace: TopoDS_Face &
    :param aPlane:
    :type aPlane: gp_Pln
    :param aSurface:
    :type aSurface: Handle_Geom_Surface &
    :param aSurfaceType:
    :type aSurfaceType: AIS_KindOfSurface &
    :param anOffset:
    :type anOffset: float &
    :rtype: void

    """
    return _AIS.ais_InitFaceLength(*args)

def ais_InitLengthBetweenCurvilinearFaces(*args) -> "void":
    """
    * Finds attachment points on two curvilinear faces for length dimension. @param thePlaneDir [in] the direction on the dimension plane to compute the plane automatically. It will not be taken into account if plane is defined by user.

    :param theFirstFace:
    :type theFirstFace: TopoDS_Face &
    :param theSecondFace:
    :type theSecondFace: TopoDS_Face &
    :param theFirstSurf:
    :type theFirstSurf: Handle_Geom_Surface &
    :param theSecondSurf:
    :type theSecondSurf: Handle_Geom_Surface &
    :param theFirstAttach:
    :type theFirstAttach: gp_Pnt
    :param theSecondAttach:
    :type theSecondAttach: gp_Pnt
    :param theDirOnPlane:
    :type theDirOnPlane: gp_Dir
    :rtype: void

    """
    return _AIS.ais_InitLengthBetweenCurvilinearFaces(*args)

def ais_InitAngleBetweenPlanarFaces(*args) -> "Standard_Boolean":
    """
    * Finds three points for the angle dimension between two planes.

    :param theFirstFace:
    :type theFirstFace: TopoDS_Face &
    :param theSecondFace:
    :type theSecondFace: TopoDS_Face &
    :param theCenter:
    :type theCenter: gp_Pnt
    :param theFirstAttach:
    :type theFirstAttach: gp_Pnt
    :param theSecondAttach:
    :type theSecondAttach: gp_Pnt
    :param theIsFirstPointSet: default value is Standard_False
    :type theIsFirstPointSet: bool
    :rtype: bool

    """
    return _AIS.ais_InitAngleBetweenPlanarFaces(*args)

def ais_InitAngleBetweenCurvilinearFaces(*args) -> "Standard_Boolean":
    """
    * Finds three points for the angle dimension between two curvilinear surfaces.

    :param theFirstFace:
    :type theFirstFace: TopoDS_Face &
    :param theSecondFace:
    :type theSecondFace: TopoDS_Face &
    :param theFirstSurfType:
    :type theFirstSurfType: AIS_KindOfSurface
    :param theSecondSurfType:
    :type theSecondSurfType: AIS_KindOfSurface
    :param theCenter:
    :type theCenter: gp_Pnt
    :param theFirstAttach:
    :type theFirstAttach: gp_Pnt
    :param theSecondAttach:
    :type theSecondAttach: gp_Pnt
    :param theIsFirstPointSet: default value is Standard_False
    :type theIsFirstPointSet: bool
    :rtype: bool

    """
    return _AIS.ais_InitAngleBetweenCurvilinearFaces(*args)

def ais_ProjectPointOnPlane(*args) -> "gp_Pnt":
    """
    :param aPoint:
    :type aPoint: gp_Pnt
    :param aPlane:
    :type aPlane: gp_Pln
    :rtype: gp_Pnt

    """
    return _AIS.ais_ProjectPointOnPlane(*args)

def ais_ProjectPointOnLine(*args) -> "gp_Pnt":
    """
    :param aPoint:
    :type aPoint: gp_Pnt
    :param aLine:
    :type aLine: gp_Lin
    :rtype: gp_Pnt

    """
    return _AIS.ais_ProjectPointOnLine(*args)

def ais_TranslatePointToBound(*args) -> "gp_Pnt":
    """
    :param aPoint:
    :type aPoint: gp_Pnt
    :param aDir:
    :type aDir: gp_Dir
    :param aBndBox:
    :type aBndBox: Bnd_Box &
    :rtype: gp_Pnt

    """
    return _AIS.ais_TranslatePointToBound(*args)

def ais_InDomain(*args) -> "Standard_Boolean":
    """
    * returns True if point with anAttachPar is in domain of arc

    :param aFirstPar:
    :type aFirstPar: float
    :param aLastPar:
    :type aLastPar: float
    :param anAttachPar:
    :type anAttachPar: float
    :rtype: bool

    """
    return _AIS.ais_InDomain(*args)

def ais_NearestApex(*args) -> "Standard_Boolean &":
    """
    * computes nearest to ellipse arc apex

    :param elips:
    :type elips: gp_Elips
    :param pApex:
    :type pApex: gp_Pnt
    :param nApex:
    :type nApex: gp_Pnt
    :param fpara:
    :type fpara: float
    :param lpara:
    :type lpara: float
    :param IsInDomain:
    :type IsInDomain: bool
    :rtype: gp_Pnt

    """
    return _AIS.ais_NearestApex(*args)

def ais_DistanceFromApex(*args) -> "Standard_Real":
    """
    * computes length of ellipse arc in parametric units

    :param elips:
    :type elips: gp_Elips
    :param Apex:
    :type Apex: gp_Pnt
    :param par:
    :type par: float
    :rtype: float

    """
    return _AIS.ais_DistanceFromApex(*args)

def ais_ComputeProjEdgePresentation(*args) -> "void":
    """
    :param aPres:
    :type aPres: Handle_Prs3d_Presentation &
    :param aDrawer:
    :type aDrawer: Handle_AIS_Drawer &
    :param anEdge:
    :type anEdge: TopoDS_Edge &
    :param ProjCurve:
    :type ProjCurve: Handle_Geom_Curve &
    :param FirstP:
    :type FirstP: gp_Pnt
    :param LastP:
    :type LastP: gp_Pnt
    :param aColor: default value is Quantity_NOC_PURPLE
    :type aColor: Quantity_NameOfColor
    :param aWidth: default value is 2
    :type aWidth: float
    :param aProjTOL: default value is Aspect_TOL_DASH
    :type aProjTOL: Aspect_TypeOfLine
    :param aCallTOL: default value is Aspect_TOL_DOT
    :type aCallTOL: Aspect_TypeOfLine
    :rtype: void

    """
    return _AIS.ais_ComputeProjEdgePresentation(*args)

def ais_ComputeProjVertexPresentation(*args) -> "void":
    """
    :param aPres:
    :type aPres: Handle_Prs3d_Presentation &
    :param aDrawer:
    :type aDrawer: Handle_AIS_Drawer &
    :param aVertex:
    :type aVertex: TopoDS_Vertex &
    :param ProjPoint:
    :type ProjPoint: gp_Pnt
    :param aColor: default value is Quantity_NOC_PURPLE
    :type aColor: Quantity_NameOfColor
    :param aWidth: default value is 2
    :type aWidth: float
    :param aProjTOM: default value is Aspect_TOM_PLUS
    :type aProjTOM: Aspect_TypeOfMarker
    :param aCallTOL: default value is Aspect_TOL_DOT
    :type aCallTOL: Aspect_TypeOfLine
    :rtype: void

    """
    return _AIS.ais_ComputeProjVertexPresentation(*args)

class AIS_AttributeFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an empty attribute filter object. This filter object determines whether selectable interactive objects have a non-null owner.

        :rtype: None

        * Constructs an attribute filter object defined by the color attribute aCol.

        :param aCol:
        :type aCol: Quantity_NameOfColor
        :rtype: None

        * Constructs an attribute filter object defined by the line width attribute aWidth.

        :param aWidth:
        :type aWidth: float
        :rtype: None

        """
        _AIS.AIS_AttributeFilter_swiginit(self, _AIS.new_AIS_AttributeFilter(*args))

    def HasColor(self, *args) -> "Standard_Boolean":
        """
        * Indicates that the Interactive Object has the color setting specified by the argument aCol at construction time.

        :rtype: bool

        """
        return _AIS.AIS_AttributeFilter_HasColor(self, *args)


    def HasWidth(self, *args) -> "Standard_Boolean":
        """
        * Indicates that the Interactive Object has the width setting specified by the argument aWidth at construction time.

        :rtype: bool

        """
        return _AIS.AIS_AttributeFilter_HasWidth(self, *args)


    def SetColor(self, *args) -> "void":
        """
        * Sets the color aCol. This must be chosen from the list of colors in Quantity_NameOfColor.

        :param aCol:
        :type aCol: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_AttributeFilter_SetColor(self, *args)


    def SetWidth(self, *args) -> "void":
        """
        * Sets the line width aWidth.

        :param aWidth:
        :type aWidth: float
        :rtype: None

        """
        return _AIS.AIS_AttributeFilter_SetWidth(self, *args)


    def UnsetColor(self, *args) -> "void":
        """
        * Removes the setting for color from the filter.

        :rtype: None

        """
        return _AIS.AIS_AttributeFilter_UnsetColor(self, *args)


    def UnsetWidth(self, *args) -> "void":
        """
        * Removes the setting for width from the filter.

        :rtype: None

        """
        return _AIS.AIS_AttributeFilter_UnsetWidth(self, *args)


    def IsOk(self, *args) -> "Standard_Boolean":
        """
        * Indicates that the selected Interactive Object passes the filter. The owner, anObj, can be either direct or user. A direct owner is the corresponding construction element, whereas a user is the compound shape of which the entity forms a part. If the Interactive Object returns Standard_True when detected by the Local Context selector through the mouse, the object is kept; if not, it is rejected.

        :param anObj:
        :type anObj: Handle_SelectMgr_EntityOwner &
        :rtype: bool

        """
        return _AIS.AIS_AttributeFilter_IsOk(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_AttributeFilter(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_AttributeFilter
AIS_AttributeFilter.HasColor = new_instancemethod(_AIS.AIS_AttributeFilter_HasColor, None, AIS_AttributeFilter)
AIS_AttributeFilter.HasWidth = new_instancemethod(_AIS.AIS_AttributeFilter_HasWidth, None, AIS_AttributeFilter)
AIS_AttributeFilter.SetColor = new_instancemethod(_AIS.AIS_AttributeFilter_SetColor, None, AIS_AttributeFilter)
AIS_AttributeFilter.SetWidth = new_instancemethod(_AIS.AIS_AttributeFilter_SetWidth, None, AIS_AttributeFilter)
AIS_AttributeFilter.UnsetColor = new_instancemethod(_AIS.AIS_AttributeFilter_UnsetColor, None, AIS_AttributeFilter)
AIS_AttributeFilter.UnsetWidth = new_instancemethod(_AIS.AIS_AttributeFilter_UnsetWidth, None, AIS_AttributeFilter)
AIS_AttributeFilter.IsOk = new_instancemethod(_AIS.AIS_AttributeFilter_IsOk, None, AIS_AttributeFilter)
AIS_AttributeFilter_swigregister = _AIS.AIS_AttributeFilter_swigregister
AIS_AttributeFilter_swigregister(AIS_AttributeFilter)

class Handle_AIS_AttributeFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_AttributeFilter_swiginit(self, _AIS.new_Handle_AIS_AttributeFilter(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_AttributeFilter_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_AttributeFilter
Handle_AIS_AttributeFilter.Nullify = new_instancemethod(_AIS.Handle_AIS_AttributeFilter_Nullify, None, Handle_AIS_AttributeFilter)
Handle_AIS_AttributeFilter.IsNull = new_instancemethod(_AIS.Handle_AIS_AttributeFilter_IsNull, None, Handle_AIS_AttributeFilter)
Handle_AIS_AttributeFilter._get_reference = new_instancemethod(_AIS.Handle_AIS_AttributeFilter__get_reference, None, Handle_AIS_AttributeFilter)
Handle_AIS_AttributeFilter_swigregister = _AIS.Handle_AIS_AttributeFilter_swigregister
Handle_AIS_AttributeFilter_swigregister(Handle_AIS_AttributeFilter)

def Handle_AIS_AttributeFilter_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_AttributeFilter const":
    return _AIS.Handle_AIS_AttributeFilter_DownCast(AnObject)
Handle_AIS_AttributeFilter_DownCast = _AIS.Handle_AIS_AttributeFilter_DownCast

class AIS_BadEdgeFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an empty filter object for bad edges.

        :rtype: None

        """
        _AIS.AIS_BadEdgeFilter_swiginit(self, _AIS.new_AIS_BadEdgeFilter(*args))

    def ActsOn(self, *args) -> "Standard_Boolean":
        """
        :param aType:
        :type aType: TopAbs_ShapeEnum
        :rtype: bool

        """
        return _AIS.AIS_BadEdgeFilter_ActsOn(self, *args)


    def IsOk(self, *args) -> "Standard_Boolean":
        """
        :param EO:
        :type EO: Handle_SelectMgr_EntityOwner &
        :rtype: bool

        """
        return _AIS.AIS_BadEdgeFilter_IsOk(self, *args)


    def SetContour(self, *args) -> "void":
        """
        * sets <myContour> with current contour. used by IsOk.

        :param Index:
        :type Index: int
        :rtype: None

        """
        return _AIS.AIS_BadEdgeFilter_SetContour(self, *args)


    def AddEdge(self, *args) -> "void":
        """
        * Adds an edge to the list of non-selectionnable edges.

        :param anEdge:
        :type anEdge: TopoDS_Edge &
        :param Index:
        :type Index: int
        :rtype: None

        """
        return _AIS.AIS_BadEdgeFilter_AddEdge(self, *args)


    def RemoveEdges(self, *args) -> "void":
        """
        * removes from the list of non-selectionnable edges all edges in the contour <Index>.

        :param Index:
        :type Index: int
        :rtype: None

        """
        return _AIS.AIS_BadEdgeFilter_RemoveEdges(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_BadEdgeFilter(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_BadEdgeFilter
AIS_BadEdgeFilter.ActsOn = new_instancemethod(_AIS.AIS_BadEdgeFilter_ActsOn, None, AIS_BadEdgeFilter)
AIS_BadEdgeFilter.IsOk = new_instancemethod(_AIS.AIS_BadEdgeFilter_IsOk, None, AIS_BadEdgeFilter)
AIS_BadEdgeFilter.SetContour = new_instancemethod(_AIS.AIS_BadEdgeFilter_SetContour, None, AIS_BadEdgeFilter)
AIS_BadEdgeFilter.AddEdge = new_instancemethod(_AIS.AIS_BadEdgeFilter_AddEdge, None, AIS_BadEdgeFilter)
AIS_BadEdgeFilter.RemoveEdges = new_instancemethod(_AIS.AIS_BadEdgeFilter_RemoveEdges, None, AIS_BadEdgeFilter)
AIS_BadEdgeFilter_swigregister = _AIS.AIS_BadEdgeFilter_swigregister
AIS_BadEdgeFilter_swigregister(AIS_BadEdgeFilter)

class Handle_AIS_BadEdgeFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_BadEdgeFilter_swiginit(self, _AIS.new_Handle_AIS_BadEdgeFilter(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_BadEdgeFilter_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_BadEdgeFilter
Handle_AIS_BadEdgeFilter.Nullify = new_instancemethod(_AIS.Handle_AIS_BadEdgeFilter_Nullify, None, Handle_AIS_BadEdgeFilter)
Handle_AIS_BadEdgeFilter.IsNull = new_instancemethod(_AIS.Handle_AIS_BadEdgeFilter_IsNull, None, Handle_AIS_BadEdgeFilter)
Handle_AIS_BadEdgeFilter._get_reference = new_instancemethod(_AIS.Handle_AIS_BadEdgeFilter__get_reference, None, Handle_AIS_BadEdgeFilter)
Handle_AIS_BadEdgeFilter_swigregister = _AIS.Handle_AIS_BadEdgeFilter_swigregister
Handle_AIS_BadEdgeFilter_swigregister(Handle_AIS_BadEdgeFilter)

def Handle_AIS_BadEdgeFilter_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_BadEdgeFilter const":
    return _AIS.Handle_AIS_BadEdgeFilter_DownCast(AnObject)
Handle_AIS_BadEdgeFilter_DownCast = _AIS.Handle_AIS_BadEdgeFilter_DownCast

class AIS_C0RegularityFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param aShape:
        :type aShape: TopoDS_Shape &
        :rtype: None

        """
        _AIS.AIS_C0RegularityFilter_swiginit(self, _AIS.new_AIS_C0RegularityFilter(*args))

    def ActsOn(self, *args) -> "Standard_Boolean":
        """
        :param aType:
        :type aType: TopAbs_ShapeEnum
        :rtype: bool

        """
        return _AIS.AIS_C0RegularityFilter_ActsOn(self, *args)


    def IsOk(self, *args) -> "Standard_Boolean":
        """
        :param EO:
        :type EO: Handle_SelectMgr_EntityOwner &
        :rtype: bool

        """
        return _AIS.AIS_C0RegularityFilter_IsOk(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_C0RegularityFilter(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_C0RegularityFilter
AIS_C0RegularityFilter.ActsOn = new_instancemethod(_AIS.AIS_C0RegularityFilter_ActsOn, None, AIS_C0RegularityFilter)
AIS_C0RegularityFilter.IsOk = new_instancemethod(_AIS.AIS_C0RegularityFilter_IsOk, None, AIS_C0RegularityFilter)
AIS_C0RegularityFilter_swigregister = _AIS.AIS_C0RegularityFilter_swigregister
AIS_C0RegularityFilter_swigregister(AIS_C0RegularityFilter)

class Handle_AIS_C0RegularityFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_C0RegularityFilter_swiginit(self, _AIS.new_Handle_AIS_C0RegularityFilter(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_C0RegularityFilter_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_C0RegularityFilter
Handle_AIS_C0RegularityFilter.Nullify = new_instancemethod(_AIS.Handle_AIS_C0RegularityFilter_Nullify, None, Handle_AIS_C0RegularityFilter)
Handle_AIS_C0RegularityFilter.IsNull = new_instancemethod(_AIS.Handle_AIS_C0RegularityFilter_IsNull, None, Handle_AIS_C0RegularityFilter)
Handle_AIS_C0RegularityFilter._get_reference = new_instancemethod(_AIS.Handle_AIS_C0RegularityFilter__get_reference, None, Handle_AIS_C0RegularityFilter)
Handle_AIS_C0RegularityFilter_swigregister = _AIS.Handle_AIS_C0RegularityFilter_swigregister
Handle_AIS_C0RegularityFilter_swigregister(Handle_AIS_C0RegularityFilter)

def Handle_AIS_C0RegularityFilter_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_C0RegularityFilter const":
    return _AIS.Handle_AIS_C0RegularityFilter_DownCast(AnObject)
Handle_AIS_C0RegularityFilter_DownCast = _AIS.Handle_AIS_C0RegularityFilter_DownCast

class AIS_DataMapIteratorOfDataMapOfILC(OCC.TCollection.TCollection_BasicMapIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param aMap:
        :type aMap: AIS_DataMapOfILC &
        :rtype: None

        """
        _AIS.AIS_DataMapIteratorOfDataMapOfILC_swiginit(self, _AIS.new_AIS_DataMapIteratorOfDataMapOfILC(*args))

    def Initialize(self, *args) -> "void":
        """
        :param aMap:
        :type aMap: AIS_DataMapOfILC &
        :rtype: None

        """
        return _AIS.AIS_DataMapIteratorOfDataMapOfILC_Initialize(self, *args)


    def Key(self, *args) -> "Standard_Integer const &":
        """
        :rtype: int

        """
        return _AIS.AIS_DataMapIteratorOfDataMapOfILC_Key(self, *args)


    def Value(self, *args) -> "Handle_AIS_LocalContext":
        """
        :rtype: Handle_AIS_LocalContext

        """
        return _AIS.AIS_DataMapIteratorOfDataMapOfILC_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapIteratorOfDataMapOfILC
AIS_DataMapIteratorOfDataMapOfILC.Initialize = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapOfILC_Initialize, None, AIS_DataMapIteratorOfDataMapOfILC)
AIS_DataMapIteratorOfDataMapOfILC.Key = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapOfILC_Key, None, AIS_DataMapIteratorOfDataMapOfILC)
AIS_DataMapIteratorOfDataMapOfILC.Value = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapOfILC_Value, None, AIS_DataMapIteratorOfDataMapOfILC)
AIS_DataMapIteratorOfDataMapOfILC_swigregister = _AIS.AIS_DataMapIteratorOfDataMapOfILC_swigregister
AIS_DataMapIteratorOfDataMapOfILC_swigregister(AIS_DataMapIteratorOfDataMapOfILC)

class AIS_DataMapIteratorOfDataMapOfIOStatus(OCC.TCollection.TCollection_BasicMapIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param aMap:
        :type aMap: AIS_DataMapOfIOStatus &
        :rtype: None

        """
        _AIS.AIS_DataMapIteratorOfDataMapOfIOStatus_swiginit(self, _AIS.new_AIS_DataMapIteratorOfDataMapOfIOStatus(*args))

    def Initialize(self, *args) -> "void":
        """
        :param aMap:
        :type aMap: AIS_DataMapOfIOStatus &
        :rtype: None

        """
        return _AIS.AIS_DataMapIteratorOfDataMapOfIOStatus_Initialize(self, *args)


    def Key(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_DataMapIteratorOfDataMapOfIOStatus_Key(self, *args)


    def Value(self, *args) -> "Handle_AIS_GlobalStatus":
        """
        :rtype: Handle_AIS_GlobalStatus

        """
        return _AIS.AIS_DataMapIteratorOfDataMapOfIOStatus_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapIteratorOfDataMapOfIOStatus
AIS_DataMapIteratorOfDataMapOfIOStatus.Initialize = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapOfIOStatus_Initialize, None, AIS_DataMapIteratorOfDataMapOfIOStatus)
AIS_DataMapIteratorOfDataMapOfIOStatus.Key = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapOfIOStatus_Key, None, AIS_DataMapIteratorOfDataMapOfIOStatus)
AIS_DataMapIteratorOfDataMapOfIOStatus.Value = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapOfIOStatus_Value, None, AIS_DataMapIteratorOfDataMapOfIOStatus)
AIS_DataMapIteratorOfDataMapOfIOStatus_swigregister = _AIS.AIS_DataMapIteratorOfDataMapOfIOStatus_swigregister
AIS_DataMapIteratorOfDataMapOfIOStatus_swigregister(AIS_DataMapIteratorOfDataMapOfIOStatus)

class AIS_DataMapIteratorOfDataMapOfSelStat(OCC.TCollection.TCollection_BasicMapIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param aMap:
        :type aMap: AIS_DataMapOfSelStat &
        :rtype: None

        """
        _AIS.AIS_DataMapIteratorOfDataMapOfSelStat_swiginit(self, _AIS.new_AIS_DataMapIteratorOfDataMapOfSelStat(*args))

    def Initialize(self, *args) -> "void":
        """
        :param aMap:
        :type aMap: AIS_DataMapOfSelStat &
        :rtype: None

        """
        return _AIS.AIS_DataMapIteratorOfDataMapOfSelStat_Initialize(self, *args)


    def Key(self, *args) -> "Handle_SelectMgr_SelectableObject":
        """
        :rtype: Handle_SelectMgr_SelectableObject

        """
        return _AIS.AIS_DataMapIteratorOfDataMapOfSelStat_Key(self, *args)


    def Value(self, *args) -> "Handle_AIS_LocalStatus":
        """
        :rtype: Handle_AIS_LocalStatus

        """
        return _AIS.AIS_DataMapIteratorOfDataMapOfSelStat_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapIteratorOfDataMapOfSelStat
AIS_DataMapIteratorOfDataMapOfSelStat.Initialize = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapOfSelStat_Initialize, None, AIS_DataMapIteratorOfDataMapOfSelStat)
AIS_DataMapIteratorOfDataMapOfSelStat.Key = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapOfSelStat_Key, None, AIS_DataMapIteratorOfDataMapOfSelStat)
AIS_DataMapIteratorOfDataMapOfSelStat.Value = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapOfSelStat_Value, None, AIS_DataMapIteratorOfDataMapOfSelStat)
AIS_DataMapIteratorOfDataMapOfSelStat_swigregister = _AIS.AIS_DataMapIteratorOfDataMapOfSelStat_swigregister
AIS_DataMapIteratorOfDataMapOfSelStat_swigregister(AIS_DataMapIteratorOfDataMapOfSelStat)

class AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive(OCC.TCollection.TCollection_BasicMapIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param aMap:
        :type aMap: AIS_DataMapofIntegerListOfinteractive &
        :rtype: None

        """
        _AIS.AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_swiginit(self, _AIS.new_AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive(*args))

    def Initialize(self, *args) -> "void":
        """
        :param aMap:
        :type aMap: AIS_DataMapofIntegerListOfinteractive &
        :rtype: None

        """
        return _AIS.AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_Initialize(self, *args)


    def Key(self, *args) -> "Standard_Integer const &":
        """
        :rtype: int

        """
        return _AIS.AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_Key(self, *args)


    def Value(self, *args) -> "AIS_ListOfInteractive const &":
        """
        :rtype: AIS_ListOfInteractive

        """
        return _AIS.AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive
AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive.Initialize = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_Initialize, None, AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive)
AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive.Key = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_Key, None, AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive)
AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive.Value = new_instancemethod(_AIS.AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_Value, None, AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive)
AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_swigregister = _AIS.AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_swigregister
AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive_swigregister(AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive)

class AIS_DataMapNodeOfDataMapOfILC(OCC.TCollection.TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param K:
        :type K: int &
        :param I:
        :type I: Handle_AIS_LocalContext &
        :param n:
        :type n: TCollection_MapNodePtr &
        :rtype: None

        """
        _AIS.AIS_DataMapNodeOfDataMapOfILC_swiginit(self, _AIS.new_AIS_DataMapNodeOfDataMapOfILC(*args))

    def GetKey(self) -> "Standard_Integer":
        """GetKey(AIS_DataMapNodeOfDataMapOfILC self) -> Standard_Integer"""
        return _AIS.AIS_DataMapNodeOfDataMapOfILC_GetKey(self)


    def SetKey(self, value: 'Standard_Integer') -> "void":
        """SetKey(AIS_DataMapNodeOfDataMapOfILC self, Standard_Integer value)"""
        return _AIS.AIS_DataMapNodeOfDataMapOfILC_SetKey(self, value)


    def Value(self, *args) -> "Handle_AIS_LocalContext":
        """
        :rtype: Handle_AIS_LocalContext

        """
        return _AIS.AIS_DataMapNodeOfDataMapOfILC_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_DataMapNodeOfDataMapOfILC(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapNodeOfDataMapOfILC
AIS_DataMapNodeOfDataMapOfILC.GetKey = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapOfILC_GetKey, None, AIS_DataMapNodeOfDataMapOfILC)
AIS_DataMapNodeOfDataMapOfILC.SetKey = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapOfILC_SetKey, None, AIS_DataMapNodeOfDataMapOfILC)
AIS_DataMapNodeOfDataMapOfILC.Value = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapOfILC_Value, None, AIS_DataMapNodeOfDataMapOfILC)
AIS_DataMapNodeOfDataMapOfILC_swigregister = _AIS.AIS_DataMapNodeOfDataMapOfILC_swigregister
AIS_DataMapNodeOfDataMapOfILC_swigregister(AIS_DataMapNodeOfDataMapOfILC)

class Handle_AIS_DataMapNodeOfDataMapOfILC(OCC.TCollection.Handle_TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_DataMapNodeOfDataMapOfILC_swiginit(self, _AIS.new_Handle_AIS_DataMapNodeOfDataMapOfILC(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfILC_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_DataMapNodeOfDataMapOfILC
Handle_AIS_DataMapNodeOfDataMapOfILC.Nullify = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfILC_Nullify, None, Handle_AIS_DataMapNodeOfDataMapOfILC)
Handle_AIS_DataMapNodeOfDataMapOfILC.IsNull = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfILC_IsNull, None, Handle_AIS_DataMapNodeOfDataMapOfILC)
Handle_AIS_DataMapNodeOfDataMapOfILC._get_reference = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfILC__get_reference, None, Handle_AIS_DataMapNodeOfDataMapOfILC)
Handle_AIS_DataMapNodeOfDataMapOfILC_swigregister = _AIS.Handle_AIS_DataMapNodeOfDataMapOfILC_swigregister
Handle_AIS_DataMapNodeOfDataMapOfILC_swigregister(Handle_AIS_DataMapNodeOfDataMapOfILC)

def Handle_AIS_DataMapNodeOfDataMapOfILC_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_DataMapNodeOfDataMapOfILC const":
    return _AIS.Handle_AIS_DataMapNodeOfDataMapOfILC_DownCast(AnObject)
Handle_AIS_DataMapNodeOfDataMapOfILC_DownCast = _AIS.Handle_AIS_DataMapNodeOfDataMapOfILC_DownCast

class AIS_DataMapNodeOfDataMapOfIOStatus(OCC.TCollection.TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param K:
        :type K: Handle_AIS_InteractiveObject &
        :param I:
        :type I: Handle_AIS_GlobalStatus &
        :param n:
        :type n: TCollection_MapNodePtr &
        :rtype: None

        """
        _AIS.AIS_DataMapNodeOfDataMapOfIOStatus_swiginit(self, _AIS.new_AIS_DataMapNodeOfDataMapOfIOStatus(*args))

    def Key(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_DataMapNodeOfDataMapOfIOStatus_Key(self, *args)


    def Value(self, *args) -> "Handle_AIS_GlobalStatus":
        """
        :rtype: Handle_AIS_GlobalStatus

        """
        return _AIS.AIS_DataMapNodeOfDataMapOfIOStatus_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_DataMapNodeOfDataMapOfIOStatus(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapNodeOfDataMapOfIOStatus
AIS_DataMapNodeOfDataMapOfIOStatus.Key = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapOfIOStatus_Key, None, AIS_DataMapNodeOfDataMapOfIOStatus)
AIS_DataMapNodeOfDataMapOfIOStatus.Value = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapOfIOStatus_Value, None, AIS_DataMapNodeOfDataMapOfIOStatus)
AIS_DataMapNodeOfDataMapOfIOStatus_swigregister = _AIS.AIS_DataMapNodeOfDataMapOfIOStatus_swigregister
AIS_DataMapNodeOfDataMapOfIOStatus_swigregister(AIS_DataMapNodeOfDataMapOfIOStatus)

class Handle_AIS_DataMapNodeOfDataMapOfIOStatus(OCC.TCollection.Handle_TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_DataMapNodeOfDataMapOfIOStatus_swiginit(self, _AIS.new_Handle_AIS_DataMapNodeOfDataMapOfIOStatus(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfIOStatus_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_DataMapNodeOfDataMapOfIOStatus
Handle_AIS_DataMapNodeOfDataMapOfIOStatus.Nullify = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfIOStatus_Nullify, None, Handle_AIS_DataMapNodeOfDataMapOfIOStatus)
Handle_AIS_DataMapNodeOfDataMapOfIOStatus.IsNull = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfIOStatus_IsNull, None, Handle_AIS_DataMapNodeOfDataMapOfIOStatus)
Handle_AIS_DataMapNodeOfDataMapOfIOStatus._get_reference = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfIOStatus__get_reference, None, Handle_AIS_DataMapNodeOfDataMapOfIOStatus)
Handle_AIS_DataMapNodeOfDataMapOfIOStatus_swigregister = _AIS.Handle_AIS_DataMapNodeOfDataMapOfIOStatus_swigregister
Handle_AIS_DataMapNodeOfDataMapOfIOStatus_swigregister(Handle_AIS_DataMapNodeOfDataMapOfIOStatus)

def Handle_AIS_DataMapNodeOfDataMapOfIOStatus_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_DataMapNodeOfDataMapOfIOStatus const":
    return _AIS.Handle_AIS_DataMapNodeOfDataMapOfIOStatus_DownCast(AnObject)
Handle_AIS_DataMapNodeOfDataMapOfIOStatus_DownCast = _AIS.Handle_AIS_DataMapNodeOfDataMapOfIOStatus_DownCast

class AIS_DataMapNodeOfDataMapOfSelStat(OCC.TCollection.TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param K:
        :type K: Handle_SelectMgr_SelectableObject &
        :param I:
        :type I: Handle_AIS_LocalStatus &
        :param n:
        :type n: TCollection_MapNodePtr &
        :rtype: None

        """
        _AIS.AIS_DataMapNodeOfDataMapOfSelStat_swiginit(self, _AIS.new_AIS_DataMapNodeOfDataMapOfSelStat(*args))

    def Key(self, *args) -> "Handle_SelectMgr_SelectableObject":
        """
        :rtype: Handle_SelectMgr_SelectableObject

        """
        return _AIS.AIS_DataMapNodeOfDataMapOfSelStat_Key(self, *args)


    def Value(self, *args) -> "Handle_AIS_LocalStatus":
        """
        :rtype: Handle_AIS_LocalStatus

        """
        return _AIS.AIS_DataMapNodeOfDataMapOfSelStat_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_DataMapNodeOfDataMapOfSelStat(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapNodeOfDataMapOfSelStat
AIS_DataMapNodeOfDataMapOfSelStat.Key = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapOfSelStat_Key, None, AIS_DataMapNodeOfDataMapOfSelStat)
AIS_DataMapNodeOfDataMapOfSelStat.Value = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapOfSelStat_Value, None, AIS_DataMapNodeOfDataMapOfSelStat)
AIS_DataMapNodeOfDataMapOfSelStat_swigregister = _AIS.AIS_DataMapNodeOfDataMapOfSelStat_swigregister
AIS_DataMapNodeOfDataMapOfSelStat_swigregister(AIS_DataMapNodeOfDataMapOfSelStat)

class Handle_AIS_DataMapNodeOfDataMapOfSelStat(OCC.TCollection.Handle_TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_DataMapNodeOfDataMapOfSelStat_swiginit(self, _AIS.new_Handle_AIS_DataMapNodeOfDataMapOfSelStat(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfSelStat_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_DataMapNodeOfDataMapOfSelStat
Handle_AIS_DataMapNodeOfDataMapOfSelStat.Nullify = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfSelStat_Nullify, None, Handle_AIS_DataMapNodeOfDataMapOfSelStat)
Handle_AIS_DataMapNodeOfDataMapOfSelStat.IsNull = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfSelStat_IsNull, None, Handle_AIS_DataMapNodeOfDataMapOfSelStat)
Handle_AIS_DataMapNodeOfDataMapOfSelStat._get_reference = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapOfSelStat__get_reference, None, Handle_AIS_DataMapNodeOfDataMapOfSelStat)
Handle_AIS_DataMapNodeOfDataMapOfSelStat_swigregister = _AIS.Handle_AIS_DataMapNodeOfDataMapOfSelStat_swigregister
Handle_AIS_DataMapNodeOfDataMapOfSelStat_swigregister(Handle_AIS_DataMapNodeOfDataMapOfSelStat)

def Handle_AIS_DataMapNodeOfDataMapOfSelStat_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_DataMapNodeOfDataMapOfSelStat const":
    return _AIS.Handle_AIS_DataMapNodeOfDataMapOfSelStat_DownCast(AnObject)
Handle_AIS_DataMapNodeOfDataMapOfSelStat_DownCast = _AIS.Handle_AIS_DataMapNodeOfDataMapOfSelStat_DownCast

class AIS_DataMapNodeOfDataMapofIntegerListOfinteractive(OCC.TCollection.TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param K:
        :type K: int &
        :param I:
        :type I: AIS_ListOfInteractive &
        :param n:
        :type n: TCollection_MapNodePtr &
        :rtype: None

        """
        _AIS.AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_swiginit(self, _AIS.new_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive(*args))

    def GetKey(self) -> "Standard_Integer":
        """GetKey(AIS_DataMapNodeOfDataMapofIntegerListOfinteractive self) -> Standard_Integer"""
        return _AIS.AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_GetKey(self)


    def SetKey(self, value: 'Standard_Integer') -> "void":
        """SetKey(AIS_DataMapNodeOfDataMapofIntegerListOfinteractive self, Standard_Integer value)"""
        return _AIS.AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_SetKey(self, value)


    def Value(self, *args) -> "AIS_ListOfInteractive &":
        """
        :rtype: AIS_ListOfInteractive

        """
        return _AIS.AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive
AIS_DataMapNodeOfDataMapofIntegerListOfinteractive.GetKey = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_GetKey, None, AIS_DataMapNodeOfDataMapofIntegerListOfinteractive)
AIS_DataMapNodeOfDataMapofIntegerListOfinteractive.SetKey = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_SetKey, None, AIS_DataMapNodeOfDataMapofIntegerListOfinteractive)
AIS_DataMapNodeOfDataMapofIntegerListOfinteractive.Value = new_instancemethod(_AIS.AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_Value, None, AIS_DataMapNodeOfDataMapofIntegerListOfinteractive)
AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_swigregister = _AIS.AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_swigregister
AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_swigregister(AIS_DataMapNodeOfDataMapofIntegerListOfinteractive)

class Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive(OCC.TCollection.Handle_TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_swiginit(self, _AIS.new_Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive
Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive.Nullify = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_Nullify, None, Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive)
Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive.IsNull = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_IsNull, None, Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive)
Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive._get_reference = new_instancemethod(_AIS.Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive__get_reference, None, Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive)
Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_swigregister = _AIS.Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_swigregister
Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_swigregister(Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive)

def Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive const":
    return _AIS.Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_DownCast(AnObject)
Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_DownCast = _AIS.Handle_AIS_DataMapNodeOfDataMapofIntegerListOfinteractive_DownCast

class AIS_DataMapOfILC(OCC.TCollection.TCollection_BasicMap):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param NbBuckets: default value is 1
        :type NbBuckets: int
        :rtype: None

        """
        _AIS.AIS_DataMapOfILC_swiginit(self, _AIS.new_AIS_DataMapOfILC(*args))

    def Assign(self, *args) -> "AIS_DataMapOfILC &":
        """
        :param Other:
        :type Other: AIS_DataMapOfILC &
        :rtype: AIS_DataMapOfILC

        """
        return _AIS.AIS_DataMapOfILC_Assign(self, *args)


    def Set(self, *args) -> "AIS_DataMapOfILC &":
        """
        :param Other:
        :type Other: AIS_DataMapOfILC &
        :rtype: AIS_DataMapOfILC

        """
        return _AIS.AIS_DataMapOfILC_Set(self, *args)


    def ReSize(self, *args) -> "void":
        """
        :param NbBuckets:
        :type NbBuckets: int
        :rtype: None

        """
        return _AIS.AIS_DataMapOfILC_ReSize(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_DataMapOfILC_Clear(self, *args)


    def Bind(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: int &
        :param I:
        :type I: Handle_AIS_LocalContext &
        :rtype: bool

        """
        return _AIS.AIS_DataMapOfILC_Bind(self, *args)


    def IsBound(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: int &
        :rtype: bool

        """
        return _AIS.AIS_DataMapOfILC_IsBound(self, *args)


    def UnBind(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: int &
        :rtype: bool

        """
        return _AIS.AIS_DataMapOfILC_UnBind(self, *args)


    def Find(self, *args) -> "Handle_AIS_LocalContext":
        """
        :param K:
        :type K: int &
        :rtype: Handle_AIS_LocalContext

        """
        return _AIS.AIS_DataMapOfILC_Find(self, *args)


    def ChangeFind(self, *args) -> "Handle_AIS_LocalContext":
        """
        :param K:
        :type K: int &
        :rtype: Handle_AIS_LocalContext

        """
        return _AIS.AIS_DataMapOfILC_ChangeFind(self, *args)


    def Find1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: int &
        :rtype: Standard_Address

        """
        return _AIS.AIS_DataMapOfILC_Find1(self, *args)


    def ChangeFind1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: int &
        :rtype: Standard_Address

        """
        return _AIS.AIS_DataMapOfILC_ChangeFind1(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapOfILC
AIS_DataMapOfILC.Assign = new_instancemethod(_AIS.AIS_DataMapOfILC_Assign, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.Set = new_instancemethod(_AIS.AIS_DataMapOfILC_Set, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.ReSize = new_instancemethod(_AIS.AIS_DataMapOfILC_ReSize, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.Clear = new_instancemethod(_AIS.AIS_DataMapOfILC_Clear, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.Bind = new_instancemethod(_AIS.AIS_DataMapOfILC_Bind, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.IsBound = new_instancemethod(_AIS.AIS_DataMapOfILC_IsBound, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.UnBind = new_instancemethod(_AIS.AIS_DataMapOfILC_UnBind, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.Find = new_instancemethod(_AIS.AIS_DataMapOfILC_Find, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.ChangeFind = new_instancemethod(_AIS.AIS_DataMapOfILC_ChangeFind, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.Find1 = new_instancemethod(_AIS.AIS_DataMapOfILC_Find1, None, AIS_DataMapOfILC)
AIS_DataMapOfILC.ChangeFind1 = new_instancemethod(_AIS.AIS_DataMapOfILC_ChangeFind1, None, AIS_DataMapOfILC)
AIS_DataMapOfILC_swigregister = _AIS.AIS_DataMapOfILC_swigregister
AIS_DataMapOfILC_swigregister(AIS_DataMapOfILC)

class AIS_DataMapOfIOStatus(OCC.TCollection.TCollection_BasicMap):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param NbBuckets: default value is 1
        :type NbBuckets: int
        :rtype: None

        """
        _AIS.AIS_DataMapOfIOStatus_swiginit(self, _AIS.new_AIS_DataMapOfIOStatus(*args))

    def Assign(self, *args) -> "AIS_DataMapOfIOStatus &":
        """
        :param Other:
        :type Other: AIS_DataMapOfIOStatus &
        :rtype: AIS_DataMapOfIOStatus

        """
        return _AIS.AIS_DataMapOfIOStatus_Assign(self, *args)


    def Set(self, *args) -> "AIS_DataMapOfIOStatus &":
        """
        :param Other:
        :type Other: AIS_DataMapOfIOStatus &
        :rtype: AIS_DataMapOfIOStatus

        """
        return _AIS.AIS_DataMapOfIOStatus_Set(self, *args)


    def ReSize(self, *args) -> "void":
        """
        :param NbBuckets:
        :type NbBuckets: int
        :rtype: None

        """
        return _AIS.AIS_DataMapOfIOStatus_ReSize(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_DataMapOfIOStatus_Clear(self, *args)


    def Bind(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: Handle_AIS_InteractiveObject &
        :param I:
        :type I: Handle_AIS_GlobalStatus &
        :rtype: bool

        """
        return _AIS.AIS_DataMapOfIOStatus_Bind(self, *args)


    def IsBound(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_DataMapOfIOStatus_IsBound(self, *args)


    def UnBind(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_DataMapOfIOStatus_UnBind(self, *args)


    def Find(self, *args) -> "Handle_AIS_GlobalStatus":
        """
        :param K:
        :type K: Handle_AIS_InteractiveObject &
        :rtype: Handle_AIS_GlobalStatus

        """
        return _AIS.AIS_DataMapOfIOStatus_Find(self, *args)


    def ChangeFind(self, *args) -> "Handle_AIS_GlobalStatus":
        """
        :param K:
        :type K: Handle_AIS_InteractiveObject &
        :rtype: Handle_AIS_GlobalStatus

        """
        return _AIS.AIS_DataMapOfIOStatus_ChangeFind(self, *args)


    def Find1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: Handle_AIS_InteractiveObject &
        :rtype: Standard_Address

        """
        return _AIS.AIS_DataMapOfIOStatus_Find1(self, *args)


    def ChangeFind1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: Handle_AIS_InteractiveObject &
        :rtype: Standard_Address

        """
        return _AIS.AIS_DataMapOfIOStatus_ChangeFind1(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapOfIOStatus
AIS_DataMapOfIOStatus.Assign = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_Assign, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.Set = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_Set, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.ReSize = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_ReSize, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.Clear = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_Clear, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.Bind = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_Bind, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.IsBound = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_IsBound, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.UnBind = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_UnBind, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.Find = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_Find, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.ChangeFind = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_ChangeFind, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.Find1 = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_Find1, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus.ChangeFind1 = new_instancemethod(_AIS.AIS_DataMapOfIOStatus_ChangeFind1, None, AIS_DataMapOfIOStatus)
AIS_DataMapOfIOStatus_swigregister = _AIS.AIS_DataMapOfIOStatus_swigregister
AIS_DataMapOfIOStatus_swigregister(AIS_DataMapOfIOStatus)

class AIS_DataMapOfSelStat(OCC.TCollection.TCollection_BasicMap):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param NbBuckets: default value is 1
        :type NbBuckets: int
        :rtype: None

        """
        _AIS.AIS_DataMapOfSelStat_swiginit(self, _AIS.new_AIS_DataMapOfSelStat(*args))

    def Assign(self, *args) -> "AIS_DataMapOfSelStat &":
        """
        :param Other:
        :type Other: AIS_DataMapOfSelStat &
        :rtype: AIS_DataMapOfSelStat

        """
        return _AIS.AIS_DataMapOfSelStat_Assign(self, *args)


    def Set(self, *args) -> "AIS_DataMapOfSelStat &":
        """
        :param Other:
        :type Other: AIS_DataMapOfSelStat &
        :rtype: AIS_DataMapOfSelStat

        """
        return _AIS.AIS_DataMapOfSelStat_Set(self, *args)


    def ReSize(self, *args) -> "void":
        """
        :param NbBuckets:
        :type NbBuckets: int
        :rtype: None

        """
        return _AIS.AIS_DataMapOfSelStat_ReSize(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_DataMapOfSelStat_Clear(self, *args)


    def Bind(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: Handle_SelectMgr_SelectableObject &
        :param I:
        :type I: Handle_AIS_LocalStatus &
        :rtype: bool

        """
        return _AIS.AIS_DataMapOfSelStat_Bind(self, *args)


    def IsBound(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: Handle_SelectMgr_SelectableObject &
        :rtype: bool

        """
        return _AIS.AIS_DataMapOfSelStat_IsBound(self, *args)


    def UnBind(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: Handle_SelectMgr_SelectableObject &
        :rtype: bool

        """
        return _AIS.AIS_DataMapOfSelStat_UnBind(self, *args)


    def Find(self, *args) -> "Handle_AIS_LocalStatus":
        """
        :param K:
        :type K: Handle_SelectMgr_SelectableObject &
        :rtype: Handle_AIS_LocalStatus

        """
        return _AIS.AIS_DataMapOfSelStat_Find(self, *args)


    def ChangeFind(self, *args) -> "Handle_AIS_LocalStatus":
        """
        :param K:
        :type K: Handle_SelectMgr_SelectableObject &
        :rtype: Handle_AIS_LocalStatus

        """
        return _AIS.AIS_DataMapOfSelStat_ChangeFind(self, *args)


    def Find1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: Handle_SelectMgr_SelectableObject &
        :rtype: Standard_Address

        """
        return _AIS.AIS_DataMapOfSelStat_Find1(self, *args)


    def ChangeFind1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: Handle_SelectMgr_SelectableObject &
        :rtype: Standard_Address

        """
        return _AIS.AIS_DataMapOfSelStat_ChangeFind1(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapOfSelStat
AIS_DataMapOfSelStat.Assign = new_instancemethod(_AIS.AIS_DataMapOfSelStat_Assign, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.Set = new_instancemethod(_AIS.AIS_DataMapOfSelStat_Set, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.ReSize = new_instancemethod(_AIS.AIS_DataMapOfSelStat_ReSize, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.Clear = new_instancemethod(_AIS.AIS_DataMapOfSelStat_Clear, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.Bind = new_instancemethod(_AIS.AIS_DataMapOfSelStat_Bind, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.IsBound = new_instancemethod(_AIS.AIS_DataMapOfSelStat_IsBound, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.UnBind = new_instancemethod(_AIS.AIS_DataMapOfSelStat_UnBind, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.Find = new_instancemethod(_AIS.AIS_DataMapOfSelStat_Find, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.ChangeFind = new_instancemethod(_AIS.AIS_DataMapOfSelStat_ChangeFind, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.Find1 = new_instancemethod(_AIS.AIS_DataMapOfSelStat_Find1, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat.ChangeFind1 = new_instancemethod(_AIS.AIS_DataMapOfSelStat_ChangeFind1, None, AIS_DataMapOfSelStat)
AIS_DataMapOfSelStat_swigregister = _AIS.AIS_DataMapOfSelStat_swigregister
AIS_DataMapOfSelStat_swigregister(AIS_DataMapOfSelStat)

class AIS_DataMapofIntegerListOfinteractive(OCC.TCollection.TCollection_BasicMap):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param NbBuckets: default value is 1
        :type NbBuckets: int
        :rtype: None

        """
        _AIS.AIS_DataMapofIntegerListOfinteractive_swiginit(self, _AIS.new_AIS_DataMapofIntegerListOfinteractive(*args))

    def Assign(self, *args) -> "AIS_DataMapofIntegerListOfinteractive &":
        """
        :param Other:
        :type Other: AIS_DataMapofIntegerListOfinteractive &
        :rtype: AIS_DataMapofIntegerListOfinteractive

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_Assign(self, *args)


    def Set(self, *args) -> "AIS_DataMapofIntegerListOfinteractive &":
        """
        :param Other:
        :type Other: AIS_DataMapofIntegerListOfinteractive &
        :rtype: AIS_DataMapofIntegerListOfinteractive

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_Set(self, *args)


    def ReSize(self, *args) -> "void":
        """
        :param NbBuckets:
        :type NbBuckets: int
        :rtype: None

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_ReSize(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_Clear(self, *args)


    def Bind(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: int &
        :param I:
        :type I: AIS_ListOfInteractive &
        :rtype: bool

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_Bind(self, *args)


    def IsBound(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: int &
        :rtype: bool

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_IsBound(self, *args)


    def UnBind(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: int &
        :rtype: bool

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_UnBind(self, *args)


    def Find(self, *args) -> "AIS_ListOfInteractive const &":
        """
        :param K:
        :type K: int &
        :rtype: AIS_ListOfInteractive

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_Find(self, *args)


    def ChangeFind(self, *args) -> "AIS_ListOfInteractive &":
        """
        :param K:
        :type K: int &
        :rtype: AIS_ListOfInteractive

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_ChangeFind(self, *args)


    def Find1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: int &
        :rtype: Standard_Address

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_Find1(self, *args)


    def ChangeFind1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: int &
        :rtype: Standard_Address

        """
        return _AIS.AIS_DataMapofIntegerListOfinteractive_ChangeFind1(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DataMapofIntegerListOfinteractive
AIS_DataMapofIntegerListOfinteractive.Assign = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_Assign, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.Set = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_Set, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.ReSize = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_ReSize, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.Clear = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_Clear, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.Bind = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_Bind, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.IsBound = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_IsBound, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.UnBind = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_UnBind, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.Find = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_Find, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.ChangeFind = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_ChangeFind, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.Find1 = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_Find1, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive.ChangeFind1 = new_instancemethod(_AIS.AIS_DataMapofIntegerListOfinteractive_ChangeFind1, None, AIS_DataMapofIntegerListOfinteractive)
AIS_DataMapofIntegerListOfinteractive_swigregister = _AIS.AIS_DataMapofIntegerListOfinteractive_swigregister
AIS_DataMapofIntegerListOfinteractive_swigregister(AIS_DataMapofIntegerListOfinteractive)

class AIS_DimensionOwner(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the dimension owner, theSO, and attributes it the priority, thePriority.

        :param theSelObject:
        :type theSelObject: Handle_SelectMgr_SelectableObject &
        :param theSelMode:
        :type theSelMode: AIS_DimensionSelectionMode
        :param thePriority: default value is 0
        :type thePriority: int
        :rtype: None

        """
        _AIS.AIS_DimensionOwner_swiginit(self, _AIS.new_AIS_DimensionOwner(*args))

    def SelectionMode(self, *args) -> "AIS_DimensionSelectionMode":
        """
        :rtype: AIS_DimensionSelectionMode

        """
        return _AIS.AIS_DimensionOwner_SelectionMode(self, *args)


    def HilightWithColor(self, *args) -> "void":
        """
        :param thePM:
        :type thePM: Handle_PrsMgr_PresentationManager3d &
        :param theColor:
        :type theColor: Quantity_NameOfColor
        :param theMode: default value is 0
        :type theMode: int
        :rtype: void

        """
        return _AIS.AIS_DimensionOwner_HilightWithColor(self, *args)


    def IsHilighted(self, *args) -> "Standard_Boolean":
        """
        * Returns true if an object with the selection mode aMode is highlighted in the presentation manager aPM.

        :param thePM:
        :type thePM: Handle_PrsMgr_PresentationManager &
        :param theMode: default value is 0
        :type theMode: int
        :rtype: bool

        """
        return _AIS.AIS_DimensionOwner_IsHilighted(self, *args)


    def Hilight(self, *args) -> "void":
        """
        :param thePM:
        :type thePM: Handle_PrsMgr_PresentationManager &
        :param theMode: default value is 0
        :type theMode: int
        :rtype: void

        """
        return _AIS.AIS_DimensionOwner_Hilight(self, *args)


    def Unhilight(self, *args) -> "void":
        """
        * Removes highlighting from the selected part of dimension.

        :param thePM:
        :type thePM: Handle_PrsMgr_PresentationManager &
        :param theMode: default value is 0
        :type theMode: int
        :rtype: void

        """
        return _AIS.AIS_DimensionOwner_Unhilight(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_DimensionOwner(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DimensionOwner
AIS_DimensionOwner.SelectionMode = new_instancemethod(_AIS.AIS_DimensionOwner_SelectionMode, None, AIS_DimensionOwner)
AIS_DimensionOwner.HilightWithColor = new_instancemethod(_AIS.AIS_DimensionOwner_HilightWithColor, None, AIS_DimensionOwner)
AIS_DimensionOwner.IsHilighted = new_instancemethod(_AIS.AIS_DimensionOwner_IsHilighted, None, AIS_DimensionOwner)
AIS_DimensionOwner.Hilight = new_instancemethod(_AIS.AIS_DimensionOwner_Hilight, None, AIS_DimensionOwner)
AIS_DimensionOwner.Unhilight = new_instancemethod(_AIS.AIS_DimensionOwner_Unhilight, None, AIS_DimensionOwner)
AIS_DimensionOwner_swigregister = _AIS.AIS_DimensionOwner_swigregister
AIS_DimensionOwner_swigregister(AIS_DimensionOwner)

class Handle_AIS_DimensionOwner(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_DimensionOwner_swiginit(self, _AIS.new_Handle_AIS_DimensionOwner(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_DimensionOwner_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_DimensionOwner
Handle_AIS_DimensionOwner.Nullify = new_instancemethod(_AIS.Handle_AIS_DimensionOwner_Nullify, None, Handle_AIS_DimensionOwner)
Handle_AIS_DimensionOwner.IsNull = new_instancemethod(_AIS.Handle_AIS_DimensionOwner_IsNull, None, Handle_AIS_DimensionOwner)
Handle_AIS_DimensionOwner._get_reference = new_instancemethod(_AIS.Handle_AIS_DimensionOwner__get_reference, None, Handle_AIS_DimensionOwner)
Handle_AIS_DimensionOwner_swigregister = _AIS.Handle_AIS_DimensionOwner_swigregister
Handle_AIS_DimensionOwner_swigregister(Handle_AIS_DimensionOwner)

def Handle_AIS_DimensionOwner_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_DimensionOwner const":
    return _AIS.Handle_AIS_DimensionOwner_DownCast(AnObject)
Handle_AIS_DimensionOwner_DownCast = _AIS.Handle_AIS_DimensionOwner_DownCast

class AIS_Drawer(OCC.Prs3d.Prs3d_Drawer):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an empty attribute management framework.

        :rtype: None

        """
        _AIS.AIS_Drawer_swiginit(self, _AIS.new_AIS_Drawer(*args))

    def SetDeviationCoefficient(self, *args) -> "void":
        """
        * Sets the hasOwnDeviationCoefficient flag to Standard_False

        :rtype: None

        * Sets the hasOwnDeviationCoefficient flag to Standard_True, sets myOwnDeviationCoefficient and myPreviousDeviationCoefficient

        :param aCoefficient:
        :type aCoefficient: float
        :rtype: None

        """
        return _AIS.AIS_Drawer_SetDeviationCoefficient(self, *args)


    def SetHLRDeviationCoefficient(self, *args) -> "void":
        """
        * Sets the deviation coefficient aCoefficient for removal of hidden lines created by different viewpoints in different presentations. The Default value is 0.02.

        :rtype: None

        * Sets the hasOwnHLRDeviationCoefficient flag to Standard_True, sets myOwnHLRDeviationCoefficient and myPreviousHLRDeviationCoefficient

        :param aCoefficient:
        :type aCoefficient: float
        :rtype: None

        """
        return _AIS.AIS_Drawer_SetHLRDeviationCoefficient(self, *args)


    def SetDeviationAngle(self, *args) -> "void":
        """
        * Sets the hasOwnDeviationAngle flag to Standard_False

        :rtype: None

        * Sets the hasOwnDeviationAngle flag to Standard_True, sets myOwnDeviationAngle and myPreviousDeviationAngle

        :param anAngle:
        :type anAngle: float
        :rtype: void

        """
        return _AIS.AIS_Drawer_SetDeviationAngle(self, *args)


    def SetHLRAngle(self, *args) -> "void":
        """
        * Sets the angle of maximum chordal deviation for removal of hidden lines created by different viewpoints in different presentations. The default value is 20*PI/180.

        :rtype: None

        * Sets the hasOwnHLRDeviationAngle flag to Standard_True, sets myOwnHLRDeviationAngle and myPreviousHLRDeviationAngle

        :param anAngle:
        :type anAngle: float
        :rtype: None

        """
        return _AIS.AIS_Drawer_SetHLRAngle(self, *args)


    def PreviousDeviationCoefficient(self, *args) -> "Standard_Real":
        """
        * Saves the previous value used for the chordal deviation coefficient. The default value is 0.1.

        :rtype: float

        """
        return _AIS.AIS_Drawer_PreviousDeviationCoefficient(self, *args)


    def PreviousHLRDeviationCoefficient(self, *args) -> "Standard_Real":
        """
        * returns myPreviousHLRDeviationCoefficient

        :rtype: float

        """
        return _AIS.AIS_Drawer_PreviousHLRDeviationCoefficient(self, *args)


    def PreviousDeviationAngle(self, *args) -> "Standard_Real":
        """
        * returns myPreviousDeviationAngle

        :rtype: float

        """
        return _AIS.AIS_Drawer_PreviousDeviationAngle(self, *args)


    def PreviousHLRDeviationAngle(self, *args) -> "Standard_Real":
        """
        * returns myPreviousHLRDeviationAngle

        :rtype: float

        """
        return _AIS.AIS_Drawer_PreviousHLRDeviationAngle(self, *args)


    def IsOwnDeviationCoefficient(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the there is a local setting for deviation coefficient in this framework for a specific interactive object.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_IsOwnDeviationCoefficient(self, *args)


    def IsOwnHLRDeviationCoefficient(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the there is a setting for HLR deviation coefficient in this framework for a specific interactive object.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_IsOwnHLRDeviationCoefficient(self, *args)


    def IsOwnDeviationAngle(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the there is a local setting for deviation angle in this framework for a specific interactive object.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_IsOwnDeviationAngle(self, *args)


    def IsOwnHLRDeviationAngle(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the there is a setting for HLR deviation angle in this framework for a specific interactive object.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_IsOwnHLRDeviationAngle(self, *args)


    def HasUIsoAspect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Drawer has a UIso aspect setting active.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasUIsoAspect(self, *args)


    def HasVIsoAspect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Drawer has a VIso aspect setting active.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasVIsoAspect(self, *args)


    def HasFreeBoundaryAspect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Drawer has a free boundary aspect setting active.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasFreeBoundaryAspect(self, *args)


    def HasLineAspect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Interactive Object has a line visualization aspect.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasLineAspect(self, *args)


    def HasWireAspect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Drawer has a wire aspect setting active.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasWireAspect(self, *args)


    def HasUnFreeBoundaryAspect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Drawer has an unfree boundary aspect setting active.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasUnFreeBoundaryAspect(self, *args)


    def HasTextAspect(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasTextAspect(self, *args)


    def HasPointAspect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Drawer has a point aspect setting active.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasPointAspect(self, *args)


    def IsOwnVertexDrawMode(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the vertex draw mode is not equal to <b>Prs3d_VDM_Inherited</b>. This means that individual vertex draw mode value (i.e. not inherited from the global drawer) is used for a specific interactive object.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_IsOwnVertexDrawMode(self, *args)


    def HasShadingAspect(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the Drawer has shading aspect active.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasShadingAspect(self, *args)


    def HasPlaneAspect(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasPlaneAspect(self, *args)


    def IsOwnFaceBoundaryDraw(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the drawer has its own attribute for 'draw face boundaries' flag that overrides the one in the link.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_IsOwnFaceBoundaryDraw(self, *args)


    def IsOwnFaceBoundaryAspect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the drawer has its own attribute for face boundaries aspect that overrides the one in the link.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_IsOwnFaceBoundaryAspect(self, *args)


    def HasDatumAspect(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasDatumAspect(self, *args)


    def HasDimensionAspect(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasDimensionAspect(self, *args)


    def HasLink(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasLink(self, *args)


    def Link(self, *args) -> "void":
        """
        :rtype: Handle_Prs3d_Drawer

        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: None

        """
        return _AIS.AIS_Drawer_Link(self, *args)


    def ClearLocalAttributes(self, *args) -> "void":
        """
        * Removes attributes stored in a Local Context.

        :rtype: void

        """
        return _AIS.AIS_Drawer_ClearLocalAttributes(self, *args)


    def WasLastLocal(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the last called attribute was local; false if it was global.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_WasLastLocal(self, *args)


    def HasLocalAttributes(self, *args) -> "Standard_Boolean":
        """
        * Returns true if a Local Context has stored attributes for Interactive Objects.

        :rtype: bool

        """
        return _AIS.AIS_Drawer_HasLocalAttributes(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Drawer(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Drawer
AIS_Drawer.SetDeviationCoefficient = new_instancemethod(_AIS.AIS_Drawer_SetDeviationCoefficient, None, AIS_Drawer)
AIS_Drawer.SetHLRDeviationCoefficient = new_instancemethod(_AIS.AIS_Drawer_SetHLRDeviationCoefficient, None, AIS_Drawer)
AIS_Drawer.SetDeviationAngle = new_instancemethod(_AIS.AIS_Drawer_SetDeviationAngle, None, AIS_Drawer)
AIS_Drawer.SetHLRAngle = new_instancemethod(_AIS.AIS_Drawer_SetHLRAngle, None, AIS_Drawer)
AIS_Drawer.PreviousDeviationCoefficient = new_instancemethod(_AIS.AIS_Drawer_PreviousDeviationCoefficient, None, AIS_Drawer)
AIS_Drawer.PreviousHLRDeviationCoefficient = new_instancemethod(_AIS.AIS_Drawer_PreviousHLRDeviationCoefficient, None, AIS_Drawer)
AIS_Drawer.PreviousDeviationAngle = new_instancemethod(_AIS.AIS_Drawer_PreviousDeviationAngle, None, AIS_Drawer)
AIS_Drawer.PreviousHLRDeviationAngle = new_instancemethod(_AIS.AIS_Drawer_PreviousHLRDeviationAngle, None, AIS_Drawer)
AIS_Drawer.IsOwnDeviationCoefficient = new_instancemethod(_AIS.AIS_Drawer_IsOwnDeviationCoefficient, None, AIS_Drawer)
AIS_Drawer.IsOwnHLRDeviationCoefficient = new_instancemethod(_AIS.AIS_Drawer_IsOwnHLRDeviationCoefficient, None, AIS_Drawer)
AIS_Drawer.IsOwnDeviationAngle = new_instancemethod(_AIS.AIS_Drawer_IsOwnDeviationAngle, None, AIS_Drawer)
AIS_Drawer.IsOwnHLRDeviationAngle = new_instancemethod(_AIS.AIS_Drawer_IsOwnHLRDeviationAngle, None, AIS_Drawer)
AIS_Drawer.HasUIsoAspect = new_instancemethod(_AIS.AIS_Drawer_HasUIsoAspect, None, AIS_Drawer)
AIS_Drawer.HasVIsoAspect = new_instancemethod(_AIS.AIS_Drawer_HasVIsoAspect, None, AIS_Drawer)
AIS_Drawer.HasFreeBoundaryAspect = new_instancemethod(_AIS.AIS_Drawer_HasFreeBoundaryAspect, None, AIS_Drawer)
AIS_Drawer.HasLineAspect = new_instancemethod(_AIS.AIS_Drawer_HasLineAspect, None, AIS_Drawer)
AIS_Drawer.HasWireAspect = new_instancemethod(_AIS.AIS_Drawer_HasWireAspect, None, AIS_Drawer)
AIS_Drawer.HasUnFreeBoundaryAspect = new_instancemethod(_AIS.AIS_Drawer_HasUnFreeBoundaryAspect, None, AIS_Drawer)
AIS_Drawer.HasTextAspect = new_instancemethod(_AIS.AIS_Drawer_HasTextAspect, None, AIS_Drawer)
AIS_Drawer.HasPointAspect = new_instancemethod(_AIS.AIS_Drawer_HasPointAspect, None, AIS_Drawer)
AIS_Drawer.IsOwnVertexDrawMode = new_instancemethod(_AIS.AIS_Drawer_IsOwnVertexDrawMode, None, AIS_Drawer)
AIS_Drawer.HasShadingAspect = new_instancemethod(_AIS.AIS_Drawer_HasShadingAspect, None, AIS_Drawer)
AIS_Drawer.HasPlaneAspect = new_instancemethod(_AIS.AIS_Drawer_HasPlaneAspect, None, AIS_Drawer)
AIS_Drawer.IsOwnFaceBoundaryDraw = new_instancemethod(_AIS.AIS_Drawer_IsOwnFaceBoundaryDraw, None, AIS_Drawer)
AIS_Drawer.IsOwnFaceBoundaryAspect = new_instancemethod(_AIS.AIS_Drawer_IsOwnFaceBoundaryAspect, None, AIS_Drawer)
AIS_Drawer.HasDatumAspect = new_instancemethod(_AIS.AIS_Drawer_HasDatumAspect, None, AIS_Drawer)
AIS_Drawer.HasDimensionAspect = new_instancemethod(_AIS.AIS_Drawer_HasDimensionAspect, None, AIS_Drawer)
AIS_Drawer.HasLink = new_instancemethod(_AIS.AIS_Drawer_HasLink, None, AIS_Drawer)
AIS_Drawer.Link = new_instancemethod(_AIS.AIS_Drawer_Link, None, AIS_Drawer)
AIS_Drawer.ClearLocalAttributes = new_instancemethod(_AIS.AIS_Drawer_ClearLocalAttributes, None, AIS_Drawer)
AIS_Drawer.WasLastLocal = new_instancemethod(_AIS.AIS_Drawer_WasLastLocal, None, AIS_Drawer)
AIS_Drawer.HasLocalAttributes = new_instancemethod(_AIS.AIS_Drawer_HasLocalAttributes, None, AIS_Drawer)
AIS_Drawer_swigregister = _AIS.AIS_Drawer_swigregister
AIS_Drawer_swigregister(AIS_Drawer)

class Handle_AIS_Drawer(OCC.Prs3d.Handle_Prs3d_Drawer):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Drawer_swiginit(self, _AIS.new_Handle_AIS_Drawer(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Drawer_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Drawer
Handle_AIS_Drawer.Nullify = new_instancemethod(_AIS.Handle_AIS_Drawer_Nullify, None, Handle_AIS_Drawer)
Handle_AIS_Drawer.IsNull = new_instancemethod(_AIS.Handle_AIS_Drawer_IsNull, None, Handle_AIS_Drawer)
Handle_AIS_Drawer._get_reference = new_instancemethod(_AIS.Handle_AIS_Drawer__get_reference, None, Handle_AIS_Drawer)
Handle_AIS_Drawer_swigregister = _AIS.Handle_AIS_Drawer_swigregister
Handle_AIS_Drawer_swigregister(Handle_AIS_Drawer)

def Handle_AIS_Drawer_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Drawer const":
    return _AIS.Handle_AIS_Drawer_DownCast(AnObject)
Handle_AIS_Drawer_DownCast = _AIS.Handle_AIS_Drawer_DownCast

class AIS_ExclusionFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an empty exclusion filter object defined by the flag setting ExclusionFlagOn. By default, the flag is set to true.

        :param ExclusionFlagOn: default value is Standard_True
        :type ExclusionFlagOn: bool
        :rtype: None

        * All the AIS objects of <TypeToExclude> Will be rejected by the IsOk Method.

        :param TypeToExclude:
        :type TypeToExclude: AIS_KindOfInteractive
        :param ExclusionFlagOn: default value is Standard_True
        :type ExclusionFlagOn: bool
        :rtype: None

        * Constructs an exclusion filter object defined by the enumeration value TypeToExclude, the signature SignatureInType, and the flag setting ExclusionFlagOn. By default, the flag is set to true.

        :param TypeToExclude:
        :type TypeToExclude: AIS_KindOfInteractive
        :param SignatureInType:
        :type SignatureInType: int
        :param ExclusionFlagOn: default value is Standard_True
        :type ExclusionFlagOn: bool
        :rtype: None

        """
        _AIS.AIS_ExclusionFilter_swiginit(self, _AIS.new_AIS_ExclusionFilter(*args))

    def IsOk(self, *args) -> "Standard_Boolean":
        """
        :param anObj:
        :type anObj: Handle_SelectMgr_EntityOwner &
        :rtype: bool

        """
        return _AIS.AIS_ExclusionFilter_IsOk(self, *args)


    def Add(self, *args) -> "Standard_Boolean":
        """
        * Adds the type TypeToExclude to the list of types.

        :param TypeToExclude:
        :type TypeToExclude: AIS_KindOfInteractive
        :rtype: bool

        :param TypeToExclude:
        :type TypeToExclude: AIS_KindOfInteractive
        :param SignatureInType:
        :type SignatureInType: int
        :rtype: bool

        """
        return _AIS.AIS_ExclusionFilter_Add(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        :param TypeToExclude:
        :type TypeToExclude: AIS_KindOfInteractive
        :rtype: bool

        :param TypeToExclude:
        :type TypeToExclude: AIS_KindOfInteractive
        :param SignatureInType:
        :type SignatureInType: int
        :rtype: bool

        """
        return _AIS.AIS_ExclusionFilter_Remove(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_ExclusionFilter_Clear(self, *args)


    def IsExclusionFlagOn(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_ExclusionFilter_IsExclusionFlagOn(self, *args)


    def SetExclusionFlag(self, *args) -> "void":
        """
        :param Status:
        :type Status: bool
        :rtype: None

        """
        return _AIS.AIS_ExclusionFilter_SetExclusionFlag(self, *args)


    def IsStored(self, *args) -> "Standard_Boolean":
        """
        :param aType:
        :type aType: AIS_KindOfInteractive
        :rtype: bool

        """
        return _AIS.AIS_ExclusionFilter_IsStored(self, *args)


    def ListOfStoredTypes(self, *args) -> "void":
        """
        :param TheList:
        :type TheList: TColStd_ListOfInteger &
        :rtype: None

        """
        return _AIS.AIS_ExclusionFilter_ListOfStoredTypes(self, *args)


    def ListOfSignature(self, *args) -> "void":
        """
        :param aType:
        :type aType: AIS_KindOfInteractive
        :param TheStoredList:
        :type TheStoredList: TColStd_ListOfInteger &
        :rtype: None

        """
        return _AIS.AIS_ExclusionFilter_ListOfSignature(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_ExclusionFilter(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_ExclusionFilter
AIS_ExclusionFilter.IsOk = new_instancemethod(_AIS.AIS_ExclusionFilter_IsOk, None, AIS_ExclusionFilter)
AIS_ExclusionFilter.Add = new_instancemethod(_AIS.AIS_ExclusionFilter_Add, None, AIS_ExclusionFilter)
AIS_ExclusionFilter.Remove = new_instancemethod(_AIS.AIS_ExclusionFilter_Remove, None, AIS_ExclusionFilter)
AIS_ExclusionFilter.Clear = new_instancemethod(_AIS.AIS_ExclusionFilter_Clear, None, AIS_ExclusionFilter)
AIS_ExclusionFilter.IsExclusionFlagOn = new_instancemethod(_AIS.AIS_ExclusionFilter_IsExclusionFlagOn, None, AIS_ExclusionFilter)
AIS_ExclusionFilter.SetExclusionFlag = new_instancemethod(_AIS.AIS_ExclusionFilter_SetExclusionFlag, None, AIS_ExclusionFilter)
AIS_ExclusionFilter.IsStored = new_instancemethod(_AIS.AIS_ExclusionFilter_IsStored, None, AIS_ExclusionFilter)
AIS_ExclusionFilter.ListOfStoredTypes = new_instancemethod(_AIS.AIS_ExclusionFilter_ListOfStoredTypes, None, AIS_ExclusionFilter)
AIS_ExclusionFilter.ListOfSignature = new_instancemethod(_AIS.AIS_ExclusionFilter_ListOfSignature, None, AIS_ExclusionFilter)
AIS_ExclusionFilter_swigregister = _AIS.AIS_ExclusionFilter_swigregister
AIS_ExclusionFilter_swigregister(AIS_ExclusionFilter)

class Handle_AIS_ExclusionFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_ExclusionFilter_swiginit(self, _AIS.new_Handle_AIS_ExclusionFilter(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_ExclusionFilter_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_ExclusionFilter
Handle_AIS_ExclusionFilter.Nullify = new_instancemethod(_AIS.Handle_AIS_ExclusionFilter_Nullify, None, Handle_AIS_ExclusionFilter)
Handle_AIS_ExclusionFilter.IsNull = new_instancemethod(_AIS.Handle_AIS_ExclusionFilter_IsNull, None, Handle_AIS_ExclusionFilter)
Handle_AIS_ExclusionFilter._get_reference = new_instancemethod(_AIS.Handle_AIS_ExclusionFilter__get_reference, None, Handle_AIS_ExclusionFilter)
Handle_AIS_ExclusionFilter_swigregister = _AIS.Handle_AIS_ExclusionFilter_swigregister
Handle_AIS_ExclusionFilter_swigregister(Handle_AIS_ExclusionFilter)

def Handle_AIS_ExclusionFilter_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_ExclusionFilter const":
    return _AIS.Handle_AIS_ExclusionFilter_DownCast(AnObject)
Handle_AIS_ExclusionFilter_DownCast = _AIS.Handle_AIS_ExclusionFilter_DownCast

class AIS_GlobalStatus(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param aStat:
        :type aStat: AIS_DisplayStatus
        :param aDispMode:
        :type aDispMode: int
        :param aSelMode:
        :type aSelMode: int
        :param ishilighted: default value is Standard_False
        :type ishilighted: bool
        :param TheHiCol: default value is Quantity_NOC_WHITE
        :type TheHiCol: Quantity_NameOfColor
        :param aLayerIndex: default value is 0
        :type aLayerIndex: int
        :rtype: None

        """
        _AIS.AIS_GlobalStatus_swiginit(self, _AIS.new_AIS_GlobalStatus(*args))

    def SetGraphicStatus(self, *args) -> "void":
        """
        :param aStat:
        :type aStat: AIS_DisplayStatus
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_SetGraphicStatus(self, *args)


    def AddDisplayMode(self, *args) -> "void":
        """
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_AddDisplayMode(self, *args)


    def AddSelectionMode(self, *args) -> "void":
        """
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_AddSelectionMode(self, *args)


    def SetLayerIndex(self, *args) -> "void":
        """
        :param AnIndex:
        :type AnIndex: int
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_SetLayerIndex(self, *args)


    def SetHilightStatus(self, *args) -> "void":
        """
        :param aStat:
        :type aStat: bool
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_SetHilightStatus(self, *args)


    def SetHilightColor(self, *args) -> "void":
        """
        :param aHiCol:
        :type aHiCol: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_SetHilightColor(self, *args)


    def IsSubIntensityOn(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_GlobalStatus_IsSubIntensityOn(self, *args)


    def SubIntensityOn(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_SubIntensityOff(self, *args)


    def RemoveDisplayMode(self, *args) -> "void":
        """
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_RemoveDisplayMode(self, *args)


    def RemoveSelectionMode(self, *args) -> "void":
        """
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_RemoveSelectionMode(self, *args)


    def ClearSelectionModes(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_GlobalStatus_ClearSelectionModes(self, *args)


    def GraphicStatus(self, *args) -> "AIS_DisplayStatus":
        """
        :rtype: AIS_DisplayStatus

        """
        return _AIS.AIS_GlobalStatus_GraphicStatus(self, *args)


    def DisplayedModes(self, *args) -> "TColStd_ListOfInteger const &":
        """
        * keeps the information of displayed modes in the main viewer.

        :rtype: TColStd_ListOfInteger

        """
        return _AIS.AIS_GlobalStatus_DisplayedModes(self, *args)


    def SelectionModes(self, *args) -> "TColStd_ListOfInteger const &":
        """
        * keeps the active selection modes of the object in the main viewer.

        :rtype: TColStd_ListOfInteger

        """
        return _AIS.AIS_GlobalStatus_SelectionModes(self, *args)


    def IsHilighted(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_GlobalStatus_IsHilighted(self, *args)


    def HilightColor(self, *args) -> "Quantity_NameOfColor":
        """
        :rtype: Quantity_NameOfColor

        """
        return _AIS.AIS_GlobalStatus_HilightColor(self, *args)


    def IsDModeIn(self, *args) -> "Standard_Boolean":
        """
        :param aMode:
        :type aMode: int
        :rtype: bool

        """
        return _AIS.AIS_GlobalStatus_IsDModeIn(self, *args)


    def IsSModeIn(self, *args) -> "Standard_Boolean":
        """
        :param aMode:
        :type aMode: int
        :rtype: bool

        """
        return _AIS.AIS_GlobalStatus_IsSModeIn(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_GlobalStatus(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_GlobalStatus
AIS_GlobalStatus.SetGraphicStatus = new_instancemethod(_AIS.AIS_GlobalStatus_SetGraphicStatus, None, AIS_GlobalStatus)
AIS_GlobalStatus.AddDisplayMode = new_instancemethod(_AIS.AIS_GlobalStatus_AddDisplayMode, None, AIS_GlobalStatus)
AIS_GlobalStatus.AddSelectionMode = new_instancemethod(_AIS.AIS_GlobalStatus_AddSelectionMode, None, AIS_GlobalStatus)
AIS_GlobalStatus.SetLayerIndex = new_instancemethod(_AIS.AIS_GlobalStatus_SetLayerIndex, None, AIS_GlobalStatus)
AIS_GlobalStatus.SetHilightStatus = new_instancemethod(_AIS.AIS_GlobalStatus_SetHilightStatus, None, AIS_GlobalStatus)
AIS_GlobalStatus.SetHilightColor = new_instancemethod(_AIS.AIS_GlobalStatus_SetHilightColor, None, AIS_GlobalStatus)
AIS_GlobalStatus.IsSubIntensityOn = new_instancemethod(_AIS.AIS_GlobalStatus_IsSubIntensityOn, None, AIS_GlobalStatus)
AIS_GlobalStatus.SubIntensityOn = new_instancemethod(_AIS.AIS_GlobalStatus_SubIntensityOn, None, AIS_GlobalStatus)
AIS_GlobalStatus.SubIntensityOff = new_instancemethod(_AIS.AIS_GlobalStatus_SubIntensityOff, None, AIS_GlobalStatus)
AIS_GlobalStatus.RemoveDisplayMode = new_instancemethod(_AIS.AIS_GlobalStatus_RemoveDisplayMode, None, AIS_GlobalStatus)
AIS_GlobalStatus.RemoveSelectionMode = new_instancemethod(_AIS.AIS_GlobalStatus_RemoveSelectionMode, None, AIS_GlobalStatus)
AIS_GlobalStatus.ClearSelectionModes = new_instancemethod(_AIS.AIS_GlobalStatus_ClearSelectionModes, None, AIS_GlobalStatus)
AIS_GlobalStatus.GraphicStatus = new_instancemethod(_AIS.AIS_GlobalStatus_GraphicStatus, None, AIS_GlobalStatus)
AIS_GlobalStatus.DisplayedModes = new_instancemethod(_AIS.AIS_GlobalStatus_DisplayedModes, None, AIS_GlobalStatus)
AIS_GlobalStatus.SelectionModes = new_instancemethod(_AIS.AIS_GlobalStatus_SelectionModes, None, AIS_GlobalStatus)
AIS_GlobalStatus.IsHilighted = new_instancemethod(_AIS.AIS_GlobalStatus_IsHilighted, None, AIS_GlobalStatus)
AIS_GlobalStatus.HilightColor = new_instancemethod(_AIS.AIS_GlobalStatus_HilightColor, None, AIS_GlobalStatus)
AIS_GlobalStatus.IsDModeIn = new_instancemethod(_AIS.AIS_GlobalStatus_IsDModeIn, None, AIS_GlobalStatus)
AIS_GlobalStatus.IsSModeIn = new_instancemethod(_AIS.AIS_GlobalStatus_IsSModeIn, None, AIS_GlobalStatus)
AIS_GlobalStatus_swigregister = _AIS.AIS_GlobalStatus_swigregister
AIS_GlobalStatus_swigregister(AIS_GlobalStatus)

class Handle_AIS_GlobalStatus(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_GlobalStatus_swiginit(self, _AIS.new_Handle_AIS_GlobalStatus(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_GlobalStatus_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_GlobalStatus
Handle_AIS_GlobalStatus.Nullify = new_instancemethod(_AIS.Handle_AIS_GlobalStatus_Nullify, None, Handle_AIS_GlobalStatus)
Handle_AIS_GlobalStatus.IsNull = new_instancemethod(_AIS.Handle_AIS_GlobalStatus_IsNull, None, Handle_AIS_GlobalStatus)
Handle_AIS_GlobalStatus._get_reference = new_instancemethod(_AIS.Handle_AIS_GlobalStatus__get_reference, None, Handle_AIS_GlobalStatus)
Handle_AIS_GlobalStatus_swigregister = _AIS.Handle_AIS_GlobalStatus_swigregister
Handle_AIS_GlobalStatus_swigregister(Handle_AIS_GlobalStatus)

def Handle_AIS_GlobalStatus_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_GlobalStatus const":
    return _AIS.Handle_AIS_GlobalStatus_DownCast(AnObject)
Handle_AIS_GlobalStatus_DownCast = _AIS.Handle_AIS_GlobalStatus_DownCast

class AIS_GraphicTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetLineColor(*args) -> "void":
        """
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param TheTypeOfAttributes:
        :type TheTypeOfAttributes: AIS_TypeOfAttribute
        :rtype: Quantity_NameOfColor

        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param TheTypeOfAttributes:
        :type TheTypeOfAttributes: AIS_TypeOfAttribute
        :param TheLineColor:
        :type TheLineColor: Quantity_Color &
        :rtype: void

        """
        return _AIS.AIS_GraphicTool_GetLineColor(*args)

    GetLineColor = staticmethod(GetLineColor)

    def GetLineWidth(*args) -> "Standard_Real":
        """
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param TheTypeOfAttributes:
        :type TheTypeOfAttributes: AIS_TypeOfAttribute
        :rtype: float

        """
        return _AIS.AIS_GraphicTool_GetLineWidth(*args)

    GetLineWidth = staticmethod(GetLineWidth)

    def GetLineType(*args) -> "Aspect_TypeOfLine":
        """
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param TheTypeOfAttributes:
        :type TheTypeOfAttributes: AIS_TypeOfAttribute
        :rtype: Aspect_TypeOfLine

        """
        return _AIS.AIS_GraphicTool_GetLineType(*args)

    GetLineType = staticmethod(GetLineType)

    def GetLineAtt(*args) -> "Standard_Real &":
        """
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param TheTypeOfAttributes:
        :type TheTypeOfAttributes: AIS_TypeOfAttribute
        :param aCol:
        :type aCol: Quantity_NameOfColor &
        :param aWidth:
        :type aWidth: float &
        :param aTyp:
        :type aTyp: Aspect_TypeOfLine &
        :rtype: void

        """
        return _AIS.AIS_GraphicTool_GetLineAtt(*args)

    GetLineAtt = staticmethod(GetLineAtt)

    def GetInteriorColor(*args) -> "void":
        """
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: Quantity_NameOfColor

        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: void

        """
        return _AIS.AIS_GraphicTool_GetInteriorColor(*args)

    GetInteriorColor = staticmethod(GetInteriorColor)

    def GetMaterial(*args) -> "Graphic3d_MaterialAspect":
        """
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: Graphic3d_MaterialAspect

        """
        return _AIS.AIS_GraphicTool_GetMaterial(*args)

    GetMaterial = staticmethod(GetMaterial)

    __repr__ = _dumps_object


    def __init__(self):
        _AIS.AIS_GraphicTool_swiginit(self, _AIS.new_AIS_GraphicTool())
    __swig_destroy__ = _AIS.delete_AIS_GraphicTool
AIS_GraphicTool_swigregister = _AIS.AIS_GraphicTool_swigregister
AIS_GraphicTool_swigregister(AIS_GraphicTool)

def AIS_GraphicTool_GetLineColor(*args) -> "void":
    """
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param TheTypeOfAttributes:
    :type TheTypeOfAttributes: AIS_TypeOfAttribute
    :rtype: Quantity_NameOfColor

    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param TheTypeOfAttributes:
    :type TheTypeOfAttributes: AIS_TypeOfAttribute
    :param TheLineColor:
    :type TheLineColor: Quantity_Color &
    :rtype: void

    """
    return _AIS.AIS_GraphicTool_GetLineColor(*args)

def AIS_GraphicTool_GetLineWidth(*args) -> "Standard_Real":
    """
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param TheTypeOfAttributes:
    :type TheTypeOfAttributes: AIS_TypeOfAttribute
    :rtype: float

    """
    return _AIS.AIS_GraphicTool_GetLineWidth(*args)

def AIS_GraphicTool_GetLineType(*args) -> "Aspect_TypeOfLine":
    """
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param TheTypeOfAttributes:
    :type TheTypeOfAttributes: AIS_TypeOfAttribute
    :rtype: Aspect_TypeOfLine

    """
    return _AIS.AIS_GraphicTool_GetLineType(*args)

def AIS_GraphicTool_GetLineAtt(*args) -> "Standard_Real &":
    """
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param TheTypeOfAttributes:
    :type TheTypeOfAttributes: AIS_TypeOfAttribute
    :param aCol:
    :type aCol: Quantity_NameOfColor &
    :param aWidth:
    :type aWidth: float &
    :param aTyp:
    :type aTyp: Aspect_TypeOfLine &
    :rtype: void

    """
    return _AIS.AIS_GraphicTool_GetLineAtt(*args)

def AIS_GraphicTool_GetInteriorColor(*args) -> "void":
    """
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: Quantity_NameOfColor

    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param aColor:
    :type aColor: Quantity_Color &
    :rtype: void

    """
    return _AIS.AIS_GraphicTool_GetInteriorColor(*args)

def AIS_GraphicTool_GetMaterial(*args) -> "Graphic3d_MaterialAspect":
    """
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: Graphic3d_MaterialAspect

    """
    return _AIS.AIS_GraphicTool_GetMaterial(*args)

class AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs(OCC.TCollection.TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param K1:
        :type K1: Handle_SelectMgr_EntityOwner &
        :param K2:
        :type K2: int
        :param I:
        :type I: Handle_Prs3d_Presentation &
        :param n1:
        :type n1: TCollection_MapNodePtr &
        :param n2:
        :type n2: TCollection_MapNodePtr &
        :rtype: None

        """
        _AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_swiginit(self, _AIS.new_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs(*args))

    def Key1(self, *args) -> "Handle_SelectMgr_EntityOwner":
        """
        :rtype: Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_Key1(self, *args)


    def GetKey2(self) -> "Standard_Integer":
        """GetKey2(AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs self) -> Standard_Integer"""
        return _AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_GetKey2(self)


    def SetKey2(self, value: 'Standard_Integer') -> "void":
        """SetKey2(AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs self, Standard_Integer value)"""
        return _AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_SetKey2(self, value)


    def Next2(self, *args) -> "TCollection_MapNodePtr &":
        """
        :rtype: TCollection_MapNodePtr

        """
        return _AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_Next2(self, *args)


    def Value(self, *args) -> "Handle_Prs3d_Presentation":
        """
        :rtype: Handle_Prs3d_Presentation

        """
        return _AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs
AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs.Key1 = new_instancemethod(_AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_Key1, None, AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs.GetKey2 = new_instancemethod(_AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_GetKey2, None, AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs.SetKey2 = new_instancemethod(_AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_SetKey2, None, AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs.Next2 = new_instancemethod(_AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_Next2, None, AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs.Value = new_instancemethod(_AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_Value, None, AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_swigregister = _AIS.AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_swigregister
AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_swigregister(AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)

class Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs(OCC.TCollection.Handle_TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_swiginit(self, _AIS.new_Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs
Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs.Nullify = new_instancemethod(_AIS.Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_Nullify, None, Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)
Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs.IsNull = new_instancemethod(_AIS.Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_IsNull, None, Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)
Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs._get_reference = new_instancemethod(_AIS.Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs__get_reference, None, Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)
Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_swigregister = _AIS.Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_swigregister
Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_swigregister(Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs)

def Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs const":
    return _AIS.Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_DownCast(AnObject)
Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_DownCast = _AIS.Handle_AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs_DownCast

class AIS_IndexedDataMapOfOwnerPrs(OCC.TCollection.TCollection_BasicMap):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param NbBuckets: default value is 1
        :type NbBuckets: int
        :rtype: None

        """
        _AIS.AIS_IndexedDataMapOfOwnerPrs_swiginit(self, _AIS.new_AIS_IndexedDataMapOfOwnerPrs(*args))

    def Assign(self, *args) -> "AIS_IndexedDataMapOfOwnerPrs &":
        """
        :param Other:
        :type Other: AIS_IndexedDataMapOfOwnerPrs &
        :rtype: AIS_IndexedDataMapOfOwnerPrs

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_Assign(self, *args)


    def Set(self, *args) -> "AIS_IndexedDataMapOfOwnerPrs &":
        """
        :param Other:
        :type Other: AIS_IndexedDataMapOfOwnerPrs &
        :rtype: AIS_IndexedDataMapOfOwnerPrs

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_Set(self, *args)


    def ReSize(self, *args) -> "void":
        """
        :param NbBuckets:
        :type NbBuckets: int
        :rtype: None

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_ReSize(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_Clear(self, *args)


    def Add(self, *args) -> "Standard_Integer":
        """
        :param K:
        :type K: Handle_SelectMgr_EntityOwner &
        :param I:
        :type I: Handle_Prs3d_Presentation &
        :rtype: int

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_Add(self, *args)


    def Substitute(self, *args) -> "void":
        """
        :param I:
        :type I: int
        :param K:
        :type K: Handle_SelectMgr_EntityOwner &
        :param T:
        :type T: Handle_Prs3d_Presentation &
        :rtype: None

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_Substitute(self, *args)


    def RemoveLast(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_RemoveLast(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        :param K:
        :type K: Handle_SelectMgr_EntityOwner &
        :rtype: bool

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_Contains(self, *args)


    def FindKey(self, *args) -> "Handle_SelectMgr_EntityOwner":
        """
        :param I:
        :type I: int
        :rtype: Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_FindKey(self, *args)


    def FindFromIndex(self, *args) -> "Handle_Prs3d_Presentation":
        """
        :param I:
        :type I: int
        :rtype: Handle_Prs3d_Presentation

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_FindFromIndex(self, *args)


    def ChangeFromIndex(self, *args) -> "Handle_Prs3d_Presentation":
        """
        :param I:
        :type I: int
        :rtype: Handle_Prs3d_Presentation

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_ChangeFromIndex(self, *args)


    def FindIndex(self, *args) -> "Standard_Integer":
        """
        :param K:
        :type K: Handle_SelectMgr_EntityOwner &
        :rtype: int

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_FindIndex(self, *args)


    def FindFromKey(self, *args) -> "Handle_Prs3d_Presentation":
        """
        :param K:
        :type K: Handle_SelectMgr_EntityOwner &
        :rtype: Handle_Prs3d_Presentation

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_FindFromKey(self, *args)


    def ChangeFromKey(self, *args) -> "Handle_Prs3d_Presentation":
        """
        :param K:
        :type K: Handle_SelectMgr_EntityOwner &
        :rtype: Handle_Prs3d_Presentation

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_ChangeFromKey(self, *args)


    def FindFromKey1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: Handle_SelectMgr_EntityOwner &
        :rtype: Standard_Address

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_FindFromKey1(self, *args)


    def ChangeFromKey1(self, *args) -> "Standard_Address":
        """
        :param K:
        :type K: Handle_SelectMgr_EntityOwner &
        :rtype: Standard_Address

        """
        return _AIS.AIS_IndexedDataMapOfOwnerPrs_ChangeFromKey1(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_IndexedDataMapOfOwnerPrs
AIS_IndexedDataMapOfOwnerPrs.Assign = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_Assign, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.Set = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_Set, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.ReSize = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_ReSize, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.Clear = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_Clear, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.Add = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_Add, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.Substitute = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_Substitute, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.RemoveLast = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_RemoveLast, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.Contains = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_Contains, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.FindKey = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_FindKey, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.FindFromIndex = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_FindFromIndex, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.ChangeFromIndex = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_ChangeFromIndex, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.FindIndex = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_FindIndex, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.FindFromKey = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_FindFromKey, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.ChangeFromKey = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_ChangeFromKey, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.FindFromKey1 = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_FindFromKey1, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs.ChangeFromKey1 = new_instancemethod(_AIS.AIS_IndexedDataMapOfOwnerPrs_ChangeFromKey1, None, AIS_IndexedDataMapOfOwnerPrs)
AIS_IndexedDataMapOfOwnerPrs_swigregister = _AIS.AIS_IndexedDataMapOfOwnerPrs_swigregister
AIS_IndexedDataMapOfOwnerPrs_swigregister(AIS_IndexedDataMapOfOwnerPrs)

class AIS_InteractiveContext(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs the interactive context object defined by the principal viewer MainViewer.

        :param MainViewer:
        :type MainViewer: Handle_V3d_Viewer &
        :rtype: None

        """
        _AIS.AIS_InteractiveContext_swiginit(self, _AIS.new_AIS_InteractiveContext(*args))

    def SetAutoActivateSelection(self, *args) -> "void":
        """
        :param Auto:
        :type Auto: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetAutoActivateSelection(self, *args)


    def GetAutoActivateSelection(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_GetAutoActivateSelection(self, *args)


    def Display(self, *args) -> "void":
        """
        * Controls the choice between the using the display and selection modes of open local context which you have defined and activating those available by default. If a local context is open and if updateviewer equals Standard_False, the Interactive Object anIobj is displayed in the default active mode. This will be the object's default display mode, if there is one. Otherwise, it will be the context mode. The Interactive Object's default selection mode is activated. In general, this is 0. This syntax has the same behavior as local context, open or closed. If you want to view the object in open local context without selection, use the syntax below, setting aSelectionMode to -1.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * Controls the choice between the using the display and selection modes of open local context which you have defined and activating those available by default. If no Local Context is opened. and the Interactive Object aniobj has no display mode of its own, the default display mode, 0, is used. Likewise, if aniobj has no selection mode of its own, the default one, 0, is used. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated. If aSelectionMode equals -1, anIobj will not be activated: it will be displayed but will not be selectable. Use this if you want to view the object in open local context without selection. Note: This option is only available in Local Context. If allowDecomposition equals true, anIObj can have subshapes detected by selection mechanisms. anIObj must be able to give a shape selection modes which fit the AIS_Shape selection modes: - vertices: 1 - edges: 2 - wires: 3.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :param amode:
        :type amode: int
        :param aSelectionMode:
        :type aSelectionMode: int
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :param allowdecomposition: default value is Standard_True
        :type allowdecomposition: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Display(self, *args)


    def Load(self, *args) -> "void":
        """
        * Allows you to load the Interactive Object aniobj with a given selection mode SelectionMode, and/or with the desired decomposition option, whether the object is visualized or not. If AllowDecomp = Standard_True and, if the interactive object is of the 'Shape' type, these 'standard' selection modes will be automatically activated as a function of the modes present in the Local Context. The loaded objects will be selectable but displayable in highlighting only when detected by the Selector. This method is available only when Local Contexts are open.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param SelectionMode: default value is -1
        :type SelectionMode: int
        :param AllowDecomp: default value is Standard_False
        :type AllowDecomp: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Load(self, *args)


    def Erase(self, *args) -> "void":
        """
        * Hides the object. The object's presentations are simply flagged as invisible and therefore excluded from redrawing. To show hidden objects, use Display().

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Erase(self, *args)


    def EraseAll(self, *args) -> "void":
        """
        * Hides all objects. The object's presentations are simply flagged as invisible and therefore excluded from redrawing. To show all hidden objects, use DisplayAll().

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_EraseAll(self, *args)


    def DisplayAll(self, *args) -> "void":
        """
        * Displays all hidden objects.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_DisplayAll(self, *args)


    def EraseSelected(self, *args) -> "void":
        """
        * Hides selected objects. The object's presentations are simply flagged as invisible and therefore excluded from redrawing. To show hidden objects, use Display().

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_EraseSelected(self, *args)


    def DisplaySelected(self, *args) -> "void":
        """
        * Displays selected objects if a local context is open. Displays current objects if there is no active local context. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_DisplaySelected(self, *args)


    def KeepTemporary(self, *args) -> "Standard_Boolean":
        """
        * Changes the status of a temporary object. It will be kept at the neutral point, i.e. put in the list of displayed objects along withwith its temporary attributes. These include display mode and selection mode, for example. Returns true if done. inWhichLocal gives the local context in which anIObj is displayed. By default, the index -1 refers to the last Local Context opened.

        :param anIObj:
        :type anIObj: Handle_AIS_InteractiveObject &
        :param InWhichLocal: default value is -1
        :type InWhichLocal: int
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_KeepTemporary(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Removes the interactive object aniobj from all viewers. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Clear(self, *args)


    def ClearPrs(self, *args) -> "void":
        """
        * Empties the graphic presentation of the mode indexed by aMode. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated. Warning Removes anIobj. anIobj is still active if it was previously activated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aMode: default value is 0
        :type aMode: int
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ClearPrs(self, *args)


    def Remove(self, *args) -> "void":
        """
        * Removes aniobj from every viewer. aniobj is no longer referenced in the Context. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Remove(self, *args)


    def RemoveAll(self, *args) -> "void":
        """
        * Removes all the objects from all opened Local Contexts and from the Neutral Point

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_RemoveAll(self, *args)


    def Hilight(self, *args) -> "void":
        """
        * Updates the display in the viewer to take dynamic detection into account. On dynamic detection by the mouse cursor, sensitive primitives are highlighted. The highlight color of entities detected by mouse movement is white by default. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Hilight(self, *args)


    def HilightWithColor(self, *args) -> "void":
        """
        * Changes the color of all the lines of the object in view, aniobj. It paints these lines the color passed as the argument, aCol. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aCol:
        :type aCol: Quantity_NameOfColor
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_HilightWithColor(self, *args)


    def Unhilight(self, *args) -> "void":
        """
        * Removes hilighting from the entity aniobj. Updates the viewer. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Unhilight(self, *args)


    def SetDisplayPriority(self, *args) -> "void":
        """
        * Sets the display priority aPriority of the seen parts presentation of the entity anIobj.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :param aPriority:
        :type aPriority: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetDisplayPriority(self, *args)


    def SetZLayer(self, *args) -> "void":
        """
        * Set Z layer id for interactive object. The layer can be specified for displayed object only. The Z layers can be used to display temporarily presentations of some object in front of the other objects in the scene. The ids for Z layers are generated by V3d_Viewer. Note that Z layers differ from under-/overlayer in V3d_View: under-/overlayer are intended for specific 2D drawings that appear behind/in front of all 3D presentations, while SetZLayer() method applies to regular 3D presentations and does not imply any specific drawing methods.

        :param theIObj:
        :type theIObj: Handle_AIS_InteractiveObject &
        :param theLayerId:
        :type theLayerId: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetZLayer(self, *args)


    def GetZLayer(self, *args) -> "Standard_Integer":
        """
        * Get Z layer id set for displayed interactive object. If the object doesn't exists in context or has no computed presentations, the method returns -1.

        :param theIObj:
        :type theIObj: Handle_AIS_InteractiveObject &
        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_GetZLayer(self, *args)


    def Redisplay(self, *args) -> "void":
        """
        * Recomputes the seen parts presentation of the entity aniobj. If allmodes equals true, all presentations are present in the object even if unseen. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :param allmodes: default value is Standard_False
        :type allmodes: bool
        :rtype: None

        * Recomputes the Prs/Selection of displayed objects of a given type and a given signature. if signature = -1 doesnt take signature criterion.

        :param aTypeOfObject:
        :type aTypeOfObject: AIS_KindOfInteractive
        :param Signature: default value is -1
        :type Signature: int
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Redisplay(self, *args)


    def RecomputePrsOnly(self, *args) -> "void":
        """
        * Recomputes the displayed presentations, flags the others Doesn't update presentations

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :param allmodes: default value is Standard_False
        :type allmodes: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_RecomputePrsOnly(self, *args)


    def RecomputeSelectionOnly(self, *args) -> "void":
        """
        * Recomputes the active selections, flags the others Doesn't update presentations

        :param anIObj:
        :type anIObj: Handle_AIS_InteractiveObject &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_RecomputeSelectionOnly(self, *args)


    def Update(self, *args) -> "void":
        """
        * Updates displayed interactive object by checking and recomputing its flagged as 'to be recomputed' presentation and selection structures. This method does not force any recomputation on its own. The method recomputes selections even if they are loaded without activation in particular selector.

        :param theIObj:
        :type theIObj: Handle_AIS_InteractiveObject &
        :param theUpdateViewer: default value is Standard_True
        :type theUpdateViewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Update(self, *args)


    def UnsetDisplayMode(self, *args) -> "void":
        """
        * Unsets the display mode of seen Interactive Objects. aMode provides the display mode index of the entity aniobj. If updateviewer equals Standard_True, the predominant mode aMode will overule the context mode. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object returns to the default selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UnsetDisplayMode(self, *args)


    def SetSelectionMode(self, *args) -> "void":
        """
        * Sets the selection mode of Interactive Objects. aMode provides the selection mode index of the entity aniobj.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetSelectionMode(self, *args)


    def UnsetSelectionMode(self, *args) -> "void":
        """
        * Removes selection mode from Interactive Objects. aMode provides the selection mode index of the entity aniobj.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UnsetSelectionMode(self, *args)


    def SetSensitivityMode(self, *args) -> "void":
        """
        * Sets the selection sensitivity mode. SM_WINDOW mode uses the specified pixel tolerance to compute the sensitivity value, SM_VIEW mode allows to define the sensitivity manually.

        :param aMode:
        :type aMode: StdSelect_SensitivityMode
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetSensitivityMode(self, *args)


    def SensitivityMode(self, *args) -> "StdSelect_SensitivityMode":
        """
        * Returns the selection sensitivity mode.

        :rtype: StdSelect_SensitivityMode

        """
        return _AIS.AIS_InteractiveContext_SensitivityMode(self, *args)


    def SetSensitivity(self, *args) -> "void":
        """
        * Sets the sensitivity aPrecision according to the view size for the current context or local context if any is activated. Sets the sensitivity aPrecision in pixels for the current context or local context if any is activated. By default, this sensitivity is equal to 4 pixels. When a local context is open, the defined sensitivity applies to this local context instead of the main context.

        :param aPrecision:
        :type aPrecision: float
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetSensitivity(self, *args)


    def Sensitivity(self, *args) -> "Standard_Real":
        """
        * Returns the selection sensitivity value.

        :rtype: float

        """
        return _AIS.AIS_InteractiveContext_Sensitivity(self, *args)


    def SetPixelTolerance(self, *args) -> "void":
        """
        * Define the current selection pixel sensitivity for this context or local context if any one is activated. Warning: When a local context is open the sensitivity is apply on it instead on the main context.

        :param aPrecision: default value is 4
        :type aPrecision: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetPixelTolerance(self, *args)


    def PixelTolerance(self, *args) -> "Standard_Integer":
        """
        * Returns the pixel tolerance.

        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_PixelTolerance(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Puts the location aLocation on the initial graphic representation and the selection for the entity aniobj. In other words, aniobj is visible and selectable at a position other than initial position. Graphic and selection primitives are not recomputed. To clean the view correctly, you must reset the previous location.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aLocation:
        :type aLocation: TopLoc_Location &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetLocation(self, *args)


    def ResetLocation(self, *args) -> "void":
        """
        * Puts the entity aniobj back into its initial position.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ResetLocation(self, *args)


    def HasLocation(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the entity aniobj has a location.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_HasLocation(self, *args)


    def Location(self, *args) -> "TopLoc_Location":
        """
        * Returns the location of the entity aniobj.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: TopLoc_Location

        """
        return _AIS.AIS_InteractiveContext_Location(self, *args)


    def SetCurrentFacingModel(self, *args) -> "void":
        """
        * change the current facing model apply on polygons for SetColor(), SetTransparency(), SetMaterial() methods default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is applying both on the front and back face.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aModel: default value is Aspect_TOFM_BOTH_SIDE
        :type aModel: Aspect_TypeOfFacingModel
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetCurrentFacingModel(self, *args)


    def SetColor(self, *args) -> "void":
        """
        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aColor:
        :type aColor: Quantity_NameOfColor
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * Sets the color of the selected entity. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aColor:
        :type aColor: Quantity_Color &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetColor(self, *args)


    def UnsetColor(self, *args) -> "void":
        """
        * Removes the color selection for the selected entity. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UnsetColor(self, *args)


    def SetWidth(self, *args) -> "void":
        """
        * Sets the width of the entity aniobj. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aValue:
        :type aValue: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: void

        """
        return _AIS.AIS_InteractiveContext_SetWidth(self, *args)


    def UnsetWidth(self, *args) -> "void":
        """
        * Removes the width setting of the entity aniobj. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: void

        """
        return _AIS.AIS_InteractiveContext_UnsetWidth(self, *args)


    def SetMaterial(self, *args) -> "void":
        """
        * Provides the type of material setting for the view of the entity aniobj. The range of settings includes: BRASS, BRONZE, GOLD, PEWTER, SILVER, STONE. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aName:
        :type aName: Graphic3d_NameOfMaterial
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetMaterial(self, *args)


    def UnsetMaterial(self, *args) -> "void":
        """
        * Removes the type of material setting for viewing the entity aniobj. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param anObj:
        :type anObj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UnsetMaterial(self, *args)


    def SetTransparency(self, *args) -> "void":
        """
        * Provides the transparency settings for viewing the entity aniobj. The transparency value aValue may be between 0.0, opaque, and 1.0, fully transparent. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aValue: default value is 0.6
        :type aValue: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetTransparency(self, *args)


    def UnsetTransparency(self, *args) -> "void":
        """
        * Removes the transparency settings for viewing the entity aniobj. The transparency value aValue may be between 0.0, opaque, and 1.0, fully transparent. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UnsetTransparency(self, *args)


    def SetLocalAttributes(self, *args) -> "void":
        """
        * Sets the attributes of the interactive object aniobj by plugging the attribute manager aDrawer into the local context. The graphic attributes of aDrawer such as visualization mode, color, and material, are then used to display aniobj. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aDrawer:
        :type aDrawer: Handle_AIS_Drawer &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetLocalAttributes(self, *args)


    def UnsetLocalAttributes(self, *args) -> "void":
        """
        * Removes the settings for local attributes of the entity anObj and returns to the Neutral Point attributes or those of the previous local context. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param anObj:
        :type anObj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UnsetLocalAttributes(self, *args)


    def SetPolygonOffsets(self, *args) -> "void":
        """
        * Sets up polygon offsets for the given AIS_InteractiveObject. It simply calls anObj->SetPolygonOffsets()

        :param anObj:
        :type anObj: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int
        :param aFactor: default value is 1.0
        :type aFactor: Standard_ShortReal
        :param aUnits: default value is 0.0
        :type aUnits: Standard_ShortReal
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args) -> "Standard_Boolean":
        """
        * simply calls anObj->HasPolygonOffsets()

        :param anObj:
        :type anObj: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args) -> "void":
        """
        * Retrieves current polygon offsets settings for <anObj>.

        :param anObj:
        :type anObj: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int &
        :param aFactor:
        :type aFactor: Standard_ShortReal &
        :param aUnits:
        :type aUnits: Standard_ShortReal &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_PolygonOffsets(self, *args)


    def SetTrihedronSize(self, *args) -> "void":
        """
        * Sets the size aSize of the trihedron. Is used to change the default value 100 mm for display of trihedra. Use of this function in one of your own interactive objects requires a call to the Compute function of the new class. This will recalculate the presentation for every trihedron displayed. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aSize:
        :type aSize: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetTrihedronSize(self, *args)


    def TrihedronSize(self, *args) -> "Standard_Real":
        """
        * returns the current value of trihedron size.

        :rtype: float

        """
        return _AIS.AIS_InteractiveContext_TrihedronSize(self, *args)


    def SetPlaneSize(self, *args) -> "void":
        """
        * Sets the plane size defined by the length in the X direction XSize and that in the Y direction YSize. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aSizeX:
        :type aSizeX: float
        :param aSizeY:
        :type aSizeY: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * Sets the plane size aSize. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated. May be used if PlaneSize returns true.

        :param aSize:
        :type aSize: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetPlaneSize(self, *args)


    def PlaneSize(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the length in the X direction XSize is the same as that in the Y direction YSize.

        :param XSize:
        :type XSize: float &
        :param YSize:
        :type YSize: float &
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_PlaneSize(self, *args)


    def DisplayStatus(self, *args) -> "AIS_DisplayStatus":
        """
        * Returns the display status of the entity anIobj. This will be one of the following: - DS_Displayed displayed in main viewer - DS_Erased hidden in main viewer - DS_Temporary temporarily displayed - DS_None nowhere displayed.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :rtype: AIS_DisplayStatus

        """
        return _AIS.AIS_InteractiveContext_DisplayStatus(self, *args)


    def DisplayedModes(self, *args) -> "TColStd_ListOfInteger const &":
        """
        * Returns the list of active display modes for the entity aniobj.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: TColStd_ListOfInteger

        """
        return _AIS.AIS_InteractiveContext_DisplayedModes(self, *args)


    def IsDisplayed(self, *args) -> "Standard_Boolean":
        """
        * Returns true if anIobj is displayed in the interactive context.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :rtype: bool

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_IsDisplayed(self, *args)


    def IsHilighted(self, *args) -> "Standard_Boolean":
        """
        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: bool

        * if <anIObj> is hilighted with a specific color <WithColor> will be returned True <theHiCol> gives the name of the hilightcolor

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :param WithColor:
        :type WithColor: bool
        :param theHiCol:
        :type theHiCol: Quantity_NameOfColor &
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_IsHilighted(self, *args)


    def DisplayPriority(self, *args) -> "Standard_Integer":
        """
        * Returns the display priority of the entity anIobj. This will be display mode of anIobj if it is in the main viewer.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_DisplayPriority(self, *args)


    def HasColor(self, *args) -> "Standard_Boolean":
        """
        * Returns true if a view of the Interactive Object aniobj has color.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_HasColor(self, *args)


    def Color(self, *args) -> "void":
        """
        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: Quantity_NameOfColor

        * Returns the color Color of the entity aniobj in the interactive context.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param acolor:
        :type acolor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Color(self, *args)


    def Width(self, *args) -> "Standard_Real":
        """
        * Returns the width of the Interactive Object aniobj in the interactive context.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: float

        """
        return _AIS.AIS_InteractiveContext_Width(self, *args)


    def Status(self, *args) -> "void":
        """
        * Returns the status astatus of the Interactive Context for the view of the Interactive Object anObj.

        :param anObj:
        :type anObj: Handle_AIS_InteractiveObject &
        :param astatus:
        :type astatus: TCollection_ExtendedString &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Status(self, *args)


    def UpdateCurrentViewer(self, *args) -> "void":
        """
        * Updates the current viewer, the viewer in Neutral Point. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UpdateCurrentViewer(self, *args)


    def DisplayMode(self, *args) -> "Standard_Integer":
        """
        * Returns the display mode setting. Note that mode 3 is only used.

        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_DisplayMode(self, *args)


    def HilightColor(self, *args) -> "Quantity_NameOfColor":
        """
        * Returns the name of the color used to show highlighted entities, that is, entities picked out by the mouse.

        :rtype: Quantity_NameOfColor

        """
        return _AIS.AIS_InteractiveContext_HilightColor(self, *args)


    def PreSelectionColor(self, *args) -> "Quantity_NameOfColor":
        """
        * Returns the name of the color used to show preselection. By default, this is Quantity_NOC_GREEN.

        :rtype: Quantity_NameOfColor

        """
        return _AIS.AIS_InteractiveContext_PreSelectionColor(self, *args)


    def DefaultColor(self, *args) -> "Quantity_NameOfColor":
        """
        * Returns the name of the color used by default. By default, this is Quantity_NOC_GOLDENROD.

        :rtype: Quantity_NameOfColor

        """
        return _AIS.AIS_InteractiveContext_DefaultColor(self, *args)


    def SubIntensityColor(self, *args) -> "Quantity_NameOfColor":
        """
        * Returns the name of the color used to show that an object is not currently selected. By default, this is Quantity_NOC_GRAY40.

        :rtype: Quantity_NameOfColor

        """
        return _AIS.AIS_InteractiveContext_SubIntensityColor(self, *args)


    def SetHilightColor(self, *args) -> "void":
        """
        * Sets the color used to show highlighted entities, that is, entities picked by the mouse. By default, this is Quantity_NOC_CYAN1.

        :param aHiCol:
        :type aHiCol: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetHilightColor(self, *args)


    def SelectionColor(self, *args) -> "void":
        """
        * Returns the name of the color used to show selected entities. By default, this is Quantity_NOC_GRAY80.

        :rtype: Quantity_NameOfColor

        * Sets the color used to show selected entities. By default, this is Quantity_NOC_GRAY80.

        :param aCol:
        :type aCol: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SelectionColor(self, *args)


    def SetPreselectionColor(self, *args) -> "void":
        """
        * Allows you to set the color used to show preselection. By default, this is Quantity_NOC_GREEN. A preselected entity is one which has been selected as the domain of application of a function such as a fillet.

        :param aCol:
        :type aCol: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetPreselectionColor(self, *args)


    def SetSubIntensityColor(self, *args) -> "void":
        """
        * Sets the color used to show that an object is not currently selected. By default, this is Quantity_NOC_GRAY40.

        :param aCol:
        :type aCol: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetSubIntensityColor(self, *args)


    def SetDisplayMode(self, *args) -> "void":
        """
        * Sets the display mode of seen Interactive Objects. aMode provides the display mode index of the entity aniobj. If updateviewer equals Standard_True, the predominant mode aMode will overule the context mode. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object returns to the default selection mode; the object is displayed but no viewer will be updated. Note that display mode 3 is only used if you have an AIS_Textured Shape.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * Sets the display mode of seen Interactive Objects. aMode provides the display mode index of the entity aniobj. If updateviewer equals Standard_True, the predominant mode aMode will overule the context mode. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object returns to the default selection mode; the object is displayed but no viewer will be updated. Note that display mode 3 is only used if you have an AIS_Textured Shape.

        :param AMode:
        :type AMode: AIS_DisplayMode
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetDisplayMode(self, *args)


    def SetAngleAndDeviation(self, *args) -> "void":
        """
        * Calls the AIS_Shape SetAngleAndDeviation to set both Angle and Deviation coefficients

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param anAngle:
        :type anAngle: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetAngleAndDeviation(self, *args)


    def SetHLRDeviationAngle(self, *args) -> "void":
        """
        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param anAngle:
        :type anAngle: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetHLRDeviationAngle(self, *args)


    def SetDeviationCoefficient(self, *args) -> "void":
        """
        * Sets the deviation coefficient aCoefficient. Drawings of curves or patches are made with respect to a maximal chordal deviation. A Deviation coefficient is used in the shading display mode. The shape is seen decomposed into triangles. These are used to calculate reflection of light from the surface of the object. The triangles are formed from chords of the curves in the shape. The deviation coefficient aCoefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve. If this limit is reached, a new triangle is begun. This deviation is absolute and is set through the method: SetMaximalChordialDeviation. The default value is 0.001. In drawing shapes, however, you are allowed to ask for a relative deviation. This deviation will be: SizeOfObject * DeviationCoefficient. default 0.001

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aCoefficient:
        :type aCoefficient: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * Sets the deviation coefficient aCoefficient. Drawings of curves or patches are made with respect to a maximal chordal deviation. A Deviation coefficient is used in the shading display mode. The shape is seen decomposed into triangles. These are used to calculate reflection of light from the surface of the object. The triangles are formed from chords of the curves in the shape. The deviation coefficient aCoefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve. If this limit is reached, a new triangle is begun. This deviation is absolute and is set through the method: SetMaximalChordialDeviation. The default value is 0.001. In drawing shapes, however, you are allowed to ask for a relative deviation. This deviation will be: SizeOfObject * DeviationCoefficient. default 0.001

        :param aCoefficient:
        :type aCoefficient: float
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetDeviationCoefficient(self, *args)


    def DeviationCoefficient(self, *args) -> "Standard_Real":
        """
        * Returns the deviation coefficient. Drawings of curves or patches are made with respect to a maximal chordal deviation. A Deviation coefficient is used in the shading display mode. The shape is seen decomposed into triangles. These are used to calculate reflection of light from the surface of the object. The triangles are formed from chords of the curves in the shape. The deviation coefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve. If this limit is reached, a new triangle is begun. This deviation is absolute and is set through AIS_Drawer::SetMaximalChordialDeviation. The default value is 0.001. In drawing shapes, however, you are allowed to ask for a relative deviation. This deviation will be: SizeOfObject * DeviationCoefficient.

        :rtype: float

        """
        return _AIS.AIS_InteractiveContext_DeviationCoefficient(self, *args)


    def SetDeviationAngle(self, *args) -> "void":
        """
        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param anAngle:
        :type anAngle: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * default 6degrees

        :param anAngle:
        :type anAngle: float
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetDeviationAngle(self, *args)


    def DeviationAngle(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _AIS.AIS_InteractiveContext_DeviationAngle(self, *args)


    def SetHLRDeviationCoefficient(self, *args) -> "void":
        """
        * Sets the deviation coefficient aCoefficient for removal of hidden lines created by different viewpoints in different presentations. The Default value is 0.02.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param aCoefficient:
        :type aCoefficient: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * Sets the deviation coefficient aCoefficient for removal of hidden lines created by different viewpoints in different presentations. The Default value is 0.02.

        :param aCoefficient:
        :type aCoefficient: float
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetHLRDeviationCoefficient(self, *args)


    def HLRDeviationCoefficient(self, *args) -> "Standard_Real":
        """
        * Returns the real number value of the hidden line removal deviation coefficient. A Deviation coefficient is used in the shading display mode. The shape is seen decomposed into triangles. These are used to calculate reflection of light from the surface of the object. The triangles are formed from chords of the curves in the shape. The deviation coefficient give the highest value of the angle with which a chord can deviate from a tangent to a curve. If this limit is reached, a new triangle is begun. To find the hidden lines, hidden line display mode entails recalculation of the view at each different projector perspective. Because hidden lines entail calculations of more than usual complexity to decompose them into these triangles, a deviation coefficient allowing greater tolerance is used. This increases efficiency in calculation. The Default value is 0.02.

        :rtype: float

        """
        return _AIS.AIS_InteractiveContext_HLRDeviationCoefficient(self, *args)


    def SetHLRAngle(self, *args) -> "void":
        """
        * Sets the HLR angle anAngle.

        :param anAngle:
        :type anAngle: float
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetHLRAngle(self, *args)


    def HLRAngle(self, *args) -> "Standard_Real":
        """
        * Returns the real number value of the deviation angle in hidden line removal views in this interactive context. The default value is 20*PI/180.

        :rtype: float

        """
        return _AIS.AIS_InteractiveContext_HLRAngle(self, *args)


    def SetHLRAngleAndDeviation(self, *args) -> "void":
        """
        * Computes a HLRAngle and a HLRDeviationCoefficient by means of the angle anAngle and sets the corresponding methods in the default drawing tool with these values.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param anAngle:
        :type anAngle: float
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * compute with anangle a HLRAngle and a HLRDeviationCoefficient and set them in myHLRAngle and in myHLRDeviationCoefficient of myDefaultDrawer ; anAngle is in radian ; ( 1 deg < angle in deg < 20 deg)

        :param anAngle:
        :type anAngle: float
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetHLRAngleAndDeviation(self, *args)


    def HiddenLineAspect(self, *args) -> "Handle_Prs3d_LineAspect":
        """
        * Initializes hidden line aspect in the default drawing tool, or Drawer. The default values are: Color: Quantity_NOC_YELLOW Type of line: Aspect_TOL_DASH Width: 1.

        :rtype: Handle_Prs3d_LineAspect

        """
        return _AIS.AIS_InteractiveContext_HiddenLineAspect(self, *args)


    def SetHiddenLineAspect(self, *args) -> "void":
        """
        * Sets the hidden line aspect anAspect. anAspect defines display attributes for hidden lines in HLR projections.

        :param anAspect:
        :type anAspect: Handle_Prs3d_LineAspect &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetHiddenLineAspect(self, *args)


    def DrawHiddenLine(self, *args) -> "Standard_Boolean":
        """
        * returns Standard_True if the hidden lines are to be drawn. By default the hidden lines are not drawn.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_DrawHiddenLine(self, *args)


    def EnableDrawHiddenLine(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_EnableDrawHiddenLine(self, *args)


    def DisableDrawHiddenLine(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_DisableDrawHiddenLine(self, *args)


    def SetIsoNumber(self, *args) -> "void":
        """
        * Sets the number of U and V isoparameters displayed.

        :param NbIsos:
        :type NbIsos: int
        :param WhichIsos: default value is AIS_TOI_Both
        :type WhichIsos: AIS_TypeOfIso
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetIsoNumber(self, *args)


    def IsoNumber(self, *args) -> "Standard_Integer":
        """
        * Returns the number of U and V isoparameters displayed.

        :param WhichIsos: default value is AIS_TOI_Both
        :type WhichIsos: AIS_TypeOfIso
        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_IsoNumber(self, *args)


    def IsoOnPlane(self, *args) -> "Standard_Boolean":
        """
        * Returns True if drawing isoparameters on planes is enabled.

        :param SwitchOn:
        :type SwitchOn: bool
        :rtype: None

        * Returns True if drawing isoparameters on planes is enabled. if <forUIsos> = False,

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_IsoOnPlane(self, *args)


    def SetSelectedAspect(self, *args) -> "void":
        """
        * Sets the graphic basic aspect to the current presentation of ALL selected objects. When <globalChange> is True , the full object presentation is changed. When <globalChange> is False , only the current group of the object presentation is changed. Updates the viewer when <updateViewer> is True

        :param anAspect:
        :type anAspect: Handle_Prs3d_BasicAspect &
        :param globalChange: default value is Standard_True
        :type globalChange: bool
        :param updateViewer: default value is Standard_True
        :type updateViewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetSelectedAspect(self, *args)


    def MoveTo(self, *args) -> "AIS_StatusOfDetection":
        """
        * Relays mouse position in pixels theXPix and theYPix to the interactive context selectors. This is done by the view theView passing this position to the main viewer and updating it. Functions in both Neutral Point and local contexts. If theToRedrawOnUpdate is set to false, callee should call RedrawImmediate() to highlight detected object.

        :param theXPix:
        :type theXPix: int
        :param theYPix:
        :type theYPix: int
        :param theView:
        :type theView: Handle_V3d_View &
        :param theToRedrawOnUpdate: default value is Standard_True
        :type theToRedrawOnUpdate: bool
        :rtype: AIS_StatusOfDetection

        """
        return _AIS.AIS_InteractiveContext_MoveTo(self, *args)


    def HasNextDetected(self, *args) -> "Standard_Boolean":
        """
        * returns True if other entities were detected in the last mouse detection

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_HasNextDetected(self, *args)


    def HilightNextDetected(self, *args) -> "Standard_Integer":
        """
        * if more than 1 object is detected by the selector, only the 'best' owner is hilighted at the mouse position. This Method allows the user to hilight one after another the other detected entities. if The method select is called, the selected entity will be the hilighted one! returns the Rank of hilighted entity WARNING : Loop Method. When all the detected entities have been hilighted , the next call will hilight the first one again

        :param theView:
        :type theView: Handle_V3d_View &
        :param theToRedrawImmediate: default value is Standard_True
        :type theToRedrawImmediate: bool
        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_HilightNextDetected(self, *args)


    def HilightPreviousDetected(self, *args) -> "Standard_Integer":
        """
        * Same as previous methods in reverse direction...

        :param theView:
        :type theView: Handle_V3d_View &
        :param theToRedrawImmediate: default value is Standard_True
        :type theToRedrawImmediate: bool
        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_HilightPreviousDetected(self, *args)


    def Select(self, *args) -> "AIS_StatusOfPick":
        """
        * Selects everything found in the bounding rectangle defined by the pixel minima and maxima, XPMin, YPMin, XPMax, and YPMax in the view, aView The objects detected are passed to the main viewer, which is then updated.

        :param XPMin:
        :type XPMin: int
        :param YPMin:
        :type YPMin: int
        :param XPMax:
        :type XPMax: int
        :param YPMax:
        :type YPMax: int
        :param aView:
        :type aView: Handle_V3d_View &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        * polyline selection; clears the previous picked list

        :param Polyline:
        :type Polyline: TColgp_Array1OfPnt2d
        :param aView:
        :type aView: Handle_V3d_View &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        * Stores and hilights the previous detected; Unhilights the previous picked.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        """
        return _AIS.AIS_InteractiveContext_Select(self, *args)


    def ShiftSelect(self, *args) -> "AIS_StatusOfPick":
        """
        * adds the last detected to the list of previous picked. if the last detected was already declared as picked, removes it from the Picked List.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        * adds the last detected to the list of previous picked. if the last detected was already declared as picked, removes it from the Picked List.

        :param Polyline:
        :type Polyline: TColgp_Array1OfPnt2d
        :param aView:
        :type aView: Handle_V3d_View &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        * rectangle of selection ; adds new detected entities into the picked list, removes the detected entities that were already stored...

        :param XPMin:
        :type XPMin: int
        :param YPMin:
        :type YPMin: int
        :param XPMax:
        :type XPMax: int
        :param YPMax:
        :type YPMax: int
        :param aView:
        :type aView: Handle_V3d_View &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        """
        return _AIS.AIS_InteractiveContext_ShiftSelect(self, *args)


    def SetToHilightSelected(self, *args) -> "void":
        """
        * Specify whether selected object must be hilighted when mouse cursor is moved above it (in MoveTo method). By default this value is false and selected object is not hilighted in this case.

        :param toHilight:
        :type toHilight: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetToHilightSelected(self, *args)


    def ToHilightSelected(self, *args) -> "Standard_Boolean":
        """
        * Return value specified whether selected object must be hilighted when mouse cursor is moved above it

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_ToHilightSelected(self, *args)


    def SetCurrentObject(self, *args) -> "void":
        """
        * Updates the view of the current object in open context. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetCurrentObject(self, *args)


    def AddOrRemoveCurrentObject(self, *args) -> "void":
        """
        * Allows you to add a current object to the list of current objects or remove it from that list. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_AddOrRemoveCurrentObject(self, *args)


    def UpdateCurrent(self, *args) -> "void":
        """
        * Updates the list of current objects, i.e. hilights new current objects, removes hilighting from former current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UpdateCurrent(self, *args)


    def WasCurrentTouched(self, *args) -> "Standard_Boolean":
        """
        * Returns the current selection touched by the cursor. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_WasCurrentTouched(self, *args)


    def SetOkCurrent(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetOkCurrent(self, *args)


    def IsCurrent(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is a non-null interactive object in Neutral Point. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_IsCurrent(self, *args)


    def InitCurrent(self, *args) -> "void":
        """
        * Initializes a scan of the current selected objects in Neutral Point. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_InitCurrent(self, *args)


    def MoreCurrent(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is another object found by the scan of the list of current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_MoreCurrent(self, *args)


    def NextCurrent(self, *args) -> "void":
        """
        * Continues the scan to the next object in the list of current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_NextCurrent(self, *args)


    def Current(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        * Returns the current interactive object. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_Current(self, *args)


    def NbCurrents(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_NbCurrents(self, *args)


    def FirstCurrentObject(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        * Returns the first current object in the list of current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_FirstCurrentObject(self, *args)


    def HilightCurrents(self, *args) -> "void":
        """
        * Highlights current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_HilightCurrents(self, *args)


    def UnhilightCurrents(self, *args) -> "void":
        """
        * Removes highlighting from current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UnhilightCurrents(self, *args)


    def ClearCurrents(self, *args) -> "void":
        """
        * Empties previous current objects in order to get the current objects detected by the selector using UpdateCurrent. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ClearCurrents(self, *args)


    def SetSelected(self, *args) -> "void":
        """
        * Puts the interactive object aniObj in the list of selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniObj:
        :type aniObj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetSelected(self, *args)


    def SetSelectedCurrent(self, *args) -> "void":
        """
        * puts the selected list in the current objects List.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetSelectedCurrent(self, *args)


    def UpdateSelected(self, *args) -> "void":
        """
        * updates the list of selected objects i.e. hilights the new selected unhilights old selected objects

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UpdateSelected(self, *args)


    def HilightSelected(self, *args) -> "void":
        """
        * Highlights selected objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_HilightSelected(self, *args)


    def UnhilightSelected(self, *args) -> "void":
        """
        * Removes highlighting from selected objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UnhilightSelected(self, *args)


    def ClearSelected(self, *args) -> "void":
        """
        * Empties previous selected objects in order to get the selected objects detected by the selector using UpdateSelected. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ClearSelected(self, *args)


    def AddOrRemoveSelected(self, *args) -> "void":
        """
        * Allows you to add a selected object to the list of selected objects or remove it from that list. This entity can be an Interactive Object aniobj or its owner aShape as can be seen in the two syntaxes above. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * No right to Add a selected Shape (Internal Management of shape Selection). A Previous selected shape may only be removed.

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * allows to add/remove in the selected list the entities represented by <anOwner> in the selection process.

        :param anOwner:
        :type anOwner: Handle_SelectMgr_EntityOwner &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_AddOrRemoveSelected(self, *args)


    def IsSelected(self, *args) -> "Standard_Boolean":
        """
        * Finds the selected object aniobj in local context and returns its name. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_IsSelected(self, *args)


    def InitSelected(self, *args) -> "void":
        """
        * Initializes a scan of the selected objects in local context. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_InitSelected(self, *args)


    def MoreSelected(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is another object found by the scan of the list of selected objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_MoreSelected(self, *args)


    def NextSelected(self, *args) -> "void":
        """
        * Continues the scan to the next object in the list of selected objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_NextSelected(self, *args)


    def NbSelected(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_NbSelected(self, *args)


    def HasSelectedShape(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the interactive context has a shape selected in it which results from the decomposition of another entity in local context. If HasSelectedShape returns true, SelectedShape returns the shape which has been shown to be selected. Interactive returns the Interactive Object from which the shape has been selected. If HasSelectedShape returns false, Interactive returns the interactive entity selected by the click of the mouse.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_HasSelectedShape(self, *args)


    def SelectedShape(self, *args) -> "TopoDS_Shape":
        """
        * Returns the selected shape in the open local context. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_InteractiveContext_SelectedShape(self, *args)


    def SelectedOwner(self, *args) -> "Handle_SelectMgr_EntityOwner":
        """
        * Returns the owner of the selected entity resulting from the decomposition of another entity in local context.

        :rtype: Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_InteractiveContext_SelectedOwner(self, *args)


    def EntityOwners(self, *args) -> "void":
        """
        * Returns a collection containing all entity owners created for the interactive object <theIObj> in the selection mode theMode (in all active modes if the Mode == -1)

        :param theOwners:
        :type theOwners: SelectMgr_IndexedMapOfOwner &
        :param theIObj:
        :type theIObj: Handle_AIS_InteractiveObject &
        :param theMode: default value is -1
        :type theMode: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_EntityOwners(self, *args)


    def Interactive(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        * Returns the location of the selected Interactive Object.

        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_Interactive(self, *args)


    def SelectedInteractive(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_SelectedInteractive(self, *args)


    def HasApplicative(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the applicative object has an owner from Interactive attributed to it.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_HasApplicative(self, *args)


    def Applicative(self, *args) -> "Handle_Standard_Transient":
        """
        * Returns the owner of the applicative entity detected in interactive context. The owner can be a shape for a set of sub-shapes or a sub-shape for sub-shapes which it is composed of.

        :rtype: Handle_Standard_Transient

        """
        return _AIS.AIS_InteractiveContext_Applicative(self, *args)


    def HasDetected(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is a mouse-detected entity in local context. If there is no open local context, the objects selected are called current objects; selected objects if there is one. Iterators allow entities to be recovered in either case. This method is one of a set which allows you to manipulate the objects which have been placed in these two lists.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_HasDetected(self, *args)


    def HasDetectedShape(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is a detected shape in local context. If there is no open local context, the objects selected are called current objects; selected objects if there is one. Iterators allow entities to be recovered in either case. This method is one of a set which allows you to manipulate the objects which have been placed in these two lists.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_HasDetectedShape(self, *args)


    def DetectedShape(self, *args) -> "TopoDS_Shape const":
        """
        * Returns the shape detected in local context. If there is no open local context, the objects selected are called current objects; selected objects if there is one. Iterators allow entities to be recovered in either case. This method is one of a set which allows you to manipulate the objects which have been placed in these two lists.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_InteractiveContext_DetectedShape(self, *args)


    def DetectedInteractive(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        * Returns the interactive objects last detected in open context. If there is no open local context, the objects selected are called current objects; selected objects if there is one. Iterators allow entities to be recovered in either case. This method is one of a set which allows you to manipulate the objects which have been placed in these two lists.

        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_DetectedInteractive(self, *args)


    def DetectedOwner(self, *args) -> "Handle_SelectMgr_EntityOwner":
        """
        * returns the owner of the detected sensitive primitive.

        :rtype: Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_InteractiveContext_DetectedOwner(self, *args)


    def InitDetected(self, *args) -> "void":
        """
        * Initialization for iteration through mouse-detected objects in interactive context or in local context if it is opened.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_InitDetected(self, *args)


    def MoreDetected(self, *args) -> "Standard_Boolean":
        """
        * returns true if there is more mouse-detected objects after the current one during iteration through mouse-detected interactive objects.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_MoreDetected(self, *args)


    def NextDetected(self, *args) -> "void":
        """
        * Gets next current object during iteration through mouse-detected interactive objects.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_NextDetected(self, *args)


    def DetectedCurrentShape(self, *args) -> "TopoDS_Shape const":
        """
        * returns current mouse-detected shape or empty (null) shape, if current interactive object is not a shape (AIS_Shape) or there is no current mouse-detected interactive object at all.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_InteractiveContext_DetectedCurrentShape(self, *args)


    def DetectedCurrentObject(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_DetectedCurrentObject(self, *args)


    def OpenLocalContext(self, *args) -> "Standard_Integer":
        """
        * Opens local contexts and specifies how this is to be done. The options listed above function in the following manner: - UseDisplayedObjects -allows you to load or not load the interactive objects visualized at Neutral Point in the local context which you open. If false, the local context is empty after being opened. If true, the objects at Neutral Point are loaded by their default selection mode. - AllowShapeDecomposition -AIS_Shape allows or prevents decomposition in standard shape location mode of objects at Neutral Point which are type-'privileged'. This Flag is only taken into account when UseDisplayedObjects is true. - AcceptEraseOfObjects -authorises other local contexts to erase the interactive objects present in this context. This option is rarely used. - BothViewers - Has no use currently defined. This method returns the index of the created local context. It should be kept and used to close the context. Opening a local context allows you to prepare an environment for temporary presentations and selections which will disappear once the local context is closed. You can open several local contexts, but only the last one will be active.

        :param UseDisplayedObjects: default value is Standard_True
        :type UseDisplayedObjects: bool
        :param AllowShapeDecomposition: default value is Standard_True
        :type AllowShapeDecomposition: bool
        :param AcceptEraseOfObjects: default value is Standard_False
        :type AcceptEraseOfObjects: bool
        :param BothViewers: default value is Standard_False
        :type BothViewers: bool
        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_OpenLocalContext(self, *args)


    def CloseLocalContext(self, *args) -> "void":
        """
        * Allows you to close local contexts. For greater security, you should close the context with the index Index given on opening. When you close a local context, the one before, which is still on the stack, reactivates. If none is left, you return to Neutral Point. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated. Warning When the index isn't specified, the current context is closed. This option can be dangerous, as other Interactive Functions can open local contexts without necessarily warning the user.

        :param Index: default value is -1
        :type Index: int
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_CloseLocalContext(self, *args)


    def IndexOfCurrentLocal(self, *args) -> "Standard_Integer":
        """
        * returns -1 if no opened local context.

        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_IndexOfCurrentLocal(self, *args)


    def CloseAllContexts(self, *args) -> "void":
        """
        * Allows you to close all local contexts at one go and return to Neutral Point. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_CloseAllContexts(self, *args)


    def ResetOriginalState(self, *args) -> "void":
        """
        * to be used only with no opened local context.. displays and activates objects in their original state before local contexts were opened...

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ResetOriginalState(self, *args)


    def ClearLocalContext(self, *args) -> "void":
        """
        * clears Objects/Filters/Activated Modes list in the current opened local context.

        :param TheMode: default value is AIS_CM_All
        :type TheMode: AIS_ClearMode
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ClearLocalContext(self, *args)


    def UseDisplayedObjects(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_UseDisplayedObjects(self, *args)


    def NotUseDisplayedObjects(self, *args) -> "void":
        """
        * when a local Context is opened, one is able to use/not use the displayed objects at neutral point at anytime.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_NotUseDisplayedObjects(self, *args)


    def BeginImmediateDraw(self, *args) -> "Standard_Boolean":
        """
        * initializes the list of presentations to be displayed returns False if No Local COnte

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_BeginImmediateDraw(self, *args)


    def ImmediateAdd(self, *args) -> "Standard_Boolean":
        """
        * returns True if <anIObj> has been stored in the list.

        :param theObj:
        :type theObj: Handle_AIS_InteractiveObject &
        :param theMode: default value is 0
        :type theMode: int
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_ImmediateAdd(self, *args)


    def EndImmediateDraw(self, *args) -> "Standard_Boolean":
        """
        * returns True if the immediate display has been done.

        :param theView:
        :type theView: Handle_V3d_View &
        :rtype: bool

        * Uses the First Active View of Main Viewer! returns True if the immediate display has been done.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_EndImmediateDraw(self, *args)


    def IsImmediateModeOn(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_IsImmediateModeOn(self, *args)


    def SetAutomaticHilight(self, *args) -> "void":
        """
        * Sets the highlighting status aStatus of detected and selected entities. Whether you are in Neutral Point or local context, this is automatically managed by the Interactive Context. This function allows you to disconnect the automatic mode.

        :param aStatus:
        :type aStatus: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetAutomaticHilight(self, *args)


    def AutomaticHilight(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the automatic highlight mode is active in an open context.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_AutomaticHilight(self, *args)


    def SetZDetection(self, *args) -> "void":
        """
        * Enables/Disables the Z detection. If True the detection echo can be partially hidden by the detected object.

        :param aStatus: default value is Standard_False
        :type aStatus: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetZDetection(self, *args)


    def ZDetection(self, *args) -> "Standard_Boolean":
        """
        * Retrieves the Z detection state.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_ZDetection(self, *args)


    def Activate(self, *args) -> "void":
        """
        * Activates the selection mode aMode whose index is given, for the given interactive entity anIobj.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :param aMode: default value is 0
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Activate(self, *args)


    def Deactivate(self, *args) -> "void":
        """
        * Deactivates all the activated selection modes of an object.

        :param anIObj:
        :type anIObj: Handle_AIS_InteractiveObject &
        :rtype: None

        * Deactivates all the activated selection modes of the interactive object anIobj with a given selection mode aMode.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_Deactivate(self, *args)


    def ActivatedModes(self, *args) -> "void":
        """
        * Returns the list of activated selection modes in an open context.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :param theList:
        :type theList: TColStd_ListOfInteger &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ActivatedModes(self, *args)


    def SetShapeDecomposition(self, *args) -> "void":
        """
        * to be Used only with opened local context and if <anIobj> is of type shape... if <aStatus> = True <anIobj> will be sensitive to shape selection modes activation. = False, <anIobj> will not be senstive any more.

        :param anIobj:
        :type anIobj: Handle_AIS_InteractiveObject &
        :param aStatus:
        :type aStatus: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetShapeDecomposition(self, *args)


    def SetTemporaryAttributes(self, *args) -> "void":
        """
        * Sets the temporary graphic attributes of the entity anObj. These are provided by the attribute manager aDrawer and are valid for a particular local context only. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param anObj:
        :type anObj: Handle_AIS_InteractiveObject &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SetTemporaryAttributes(self, *args)


    def SubIntensityOn(self, *args) -> "void":
        """
        * Highlights, and removes highlights from, the displayed object aniobj which is displayed at Neutral Point with subintensity color; available only for active local context. There is no effect if there is no local context. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * hilights/unhilights displayed objects which are displayed at neutral state with subintensity color; available only for active local context. No effect if no local context.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args) -> "void":
        """
        * Removes the subintensity option for the entity aniobj. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.

        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * removes subintensity option for all objects.

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_SubIntensityOff(self, *args)


    def AddFilter(self, *args) -> "void":
        """
        * Allows you to add the filter aFilter to Neutral Point or to a local context if one or more selection modes have been activated. Only type filters may be active in Neutral Point.

        :param aFilter:
        :type aFilter: Handle_SelectMgr_Filter &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_AddFilter(self, *args)


    def RemoveFilter(self, *args) -> "void":
        """
        * Removes a filter from Neutral Point or a local context if one or more selection modes have been activated. Only type filters are activated in Neutral Point.

        :param aFilter:
        :type aFilter: Handle_SelectMgr_Filter &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_RemoveFilter(self, *args)


    def RemoveFilters(self, *args) -> "void":
        """
        * Remove a filter to Neutral Point or a local context if one or more selection modes have been activated. Only type filters are active in Neutral Point.

        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_RemoveFilters(self, *args)


    def ActivateStandardMode(self, *args) -> "void":
        """
        * Provides an alternative to the Display methods when activating specific selection modes. This has the effect of activating the corresponding selection mode aStandardActivation for all objects in Local Context which accept decomposition into sub-shapes. Every new Object which has been loaded into the interactive context and which answers these decomposition criteria is automatically activated according to these modes. Warning If you have opened a local context by loading an object with the default options (<AllowShapeDecomposition >= Standard_True), all objects of the 'Shape' type are also activated with the same modes. You can act on the state of these 'Standard' objects by using SetShapeDecomposition(Status).

        :param aStandardActivation:
        :type aStandardActivation: TopAbs_ShapeEnum
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ActivateStandardMode(self, *args)


    def DeactivateStandardMode(self, *args) -> "void":
        """
        * Provides an alternative to the Display methods when deactivating specific selection modes. This has the effect of deactivating the corresponding selection mode aStandardActivation for all objects in Local Context which accept decomposition into sub-shapes.

        :param aStandardActivation:
        :type aStandardActivation: TopAbs_ShapeEnum
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_DeactivateStandardMode(self, *args)


    def ActivatedStandardModes(self, *args) -> "TColStd_ListOfInteger const &":
        """
        * Returns the list of activated standard selection modes available in a local context.

        :rtype: TColStd_ListOfInteger

        """
        return _AIS.AIS_InteractiveContext_ActivatedStandardModes(self, *args)


    def Filters(self, *args) -> "SelectMgr_ListOfFilter const &":
        """
        * Returns the list of filters active in a local context.

        :rtype: SelectMgr_ListOfFilter

        """
        return _AIS.AIS_InteractiveContext_Filters(self, *args)


    def DefaultDrawer(self, *args) -> "Handle_Prs3d_Drawer":
        """
        * Returns the default attribute manager. This contains all the color and line attributes which can be used by interactive objects which do not have their own attributes.

        :rtype: Handle_Prs3d_Drawer

        """
        return _AIS.AIS_InteractiveContext_DefaultDrawer(self, *args)


    def CurrentViewer(self, *args) -> "Handle_V3d_Viewer":
        """
        * Returns the current viewer.

        :rtype: Handle_V3d_Viewer

        """
        return _AIS.AIS_InteractiveContext_CurrentViewer(self, *args)


    def DisplayedObjects(self, *args) -> "void":
        """
        * Returns the list of displayed objects of a particular Type WhichKind and Signature WhichSignature. By Default, WhichSignature equals -1. This means that there is a check on type only.

        :param aListOfIO:
        :type aListOfIO: AIS_ListOfInteractive &
        :param OnlyFromNeutral: default value is Standard_False
        :type OnlyFromNeutral: bool
        :rtype: None

        * gives the list of displayed objects of a particular Type and signature. by Default, <WhichSignature> = -1 means control only on <WhichKind>.

        :param WhichKind:
        :type WhichKind: AIS_KindOfInteractive
        :param WhichSignature:
        :type WhichSignature: int
        :param aListOfIO:
        :type aListOfIO: AIS_ListOfInteractive &
        :param OnlyFromNeutral: default value is Standard_False
        :type OnlyFromNeutral: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_DisplayedObjects(self, *args)


    def ErasedObjects(self, *args) -> "void":
        """
        * Returns the list theListOfIO of erased objects (hidden objects) particular Type WhichKind and Signature WhichSignature. By Default, WhichSignature equals 1. This means that there is a check on type only.

        :param theListOfIO:
        :type theListOfIO: AIS_ListOfInteractive &
        :rtype: None

        * gives the list of erased objects (hidden objects) Type and signature by Default, <WhichSignature> = -1 means control only on <WhichKind>.

        :param WhichKind:
        :type WhichKind: AIS_KindOfInteractive
        :param WhichSignature:
        :type WhichSignature: int
        :param theListOfIO:
        :type theListOfIO: AIS_ListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ErasedObjects(self, *args)


    def ObjectsByDisplayStatus(self, *args) -> "void":
        """
        * Returns the list theListOfIO of objects with indicated display status particular Type WhichKind and Signature WhichSignature. By Default, WhichSignature equals 1. This means that there is a check on type only.

        :param theStatus:
        :type theStatus: AIS_DisplayStatus
        :param theListOfIO:
        :type theListOfIO: AIS_ListOfInteractive &
        :rtype: None

        * gives the list of objects with indicated display status Type and signature by Default, <WhichSignature> = -1 means control only on <WhichKind>.

        :param WhichKind:
        :type WhichKind: AIS_KindOfInteractive
        :param WhichSignature:
        :type WhichSignature: int
        :param theStatus:
        :type theStatus: AIS_DisplayStatus
        :param theListOfIO:
        :type theListOfIO: AIS_ListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ObjectsByDisplayStatus(self, *args)


    def ObjectsInside(self, *args) -> "void":
        """
        * fills <aListOfIO> with objects of a particular Type and Signature with no consideration of display status. by Default, <WhichSignature> = -1 means control only on <WhichKind>. if <WhichKind> = AIS_KOI_None and <WhichSignature> = -1, all the objects are put into the list.

        :param aListOfIO:
        :type aListOfIO: AIS_ListOfInteractive &
        :param WhichKind: default value is AIS_KOI_None
        :type WhichKind: AIS_KindOfInteractive
        :param WhichSignature: default value is -1
        :type WhichSignature: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ObjectsInside(self, *args)


    def HasOpenedContext(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is an open context.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_HasOpenedContext(self, *args)


    def CurrentName(self, *args) -> "TCollection_AsciiString const &":
        """
        * Returns the name of the current selected entity in Neutral Point. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: TCollection_AsciiString

        """
        return _AIS.AIS_InteractiveContext_CurrentName(self, *args)


    def SelectionName(self, *args) -> "TCollection_AsciiString const &":
        """
        * Returns the name of the current selected entity in open local context. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: TCollection_AsciiString

        """
        return _AIS.AIS_InteractiveContext_SelectionName(self, *args)


    def DomainOfMainViewer(self, *args) -> "char const *":
        """
        * Returns the domain name of the main viewer.

        :rtype: char *

        """
        return _AIS.AIS_InteractiveContext_DomainOfMainViewer(self, *args)


    def LocalContext(self, *args) -> "Handle_AIS_LocalContext":
        """
        * This method is only intended for advanced operation, particularly with the aim to improve performance when many objects have to be selected together. Otherwise, you should use other (non-internal) methods of class AIS_InteractiveContext without trying to obtain an instance of AIS_LocalContext.

        :rtype: Handle_AIS_LocalContext

        """
        return _AIS.AIS_InteractiveContext_LocalContext(self, *args)


    def SelectionManager(self, *args) -> "Handle_SelectMgr_SelectionManager":
        """
        :rtype: Handle_SelectMgr_SelectionManager

        """
        return _AIS.AIS_InteractiveContext_SelectionManager(self, *args)


    def MainPrsMgr(self, *args) -> "Handle_PrsMgr_PresentationManager3d":
        """
        :rtype: Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.AIS_InteractiveContext_MainPrsMgr(self, *args)


    def MainSelector(self, *args) -> "Handle_StdSelect_ViewerSelector3d":
        """
        :rtype: Handle_StdSelect_ViewerSelector3d

        """
        return _AIS.AIS_InteractiveContext_MainSelector(self, *args)


    def LocalSelector(self, *args) -> "Handle_StdSelect_ViewerSelector3d":
        """
        :rtype: Handle_StdSelect_ViewerSelector3d

        """
        return _AIS.AIS_InteractiveContext_LocalSelector(self, *args)


    def PurgeDisplay(self, *args) -> "Standard_Integer":
        """
        * Clears all the structures which don't belong to objects displayed at neutral point only effective when no Local Context is opened... returns the number of removed structures from the viewers.

        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_PurgeDisplay(self, *args)


    def HighestIndex(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _AIS.AIS_InteractiveContext_HighestIndex(self, *args)


    def ClearActiveAreas(self, *args) -> "void":
        """
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ClearActiveAreas(self, *args)


    def ClearActiveSensitive(self, *args) -> "void":
        """
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_ClearActiveSensitive(self, *args)


    def DisplayActiveSensitive(self, *args) -> "void":
        """
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_DisplayActiveSensitive(self, *args)


    def DisplayActiveAreas(self, *args) -> "void":
        """
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        return _AIS.AIS_InteractiveContext_DisplayActiveAreas(self, *args)


    def IsInLocal(self, *args) -> "Standard_Boolean":
        """
        * returns if possible, the first local context where the object is seen

        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :param TheIndex:
        :type TheIndex: int &
        :rtype: bool

        """
        return _AIS.AIS_InteractiveContext_IsInLocal(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_InteractiveContext(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_InteractiveContext
AIS_InteractiveContext.SetAutoActivateSelection = new_instancemethod(_AIS.AIS_InteractiveContext_SetAutoActivateSelection, None, AIS_InteractiveContext)
AIS_InteractiveContext.GetAutoActivateSelection = new_instancemethod(_AIS.AIS_InteractiveContext_GetAutoActivateSelection, None, AIS_InteractiveContext)
AIS_InteractiveContext.Display = new_instancemethod(_AIS.AIS_InteractiveContext_Display, None, AIS_InteractiveContext)
AIS_InteractiveContext.Load = new_instancemethod(_AIS.AIS_InteractiveContext_Load, None, AIS_InteractiveContext)
AIS_InteractiveContext.Erase = new_instancemethod(_AIS.AIS_InteractiveContext_Erase, None, AIS_InteractiveContext)
AIS_InteractiveContext.EraseAll = new_instancemethod(_AIS.AIS_InteractiveContext_EraseAll, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisplayAll = new_instancemethod(_AIS.AIS_InteractiveContext_DisplayAll, None, AIS_InteractiveContext)
AIS_InteractiveContext.EraseSelected = new_instancemethod(_AIS.AIS_InteractiveContext_EraseSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisplaySelected = new_instancemethod(_AIS.AIS_InteractiveContext_DisplaySelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.KeepTemporary = new_instancemethod(_AIS.AIS_InteractiveContext_KeepTemporary, None, AIS_InteractiveContext)
AIS_InteractiveContext.Clear = new_instancemethod(_AIS.AIS_InteractiveContext_Clear, None, AIS_InteractiveContext)
AIS_InteractiveContext.ClearPrs = new_instancemethod(_AIS.AIS_InteractiveContext_ClearPrs, None, AIS_InteractiveContext)
AIS_InteractiveContext.Remove = new_instancemethod(_AIS.AIS_InteractiveContext_Remove, None, AIS_InteractiveContext)
AIS_InteractiveContext.RemoveAll = new_instancemethod(_AIS.AIS_InteractiveContext_RemoveAll, None, AIS_InteractiveContext)
AIS_InteractiveContext.Hilight = new_instancemethod(_AIS.AIS_InteractiveContext_Hilight, None, AIS_InteractiveContext)
AIS_InteractiveContext.HilightWithColor = new_instancemethod(_AIS.AIS_InteractiveContext_HilightWithColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.Unhilight = new_instancemethod(_AIS.AIS_InteractiveContext_Unhilight, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetDisplayPriority = new_instancemethod(_AIS.AIS_InteractiveContext_SetDisplayPriority, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetZLayer = new_instancemethod(_AIS.AIS_InteractiveContext_SetZLayer, None, AIS_InteractiveContext)
AIS_InteractiveContext.GetZLayer = new_instancemethod(_AIS.AIS_InteractiveContext_GetZLayer, None, AIS_InteractiveContext)
AIS_InteractiveContext.Redisplay = new_instancemethod(_AIS.AIS_InteractiveContext_Redisplay, None, AIS_InteractiveContext)
AIS_InteractiveContext.RecomputePrsOnly = new_instancemethod(_AIS.AIS_InteractiveContext_RecomputePrsOnly, None, AIS_InteractiveContext)
AIS_InteractiveContext.RecomputeSelectionOnly = new_instancemethod(_AIS.AIS_InteractiveContext_RecomputeSelectionOnly, None, AIS_InteractiveContext)
AIS_InteractiveContext.Update = new_instancemethod(_AIS.AIS_InteractiveContext_Update, None, AIS_InteractiveContext)
AIS_InteractiveContext.UnsetDisplayMode = new_instancemethod(_AIS.AIS_InteractiveContext_UnsetDisplayMode, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetSelectionMode = new_instancemethod(_AIS.AIS_InteractiveContext_SetSelectionMode, None, AIS_InteractiveContext)
AIS_InteractiveContext.UnsetSelectionMode = new_instancemethod(_AIS.AIS_InteractiveContext_UnsetSelectionMode, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetSensitivityMode = new_instancemethod(_AIS.AIS_InteractiveContext_SetSensitivityMode, None, AIS_InteractiveContext)
AIS_InteractiveContext.SensitivityMode = new_instancemethod(_AIS.AIS_InteractiveContext_SensitivityMode, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetSensitivity = new_instancemethod(_AIS.AIS_InteractiveContext_SetSensitivity, None, AIS_InteractiveContext)
AIS_InteractiveContext.Sensitivity = new_instancemethod(_AIS.AIS_InteractiveContext_Sensitivity, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetPixelTolerance = new_instancemethod(_AIS.AIS_InteractiveContext_SetPixelTolerance, None, AIS_InteractiveContext)
AIS_InteractiveContext.PixelTolerance = new_instancemethod(_AIS.AIS_InteractiveContext_PixelTolerance, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetLocation = new_instancemethod(_AIS.AIS_InteractiveContext_SetLocation, None, AIS_InteractiveContext)
AIS_InteractiveContext.ResetLocation = new_instancemethod(_AIS.AIS_InteractiveContext_ResetLocation, None, AIS_InteractiveContext)
AIS_InteractiveContext.HasLocation = new_instancemethod(_AIS.AIS_InteractiveContext_HasLocation, None, AIS_InteractiveContext)
AIS_InteractiveContext.Location = new_instancemethod(_AIS.AIS_InteractiveContext_Location, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetCurrentFacingModel = new_instancemethod(_AIS.AIS_InteractiveContext_SetCurrentFacingModel, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetColor = new_instancemethod(_AIS.AIS_InteractiveContext_SetColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.UnsetColor = new_instancemethod(_AIS.AIS_InteractiveContext_UnsetColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetWidth = new_instancemethod(_AIS.AIS_InteractiveContext_SetWidth, None, AIS_InteractiveContext)
AIS_InteractiveContext.UnsetWidth = new_instancemethod(_AIS.AIS_InteractiveContext_UnsetWidth, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetMaterial = new_instancemethod(_AIS.AIS_InteractiveContext_SetMaterial, None, AIS_InteractiveContext)
AIS_InteractiveContext.UnsetMaterial = new_instancemethod(_AIS.AIS_InteractiveContext_UnsetMaterial, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetTransparency = new_instancemethod(_AIS.AIS_InteractiveContext_SetTransparency, None, AIS_InteractiveContext)
AIS_InteractiveContext.UnsetTransparency = new_instancemethod(_AIS.AIS_InteractiveContext_UnsetTransparency, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetLocalAttributes = new_instancemethod(_AIS.AIS_InteractiveContext_SetLocalAttributes, None, AIS_InteractiveContext)
AIS_InteractiveContext.UnsetLocalAttributes = new_instancemethod(_AIS.AIS_InteractiveContext_UnsetLocalAttributes, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetPolygonOffsets = new_instancemethod(_AIS.AIS_InteractiveContext_SetPolygonOffsets, None, AIS_InteractiveContext)
AIS_InteractiveContext.HasPolygonOffsets = new_instancemethod(_AIS.AIS_InteractiveContext_HasPolygonOffsets, None, AIS_InteractiveContext)
AIS_InteractiveContext.PolygonOffsets = new_instancemethod(_AIS.AIS_InteractiveContext_PolygonOffsets, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetTrihedronSize = new_instancemethod(_AIS.AIS_InteractiveContext_SetTrihedronSize, None, AIS_InteractiveContext)
AIS_InteractiveContext.TrihedronSize = new_instancemethod(_AIS.AIS_InteractiveContext_TrihedronSize, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetPlaneSize = new_instancemethod(_AIS.AIS_InteractiveContext_SetPlaneSize, None, AIS_InteractiveContext)
AIS_InteractiveContext.PlaneSize = new_instancemethod(_AIS.AIS_InteractiveContext_PlaneSize, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisplayStatus = new_instancemethod(_AIS.AIS_InteractiveContext_DisplayStatus, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisplayedModes = new_instancemethod(_AIS.AIS_InteractiveContext_DisplayedModes, None, AIS_InteractiveContext)
AIS_InteractiveContext.IsDisplayed = new_instancemethod(_AIS.AIS_InteractiveContext_IsDisplayed, None, AIS_InteractiveContext)
AIS_InteractiveContext.IsHilighted = new_instancemethod(_AIS.AIS_InteractiveContext_IsHilighted, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisplayPriority = new_instancemethod(_AIS.AIS_InteractiveContext_DisplayPriority, None, AIS_InteractiveContext)
AIS_InteractiveContext.HasColor = new_instancemethod(_AIS.AIS_InteractiveContext_HasColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.Color = new_instancemethod(_AIS.AIS_InteractiveContext_Color, None, AIS_InteractiveContext)
AIS_InteractiveContext.Width = new_instancemethod(_AIS.AIS_InteractiveContext_Width, None, AIS_InteractiveContext)
AIS_InteractiveContext.Status = new_instancemethod(_AIS.AIS_InteractiveContext_Status, None, AIS_InteractiveContext)
AIS_InteractiveContext.UpdateCurrentViewer = new_instancemethod(_AIS.AIS_InteractiveContext_UpdateCurrentViewer, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisplayMode = new_instancemethod(_AIS.AIS_InteractiveContext_DisplayMode, None, AIS_InteractiveContext)
AIS_InteractiveContext.HilightColor = new_instancemethod(_AIS.AIS_InteractiveContext_HilightColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.PreSelectionColor = new_instancemethod(_AIS.AIS_InteractiveContext_PreSelectionColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.DefaultColor = new_instancemethod(_AIS.AIS_InteractiveContext_DefaultColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.SubIntensityColor = new_instancemethod(_AIS.AIS_InteractiveContext_SubIntensityColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetHilightColor = new_instancemethod(_AIS.AIS_InteractiveContext_SetHilightColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.SelectionColor = new_instancemethod(_AIS.AIS_InteractiveContext_SelectionColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetPreselectionColor = new_instancemethod(_AIS.AIS_InteractiveContext_SetPreselectionColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetSubIntensityColor = new_instancemethod(_AIS.AIS_InteractiveContext_SetSubIntensityColor, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetDisplayMode = new_instancemethod(_AIS.AIS_InteractiveContext_SetDisplayMode, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetAngleAndDeviation = new_instancemethod(_AIS.AIS_InteractiveContext_SetAngleAndDeviation, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetHLRDeviationAngle = new_instancemethod(_AIS.AIS_InteractiveContext_SetHLRDeviationAngle, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetDeviationCoefficient = new_instancemethod(_AIS.AIS_InteractiveContext_SetDeviationCoefficient, None, AIS_InteractiveContext)
AIS_InteractiveContext.DeviationCoefficient = new_instancemethod(_AIS.AIS_InteractiveContext_DeviationCoefficient, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetDeviationAngle = new_instancemethod(_AIS.AIS_InteractiveContext_SetDeviationAngle, None, AIS_InteractiveContext)
AIS_InteractiveContext.DeviationAngle = new_instancemethod(_AIS.AIS_InteractiveContext_DeviationAngle, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetHLRDeviationCoefficient = new_instancemethod(_AIS.AIS_InteractiveContext_SetHLRDeviationCoefficient, None, AIS_InteractiveContext)
AIS_InteractiveContext.HLRDeviationCoefficient = new_instancemethod(_AIS.AIS_InteractiveContext_HLRDeviationCoefficient, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetHLRAngle = new_instancemethod(_AIS.AIS_InteractiveContext_SetHLRAngle, None, AIS_InteractiveContext)
AIS_InteractiveContext.HLRAngle = new_instancemethod(_AIS.AIS_InteractiveContext_HLRAngle, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetHLRAngleAndDeviation = new_instancemethod(_AIS.AIS_InteractiveContext_SetHLRAngleAndDeviation, None, AIS_InteractiveContext)
AIS_InteractiveContext.HiddenLineAspect = new_instancemethod(_AIS.AIS_InteractiveContext_HiddenLineAspect, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetHiddenLineAspect = new_instancemethod(_AIS.AIS_InteractiveContext_SetHiddenLineAspect, None, AIS_InteractiveContext)
AIS_InteractiveContext.DrawHiddenLine = new_instancemethod(_AIS.AIS_InteractiveContext_DrawHiddenLine, None, AIS_InteractiveContext)
AIS_InteractiveContext.EnableDrawHiddenLine = new_instancemethod(_AIS.AIS_InteractiveContext_EnableDrawHiddenLine, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisableDrawHiddenLine = new_instancemethod(_AIS.AIS_InteractiveContext_DisableDrawHiddenLine, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetIsoNumber = new_instancemethod(_AIS.AIS_InteractiveContext_SetIsoNumber, None, AIS_InteractiveContext)
AIS_InteractiveContext.IsoNumber = new_instancemethod(_AIS.AIS_InteractiveContext_IsoNumber, None, AIS_InteractiveContext)
AIS_InteractiveContext.IsoOnPlane = new_instancemethod(_AIS.AIS_InteractiveContext_IsoOnPlane, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetSelectedAspect = new_instancemethod(_AIS.AIS_InteractiveContext_SetSelectedAspect, None, AIS_InteractiveContext)
AIS_InteractiveContext.MoveTo = new_instancemethod(_AIS.AIS_InteractiveContext_MoveTo, None, AIS_InteractiveContext)
AIS_InteractiveContext.HasNextDetected = new_instancemethod(_AIS.AIS_InteractiveContext_HasNextDetected, None, AIS_InteractiveContext)
AIS_InteractiveContext.HilightNextDetected = new_instancemethod(_AIS.AIS_InteractiveContext_HilightNextDetected, None, AIS_InteractiveContext)
AIS_InteractiveContext.HilightPreviousDetected = new_instancemethod(_AIS.AIS_InteractiveContext_HilightPreviousDetected, None, AIS_InteractiveContext)
AIS_InteractiveContext.Select = new_instancemethod(_AIS.AIS_InteractiveContext_Select, None, AIS_InteractiveContext)
AIS_InteractiveContext.ShiftSelect = new_instancemethod(_AIS.AIS_InteractiveContext_ShiftSelect, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetToHilightSelected = new_instancemethod(_AIS.AIS_InteractiveContext_SetToHilightSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.ToHilightSelected = new_instancemethod(_AIS.AIS_InteractiveContext_ToHilightSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetCurrentObject = new_instancemethod(_AIS.AIS_InteractiveContext_SetCurrentObject, None, AIS_InteractiveContext)
AIS_InteractiveContext.AddOrRemoveCurrentObject = new_instancemethod(_AIS.AIS_InteractiveContext_AddOrRemoveCurrentObject, None, AIS_InteractiveContext)
AIS_InteractiveContext.UpdateCurrent = new_instancemethod(_AIS.AIS_InteractiveContext_UpdateCurrent, None, AIS_InteractiveContext)
AIS_InteractiveContext.WasCurrentTouched = new_instancemethod(_AIS.AIS_InteractiveContext_WasCurrentTouched, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetOkCurrent = new_instancemethod(_AIS.AIS_InteractiveContext_SetOkCurrent, None, AIS_InteractiveContext)
AIS_InteractiveContext.IsCurrent = new_instancemethod(_AIS.AIS_InteractiveContext_IsCurrent, None, AIS_InteractiveContext)
AIS_InteractiveContext.InitCurrent = new_instancemethod(_AIS.AIS_InteractiveContext_InitCurrent, None, AIS_InteractiveContext)
AIS_InteractiveContext.MoreCurrent = new_instancemethod(_AIS.AIS_InteractiveContext_MoreCurrent, None, AIS_InteractiveContext)
AIS_InteractiveContext.NextCurrent = new_instancemethod(_AIS.AIS_InteractiveContext_NextCurrent, None, AIS_InteractiveContext)
AIS_InteractiveContext.Current = new_instancemethod(_AIS.AIS_InteractiveContext_Current, None, AIS_InteractiveContext)
AIS_InteractiveContext.NbCurrents = new_instancemethod(_AIS.AIS_InteractiveContext_NbCurrents, None, AIS_InteractiveContext)
AIS_InteractiveContext.FirstCurrentObject = new_instancemethod(_AIS.AIS_InteractiveContext_FirstCurrentObject, None, AIS_InteractiveContext)
AIS_InteractiveContext.HilightCurrents = new_instancemethod(_AIS.AIS_InteractiveContext_HilightCurrents, None, AIS_InteractiveContext)
AIS_InteractiveContext.UnhilightCurrents = new_instancemethod(_AIS.AIS_InteractiveContext_UnhilightCurrents, None, AIS_InteractiveContext)
AIS_InteractiveContext.ClearCurrents = new_instancemethod(_AIS.AIS_InteractiveContext_ClearCurrents, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetSelected = new_instancemethod(_AIS.AIS_InteractiveContext_SetSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetSelectedCurrent = new_instancemethod(_AIS.AIS_InteractiveContext_SetSelectedCurrent, None, AIS_InteractiveContext)
AIS_InteractiveContext.UpdateSelected = new_instancemethod(_AIS.AIS_InteractiveContext_UpdateSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.HilightSelected = new_instancemethod(_AIS.AIS_InteractiveContext_HilightSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.UnhilightSelected = new_instancemethod(_AIS.AIS_InteractiveContext_UnhilightSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.ClearSelected = new_instancemethod(_AIS.AIS_InteractiveContext_ClearSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.AddOrRemoveSelected = new_instancemethod(_AIS.AIS_InteractiveContext_AddOrRemoveSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.IsSelected = new_instancemethod(_AIS.AIS_InteractiveContext_IsSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.InitSelected = new_instancemethod(_AIS.AIS_InteractiveContext_InitSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.MoreSelected = new_instancemethod(_AIS.AIS_InteractiveContext_MoreSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.NextSelected = new_instancemethod(_AIS.AIS_InteractiveContext_NextSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.NbSelected = new_instancemethod(_AIS.AIS_InteractiveContext_NbSelected, None, AIS_InteractiveContext)
AIS_InteractiveContext.HasSelectedShape = new_instancemethod(_AIS.AIS_InteractiveContext_HasSelectedShape, None, AIS_InteractiveContext)
AIS_InteractiveContext.SelectedShape = new_instancemethod(_AIS.AIS_InteractiveContext_SelectedShape, None, AIS_InteractiveContext)
AIS_InteractiveContext.SelectedOwner = new_instancemethod(_AIS.AIS_InteractiveContext_SelectedOwner, None, AIS_InteractiveContext)
AIS_InteractiveContext.EntityOwners = new_instancemethod(_AIS.AIS_InteractiveContext_EntityOwners, None, AIS_InteractiveContext)
AIS_InteractiveContext.Interactive = new_instancemethod(_AIS.AIS_InteractiveContext_Interactive, None, AIS_InteractiveContext)
AIS_InteractiveContext.SelectedInteractive = new_instancemethod(_AIS.AIS_InteractiveContext_SelectedInteractive, None, AIS_InteractiveContext)
AIS_InteractiveContext.HasApplicative = new_instancemethod(_AIS.AIS_InteractiveContext_HasApplicative, None, AIS_InteractiveContext)
AIS_InteractiveContext.Applicative = new_instancemethod(_AIS.AIS_InteractiveContext_Applicative, None, AIS_InteractiveContext)
AIS_InteractiveContext.HasDetected = new_instancemethod(_AIS.AIS_InteractiveContext_HasDetected, None, AIS_InteractiveContext)
AIS_InteractiveContext.HasDetectedShape = new_instancemethod(_AIS.AIS_InteractiveContext_HasDetectedShape, None, AIS_InteractiveContext)
AIS_InteractiveContext.DetectedShape = new_instancemethod(_AIS.AIS_InteractiveContext_DetectedShape, None, AIS_InteractiveContext)
AIS_InteractiveContext.DetectedInteractive = new_instancemethod(_AIS.AIS_InteractiveContext_DetectedInteractive, None, AIS_InteractiveContext)
AIS_InteractiveContext.DetectedOwner = new_instancemethod(_AIS.AIS_InteractiveContext_DetectedOwner, None, AIS_InteractiveContext)
AIS_InteractiveContext.InitDetected = new_instancemethod(_AIS.AIS_InteractiveContext_InitDetected, None, AIS_InteractiveContext)
AIS_InteractiveContext.MoreDetected = new_instancemethod(_AIS.AIS_InteractiveContext_MoreDetected, None, AIS_InteractiveContext)
AIS_InteractiveContext.NextDetected = new_instancemethod(_AIS.AIS_InteractiveContext_NextDetected, None, AIS_InteractiveContext)
AIS_InteractiveContext.DetectedCurrentShape = new_instancemethod(_AIS.AIS_InteractiveContext_DetectedCurrentShape, None, AIS_InteractiveContext)
AIS_InteractiveContext.DetectedCurrentObject = new_instancemethod(_AIS.AIS_InteractiveContext_DetectedCurrentObject, None, AIS_InteractiveContext)
AIS_InteractiveContext.OpenLocalContext = new_instancemethod(_AIS.AIS_InteractiveContext_OpenLocalContext, None, AIS_InteractiveContext)
AIS_InteractiveContext.CloseLocalContext = new_instancemethod(_AIS.AIS_InteractiveContext_CloseLocalContext, None, AIS_InteractiveContext)
AIS_InteractiveContext.IndexOfCurrentLocal = new_instancemethod(_AIS.AIS_InteractiveContext_IndexOfCurrentLocal, None, AIS_InteractiveContext)
AIS_InteractiveContext.CloseAllContexts = new_instancemethod(_AIS.AIS_InteractiveContext_CloseAllContexts, None, AIS_InteractiveContext)
AIS_InteractiveContext.ResetOriginalState = new_instancemethod(_AIS.AIS_InteractiveContext_ResetOriginalState, None, AIS_InteractiveContext)
AIS_InteractiveContext.ClearLocalContext = new_instancemethod(_AIS.AIS_InteractiveContext_ClearLocalContext, None, AIS_InteractiveContext)
AIS_InteractiveContext.UseDisplayedObjects = new_instancemethod(_AIS.AIS_InteractiveContext_UseDisplayedObjects, None, AIS_InteractiveContext)
AIS_InteractiveContext.NotUseDisplayedObjects = new_instancemethod(_AIS.AIS_InteractiveContext_NotUseDisplayedObjects, None, AIS_InteractiveContext)
AIS_InteractiveContext.BeginImmediateDraw = new_instancemethod(_AIS.AIS_InteractiveContext_BeginImmediateDraw, None, AIS_InteractiveContext)
AIS_InteractiveContext.ImmediateAdd = new_instancemethod(_AIS.AIS_InteractiveContext_ImmediateAdd, None, AIS_InteractiveContext)
AIS_InteractiveContext.EndImmediateDraw = new_instancemethod(_AIS.AIS_InteractiveContext_EndImmediateDraw, None, AIS_InteractiveContext)
AIS_InteractiveContext.IsImmediateModeOn = new_instancemethod(_AIS.AIS_InteractiveContext_IsImmediateModeOn, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetAutomaticHilight = new_instancemethod(_AIS.AIS_InteractiveContext_SetAutomaticHilight, None, AIS_InteractiveContext)
AIS_InteractiveContext.AutomaticHilight = new_instancemethod(_AIS.AIS_InteractiveContext_AutomaticHilight, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetZDetection = new_instancemethod(_AIS.AIS_InteractiveContext_SetZDetection, None, AIS_InteractiveContext)
AIS_InteractiveContext.ZDetection = new_instancemethod(_AIS.AIS_InteractiveContext_ZDetection, None, AIS_InteractiveContext)
AIS_InteractiveContext.Activate = new_instancemethod(_AIS.AIS_InteractiveContext_Activate, None, AIS_InteractiveContext)
AIS_InteractiveContext.Deactivate = new_instancemethod(_AIS.AIS_InteractiveContext_Deactivate, None, AIS_InteractiveContext)
AIS_InteractiveContext.ActivatedModes = new_instancemethod(_AIS.AIS_InteractiveContext_ActivatedModes, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetShapeDecomposition = new_instancemethod(_AIS.AIS_InteractiveContext_SetShapeDecomposition, None, AIS_InteractiveContext)
AIS_InteractiveContext.SetTemporaryAttributes = new_instancemethod(_AIS.AIS_InteractiveContext_SetTemporaryAttributes, None, AIS_InteractiveContext)
AIS_InteractiveContext.SubIntensityOn = new_instancemethod(_AIS.AIS_InteractiveContext_SubIntensityOn, None, AIS_InteractiveContext)
AIS_InteractiveContext.SubIntensityOff = new_instancemethod(_AIS.AIS_InteractiveContext_SubIntensityOff, None, AIS_InteractiveContext)
AIS_InteractiveContext.AddFilter = new_instancemethod(_AIS.AIS_InteractiveContext_AddFilter, None, AIS_InteractiveContext)
AIS_InteractiveContext.RemoveFilter = new_instancemethod(_AIS.AIS_InteractiveContext_RemoveFilter, None, AIS_InteractiveContext)
AIS_InteractiveContext.RemoveFilters = new_instancemethod(_AIS.AIS_InteractiveContext_RemoveFilters, None, AIS_InteractiveContext)
AIS_InteractiveContext.ActivateStandardMode = new_instancemethod(_AIS.AIS_InteractiveContext_ActivateStandardMode, None, AIS_InteractiveContext)
AIS_InteractiveContext.DeactivateStandardMode = new_instancemethod(_AIS.AIS_InteractiveContext_DeactivateStandardMode, None, AIS_InteractiveContext)
AIS_InteractiveContext.ActivatedStandardModes = new_instancemethod(_AIS.AIS_InteractiveContext_ActivatedStandardModes, None, AIS_InteractiveContext)
AIS_InteractiveContext.Filters = new_instancemethod(_AIS.AIS_InteractiveContext_Filters, None, AIS_InteractiveContext)
AIS_InteractiveContext.DefaultDrawer = new_instancemethod(_AIS.AIS_InteractiveContext_DefaultDrawer, None, AIS_InteractiveContext)
AIS_InteractiveContext.CurrentViewer = new_instancemethod(_AIS.AIS_InteractiveContext_CurrentViewer, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisplayedObjects = new_instancemethod(_AIS.AIS_InteractiveContext_DisplayedObjects, None, AIS_InteractiveContext)
AIS_InteractiveContext.ErasedObjects = new_instancemethod(_AIS.AIS_InteractiveContext_ErasedObjects, None, AIS_InteractiveContext)
AIS_InteractiveContext.ObjectsByDisplayStatus = new_instancemethod(_AIS.AIS_InteractiveContext_ObjectsByDisplayStatus, None, AIS_InteractiveContext)
AIS_InteractiveContext.ObjectsInside = new_instancemethod(_AIS.AIS_InteractiveContext_ObjectsInside, None, AIS_InteractiveContext)
AIS_InteractiveContext.HasOpenedContext = new_instancemethod(_AIS.AIS_InteractiveContext_HasOpenedContext, None, AIS_InteractiveContext)
AIS_InteractiveContext.CurrentName = new_instancemethod(_AIS.AIS_InteractiveContext_CurrentName, None, AIS_InteractiveContext)
AIS_InteractiveContext.SelectionName = new_instancemethod(_AIS.AIS_InteractiveContext_SelectionName, None, AIS_InteractiveContext)
AIS_InteractiveContext.DomainOfMainViewer = new_instancemethod(_AIS.AIS_InteractiveContext_DomainOfMainViewer, None, AIS_InteractiveContext)
AIS_InteractiveContext.LocalContext = new_instancemethod(_AIS.AIS_InteractiveContext_LocalContext, None, AIS_InteractiveContext)
AIS_InteractiveContext.SelectionManager = new_instancemethod(_AIS.AIS_InteractiveContext_SelectionManager, None, AIS_InteractiveContext)
AIS_InteractiveContext.MainPrsMgr = new_instancemethod(_AIS.AIS_InteractiveContext_MainPrsMgr, None, AIS_InteractiveContext)
AIS_InteractiveContext.MainSelector = new_instancemethod(_AIS.AIS_InteractiveContext_MainSelector, None, AIS_InteractiveContext)
AIS_InteractiveContext.LocalSelector = new_instancemethod(_AIS.AIS_InteractiveContext_LocalSelector, None, AIS_InteractiveContext)
AIS_InteractiveContext.PurgeDisplay = new_instancemethod(_AIS.AIS_InteractiveContext_PurgeDisplay, None, AIS_InteractiveContext)
AIS_InteractiveContext.HighestIndex = new_instancemethod(_AIS.AIS_InteractiveContext_HighestIndex, None, AIS_InteractiveContext)
AIS_InteractiveContext.ClearActiveAreas = new_instancemethod(_AIS.AIS_InteractiveContext_ClearActiveAreas, None, AIS_InteractiveContext)
AIS_InteractiveContext.ClearActiveSensitive = new_instancemethod(_AIS.AIS_InteractiveContext_ClearActiveSensitive, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisplayActiveSensitive = new_instancemethod(_AIS.AIS_InteractiveContext_DisplayActiveSensitive, None, AIS_InteractiveContext)
AIS_InteractiveContext.DisplayActiveAreas = new_instancemethod(_AIS.AIS_InteractiveContext_DisplayActiveAreas, None, AIS_InteractiveContext)
AIS_InteractiveContext.IsInLocal = new_instancemethod(_AIS.AIS_InteractiveContext_IsInLocal, None, AIS_InteractiveContext)
AIS_InteractiveContext_swigregister = _AIS.AIS_InteractiveContext_swigregister
AIS_InteractiveContext_swigregister(AIS_InteractiveContext)

class Handle_AIS_InteractiveContext(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_InteractiveContext_swiginit(self, _AIS.new_Handle_AIS_InteractiveContext(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_InteractiveContext_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_InteractiveContext
Handle_AIS_InteractiveContext.Nullify = new_instancemethod(_AIS.Handle_AIS_InteractiveContext_Nullify, None, Handle_AIS_InteractiveContext)
Handle_AIS_InteractiveContext.IsNull = new_instancemethod(_AIS.Handle_AIS_InteractiveContext_IsNull, None, Handle_AIS_InteractiveContext)
Handle_AIS_InteractiveContext._get_reference = new_instancemethod(_AIS.Handle_AIS_InteractiveContext__get_reference, None, Handle_AIS_InteractiveContext)
Handle_AIS_InteractiveContext_swigregister = _AIS.Handle_AIS_InteractiveContext_swigregister
Handle_AIS_InteractiveContext_swigregister(Handle_AIS_InteractiveContext)

def Handle_AIS_InteractiveContext_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_InteractiveContext const":
    return _AIS.Handle_AIS_InteractiveContext_DownCast(AnObject)
Handle_AIS_InteractiveContext_DownCast = _AIS.Handle_AIS_InteractiveContext_DownCast

class AIS_InteractiveObject(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Type(self, *args) -> "AIS_KindOfInteractive":
        """
        * Returns the kind of Interactive Object: - None - Datum - Relation - Object By default, the interactive object has a None type. Because specific shapes entail different behavior according to their sub-shapes, you may need to create a Local Context. This will allow you to specify the additional characteristics which you need to handle these shapes.

        :rtype: AIS_KindOfInteractive

        """
        return _AIS.AIS_InteractiveObject_Type(self, *args)


    def Signature(self, *args) -> "Standard_Integer":
        """
        * Specifies additional characteristics of Interactive Objects. A signature is, in fact, an index with integer values assigned different properties. This method is frequently used in conjuction with Type to give a particular type and signature to an Interactive Object. By default, the Interactive Object has a None type and a signature of 0. Among the datums, this signature is attributed to the shape The remaining datums have the following default signatures: - Point  signature 1 - Axis signature 2 - Trihedron signature 3 - PlaneTrihedron signature 4 - Line signature 5 - Circle signature 6 - Plane  signature 7.

        :rtype: int

        """
        return _AIS.AIS_InteractiveObject_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args) -> "Standard_Boolean":
        """
        * Informs the graphic context that the interactive Object may be decomposed into sub-shapes for dynamic selection. The most used Interactive Object is AIS_Shape. Activation methods for standard selection modes are proposed in the Interactive Context. These include selection by vertex or by edges. For datums with the same behavior as AIS_Shape, such as vetices and edges, we must redefine the virtual method so that AcceptShapeDecomposition returns false. Rule for selection : Mode 0 : Selection of the interactive Object itself Mode 1 : Selection of vertices Mode 2 : Selection Of Edges Mode 3 : Selection Of Wires Mode 4 : Selection Of Faces ...

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args) -> "void":
        """
        * change the current facing model apply on polygons for SetColor(), SetTransparency(), SetMaterial() methods default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is applying both on the front and back face.

        :param aModel: default value is Aspect_TOFM_BOTH_SIDE
        :type aModel: Aspect_TypeOfFacingModel
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args) -> "Aspect_TypeOfFacingModel":
        """
        * Returns the current facing model which is in effect.

        :rtype: Aspect_TypeOfFacingModel

        """
        return _AIS.AIS_InteractiveObject_CurrentFacingModel(self, *args)


    def SetColor(self, *args) -> "void":
        """
        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: void

        * only the interactive obj knowns which Drawer attribute is affected by the color (ex: for a wire, it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color) WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myOwnColor)

        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_SetColor(self, *args)


    def UnsetColor(self, *args) -> "void":
        """
        * Removes color settings. Only the Interactive Object knows which Drawer attribute is affected by the color setting. For a wire, for example, wire aspect is the attribute affected. For a vertex, however, only point aspect is affected by the color setting.

        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_UnsetColor(self, *args)


    def SetWidth(self, *args) -> "void":
        """
        * Allows you to provide the setting aValue for width. Only the Interactive Object knows which Drawer attribute is affected by the width setting.

        :param aValue:
        :type aValue: float
        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_SetWidth(self, *args)


    def UnsetWidth(self, *args) -> "void":
        """
        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_UnsetWidth(self, *args)


    def AcceptDisplayMode(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the class of objects accepts the display mode aMode. The interactive context can have a default mode of representation for the set of Interactive Objects. This mode may not be accepted by a given class of objects. Consequently, this virtual method allowing us to get information about the class in question must be implemented.

        :param aMode:
        :type aMode: int
        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args) -> "Standard_Integer":
        """
        * Returns the default display mode. This method is to be implemented when the main mode is not mode 0.

        :rtype: int

        """
        return _AIS.AIS_InteractiveObject_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args) -> "void":
        """
        * Updates the active presentation; if <AllModes> = Standard_True all the presentations inside are recomputed.

        :param AllModes: default value is Standard_False
        :type AllModes: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_Redisplay(self, *args)


    def SetInfiniteState(self, *args) -> "void":
        """
        * Sets the infinite state flag aFlage. if <aFlag> = True , the interactiveObject is considered as infinite, i.e. its graphic presentations are not taken in account for View FitAll...

        :param aFlag: default value is Standard_True
        :type aFlag: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_SetInfiniteState(self, *args)


    def IsInfinite(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the interactive object is infinite. In this case, its graphic presentations are not taken into account in the fit-all view.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args) -> "Standard_Boolean":
        """
        * Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasInteractiveContext(self, *args)


    def GetContext(self, *args) -> "Handle_AIS_InteractiveContext":
        """
        * Returns the context pointer to the interactive context.

        :rtype: Handle_AIS_InteractiveContext

        """
        return _AIS.AIS_InteractiveObject_GetContext(self, *args)


    def SetContext(self, *args) -> "void":
        """
        * Sets the interactive context aCtx and provides a link to the default drawing tool or 'Drawer' if there is none.

        :param aCtx:
        :type aCtx: Handle_AIS_InteractiveContext &
        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_SetContext(self, *args)


    def HasOwner(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the object has an owner attributed to it. The owner can be a shape for a set of sub-shapes or a sub-shape for sub-shapes which it is composed of, and takes the form of a transient.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasOwner(self, *args)


    def GetOwner(self, *args) -> "Handle_Standard_Transient":
        """
        * Returns the owner of the Interactive Object. The owner can be a shape for a set of sub-shapes or a sub-shape for sub-shapes which it is composed of, and takes the form of a transient. There are two types of owners: - Direct owners, decomposition shapes such as edges, wires, and faces. - Users, presentable objects connecting to sensitive primitives, or a shape which has been decomposed.

        :rtype: Handle_Standard_Transient

        """
        return _AIS.AIS_InteractiveObject_GetOwner(self, *args)


    def SetOwner(self, *args) -> "void":
        """
        * Allows you to attribute the owner ApplicativeEntity to an Interactive Object. This can be a shape for a set of sub-shapes or a sub-shape for sub-shapes which it is composed of. The owner takes the form of a transient.

        :param ApplicativeEntity:
        :type ApplicativeEntity: Handle_Standard_Transient &
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_SetOwner(self, *args)


    def ClearOwner(self, *args) -> "void":
        """
        * Each Interactive Object has methods which allow us to attribute an Owner to it in the form of a Transient. This method removes the owner from the graphic entity.

        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_ClearOwner(self, *args)


    def HasUsers(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasUsers(self, *args)


    def Users(self, *args) -> "TColStd_ListOfTransient const &":
        """
        :rtype: TColStd_ListOfTransient

        """
        return _AIS.AIS_InteractiveObject_Users(self, *args)


    def AddUser(self, *args) -> "void":
        """
        :param aUser:
        :type aUser: Handle_Standard_Transient &
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_AddUser(self, *args)


    def ClearUsers(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_ClearUsers(self, *args)


    def HasDisplayMode(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Interactive Object has a display mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args) -> "void":
        """
        * Sets the display mode aMode for the interactive object. An object can have its own temporary display mode, which is different from that proposed by the interactive context. The range of possibilities currently proposed is the following: - AIS_WireFrame - AIS_Shaded This range can, however, be extended through the creation of new display modes.

        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args) -> "void":
        """
        * Removes display mode settings from the interactive object.

        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args) -> "Standard_Integer":
        """
        * Returns the display mode setting of the Interactive Object. The range of possibilities is the following: - AIS_WireFrame - AIS_Shaded This range can, however, be extended through the creation of new display modes.

        :rtype: int

        """
        return _AIS.AIS_InteractiveObject_DisplayMode(self, *args)


    def HasSelectionMode(self, *args) -> "Standard_Boolean":
        """
        * Allows you to change the selection mode of an Interactive Object. The default selection mode setting is 0. For shapes, for example, the selection modes are as follows: - mode 0 - selection of the shape itself - mode 1 - selection of vertices - mode 2 - selection of edges - mode 3 - selection of wires - mode 4 - selection of faces - mode 5 - selection of shells - mode 6 - selection of solids - mode 7 - selection of compounds For trihedra, on the other hand, the selection modes are the following four: - mode 0 - selection of a trihedron - mode 1 - selection of its origin - mode 2 - selection of its axes - mode 3 - selection of its planes

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasSelectionMode(self, *args)


    def SelectionMode(self, *args) -> "Standard_Integer":
        """
        * Returns the selection mode of the interactive object.

        :rtype: int

        """
        return _AIS.AIS_InteractiveObject_SelectionMode(self, *args)


    def SetSelectionMode(self, *args) -> "void":
        """
        * You can change the default selection mode index aMode of an Interactive Object. This is only of interest if you decide that mode 0 adopted by convention will not do.

        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_SetSelectionMode(self, *args)


    def UnsetSelectionMode(self, *args) -> "void":
        """
        * You can change the default selection mode index of an Interactive Object. This is only of interest if you decide that the 0 mode adopted by convention will not do.

        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_UnsetSelectionMode(self, *args)


    def SelectionPriority(self, *args) -> "Standard_Integer":
        """
        * Returns the selection priority setting. -1 indicates that there is none. You can modify the selection priority of an owner to make one entity more selectionable than another one. The default selection priority for an owner is 5, for example. To increase selection priority, choose a setting between 5 and 10. An entity with priority 7 will take priority over one with a setting of 6 if both objects are selected at the same time. You could give vertices priority 8, edges priority 7, faces priority 6, and shapes priority 5. If a vertex, an edge and a face are simultaneously detected during selection, only the vertex will then be highlighted. For trihedra, for example, the default priorities are the following four: - priority 1 - a trihedron - priority 5 - its origin - priority 3 - its axes - priority 2 - its planes

        :rtype: int

        """
        return _AIS.AIS_InteractiveObject_SelectionPriority(self, *args)


    def SetSelectionPriority(self, *args) -> "void":
        """
        * Allows you to provide a setting aPriority for selection priority. You can modify selection priority of an owner to make one entity more selectionable than another one. The default selection priority for an owner is 5, for example. To increase selection priority, choose a setting between 5 and 10. An entity with priority 7 will take priority over one with a setting of 6.

        :param aPriority:
        :type aPriority: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_SetSelectionPriority(self, *args)


    def UnsetSelectionPriority(self, *args) -> "void":
        """
        * Removes the setting for selection priority. SelectionPriority then returns -1.

        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_UnsetSelectionPriority(self, *args)


    def HasSelectionPriority(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is a setting for selection priority. You can modify selection priority of an owner to make one entity more selectionable than another one. The default selection priority for an owner is 5, for example. To increase selection priority, choose a setting between 5 and 10. An entity with priority 7 will take priority over one with a setting of 6.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasSelectionPriority(self, *args)


    def HasHilightMode(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Interactive Object is in highlight mode.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasHilightMode(self, *args)


    def HilightMode(self, *args) -> "Standard_Integer":
        """
        * Returns the setting for highlight mode. At dynamic detection, the presentation echoed by the Interactive Context, is by default the presentation already on the screen. You can specify a Highlight presentation mode which is valid no matter what the active representation of the object. It makes no difference whether this choice is temporary or definitive. To do this, we use the following functions: - SetHilightMode - UnSetHilightMode In the case of a shape, whether it is visualized in wireframe presentation or with shading, we want to systematically highlight the wireframe presentation. Consequently, we set the highlight mode to 0.

        :rtype: int

        """
        return _AIS.AIS_InteractiveObject_HilightMode(self, *args)


    def SetHilightMode(self, *args) -> "void":
        """
        * Sets the highlight mode anIndex for the interactive object. If, for example, you want to systematically highlight the wireframe presentation of a shape - whether visualized in wireframe presentation or with shading - you set the highlight mode to 0.

        :param anIndex:
        :type anIndex: int
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args) -> "void":
        """
        * Allows the user to take a given Prs for hilight ex : for a shape which would be displayed in shading mode the hilight Prs is the wireframe mode. if No specific hilight mode is defined, the displayed Prs will be the hilighted one.

        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_UnsetHilightMode(self, *args)


    def HasColor(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Interactive Object has color.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasColor(self, *args)


    def Color(self, *args) -> "void":
        """
        * Returns the color setting of the Interactive Object.

        :rtype: Quantity_NameOfColor

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_Color(self, *args)


    def HasWidth(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Interactive Object has width.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasWidth(self, *args)


    def Width(self, *args) -> "Standard_Real":
        """
        * Returns the width setting of the Interactive Object.

        :rtype: float

        """
        return _AIS.AIS_InteractiveObject_Width(self, *args)


    def HasMaterial(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Interactive Object has a setting for material.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasMaterial(self, *args)


    def Material(self, *args) -> "Graphic3d_NameOfMaterial":
        """
        * Returns the current material setting. This will be on of the following materials: - Brass - Bronze - Gold - Pewter - Silver - Stone.

        :rtype: Graphic3d_NameOfMaterial

        """
        return _AIS.AIS_InteractiveObject_Material(self, *args)


    def SetMaterial(self, *args) -> "void":
        """
        * Sets the name aName for material defining this display attribute for the interactive object. Material aspect determines shading aspect, color and transparency of visible entities.

        :param aName:
        :type aName: Graphic3d_NameOfMaterial
        :rtype: void

        * Sets the material aMat defining this display attribute for the interactive object. Material aspect determines shading aspect, color and transparency of visible entities.

        :param aName:
        :type aName: Graphic3d_MaterialAspect &
        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_SetMaterial(self, *args)


    def UnsetMaterial(self, *args) -> "void":
        """
        * Removes the setting for material.

        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_UnsetMaterial(self, *args)


    def SetTransparency(self, *args) -> "void":
        """
        * Attributes a setting aValue for transparency. The transparency value should be between 0.0 and 1.0. At 0.0 an object will be totally opaque, and at 1.0, fully transparent. Warning At a value of 1.0, there may be nothing visible.

        :param aValue: default value is 0.6
        :type aValue: float
        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_SetTransparency(self, *args)


    def IsTransparent(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is a transparency setting.

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_IsTransparent(self, *args)


    def Transparency(self, *args) -> "Standard_Real":
        """
        * Returns the transparency setting. This will be between 0.0 and 1.0. At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: float

        """
        return _AIS.AIS_InteractiveObject_Transparency(self, *args)


    def UnsetTransparency(self, *args) -> "void":
        """
        * Removes the transparency setting. The object is opaque by default.

        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_UnsetTransparency(self, *args)


    def SetAttributes(self, *args) -> "void":
        """
        * Initializes the drawing tool aDrawer.

        :param aDrawer:
        :type aDrawer: Handle_AIS_Drawer &
        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_SetAttributes(self, *args)


    def Attributes(self, *args) -> "Handle_AIS_Drawer":
        """
        * Returns the attributes settings.

        :rtype: Handle_AIS_Drawer

        """
        return _AIS.AIS_InteractiveObject_Attributes(self, *args)


    def UnsetAttributes(self, *args) -> "void":
        """
        * Clears settings provided by the drawing tool aDrawer.

        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_UnsetAttributes(self, *args)


    def State(self, *args) -> "Standard_Integer":
        """
        :param theState:
        :type theState: int
        :rtype: None

        :rtype: int

        """
        return _AIS.AIS_InteractiveObject_State(self, *args)


    def HasPresentation(self, *args) -> "Standard_Boolean":
        """
        * Returns True when this object has a presentation in the current DisplayMode()

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasPresentation(self, *args)


    def Presentation(self, *args) -> "Handle_Prs3d_Presentation":
        """
        * Returns the current presentation of this object according to the current DisplayMode()

        :rtype: Handle_Prs3d_Presentation

        """
        return _AIS.AIS_InteractiveObject_Presentation(self, *args)


    def SetAspect(self, *args) -> "void":
        """
        * Sets the graphic basic aspect to the current presentation. When <globalChange> is True , the full object presentation is changed. When <globalChange> is False , only the current group of the object presentation is changed.

        :param anAspect:
        :type anAspect: Handle_Prs3d_BasicAspect &
        :param globalChange: default value is Standard_True
        :type globalChange: bool
        :rtype: None

        """
        return _AIS.AIS_InteractiveObject_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args) -> "void":
        """
        * Sets up polygon offsets for this object. It modifies all existing presentations of <anObj> (if any), so it is reasonable to call this method after <anObj> has been displayed. Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work. //! <aMode> parameter can contain various combinations of Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means that polygon offsets are not changed). If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits> arguments are used by graphic renderer to calculate a depth offset value: //! offset = <aFactor> * m + <aUnits> * r, where m - maximum depth slope for the polygon currently being displayed, r - minimum window coordinates depth resolution (implementation-specific). //! Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0. //! Negative offset values move polygons closer to the viewport, while positive values shift polygons away. Consult OpenGL reference for details (glPolygonOffset function description). //! NOTE: This method has a side effect - it creates own shading aspect if not yet created, so it is better to set up object material, color, etc. first.

        :param aMode:
        :type aMode: int
        :param aFactor: default value is 1.0
        :type aFactor: Standard_ShortReal
        :param aUnits: default value is 0.0
        :type aUnits: Standard_ShortReal
        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: bool

        """
        return _AIS.AIS_InteractiveObject_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args) -> "void":
        """
        * Retrieves current polygon offsets settings from <myDrawer>.

        :param aMode:
        :type aMode: int &
        :param aFactor:
        :type aFactor: Standard_ShortReal &
        :param aUnits:
        :type aUnits: Standard_ShortReal &
        :rtype: void

        """
        return _AIS.AIS_InteractiveObject_PolygonOffsets(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_InteractiveObject(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_InteractiveObject
AIS_InteractiveObject.Type = new_instancemethod(_AIS.AIS_InteractiveObject_Type, None, AIS_InteractiveObject)
AIS_InteractiveObject.Signature = new_instancemethod(_AIS.AIS_InteractiveObject_Signature, None, AIS_InteractiveObject)
AIS_InteractiveObject.AcceptShapeDecomposition = new_instancemethod(_AIS.AIS_InteractiveObject_AcceptShapeDecomposition, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetCurrentFacingModel = new_instancemethod(_AIS.AIS_InteractiveObject_SetCurrentFacingModel, None, AIS_InteractiveObject)
AIS_InteractiveObject.CurrentFacingModel = new_instancemethod(_AIS.AIS_InteractiveObject_CurrentFacingModel, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetColor = new_instancemethod(_AIS.AIS_InteractiveObject_SetColor, None, AIS_InteractiveObject)
AIS_InteractiveObject.UnsetColor = new_instancemethod(_AIS.AIS_InteractiveObject_UnsetColor, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetWidth = new_instancemethod(_AIS.AIS_InteractiveObject_SetWidth, None, AIS_InteractiveObject)
AIS_InteractiveObject.UnsetWidth = new_instancemethod(_AIS.AIS_InteractiveObject_UnsetWidth, None, AIS_InteractiveObject)
AIS_InteractiveObject.AcceptDisplayMode = new_instancemethod(_AIS.AIS_InteractiveObject_AcceptDisplayMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.DefaultDisplayMode = new_instancemethod(_AIS.AIS_InteractiveObject_DefaultDisplayMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.Redisplay = new_instancemethod(_AIS.AIS_InteractiveObject_Redisplay, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetInfiniteState = new_instancemethod(_AIS.AIS_InteractiveObject_SetInfiniteState, None, AIS_InteractiveObject)
AIS_InteractiveObject.IsInfinite = new_instancemethod(_AIS.AIS_InteractiveObject_IsInfinite, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasInteractiveContext = new_instancemethod(_AIS.AIS_InteractiveObject_HasInteractiveContext, None, AIS_InteractiveObject)
AIS_InteractiveObject.GetContext = new_instancemethod(_AIS.AIS_InteractiveObject_GetContext, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetContext = new_instancemethod(_AIS.AIS_InteractiveObject_SetContext, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasOwner = new_instancemethod(_AIS.AIS_InteractiveObject_HasOwner, None, AIS_InteractiveObject)
AIS_InteractiveObject.GetOwner = new_instancemethod(_AIS.AIS_InteractiveObject_GetOwner, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetOwner = new_instancemethod(_AIS.AIS_InteractiveObject_SetOwner, None, AIS_InteractiveObject)
AIS_InteractiveObject.ClearOwner = new_instancemethod(_AIS.AIS_InteractiveObject_ClearOwner, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasUsers = new_instancemethod(_AIS.AIS_InteractiveObject_HasUsers, None, AIS_InteractiveObject)
AIS_InteractiveObject.Users = new_instancemethod(_AIS.AIS_InteractiveObject_Users, None, AIS_InteractiveObject)
AIS_InteractiveObject.AddUser = new_instancemethod(_AIS.AIS_InteractiveObject_AddUser, None, AIS_InteractiveObject)
AIS_InteractiveObject.ClearUsers = new_instancemethod(_AIS.AIS_InteractiveObject_ClearUsers, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasDisplayMode = new_instancemethod(_AIS.AIS_InteractiveObject_HasDisplayMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetDisplayMode = new_instancemethod(_AIS.AIS_InteractiveObject_SetDisplayMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.UnsetDisplayMode = new_instancemethod(_AIS.AIS_InteractiveObject_UnsetDisplayMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.DisplayMode = new_instancemethod(_AIS.AIS_InteractiveObject_DisplayMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasSelectionMode = new_instancemethod(_AIS.AIS_InteractiveObject_HasSelectionMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.SelectionMode = new_instancemethod(_AIS.AIS_InteractiveObject_SelectionMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetSelectionMode = new_instancemethod(_AIS.AIS_InteractiveObject_SetSelectionMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.UnsetSelectionMode = new_instancemethod(_AIS.AIS_InteractiveObject_UnsetSelectionMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.SelectionPriority = new_instancemethod(_AIS.AIS_InteractiveObject_SelectionPriority, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetSelectionPriority = new_instancemethod(_AIS.AIS_InteractiveObject_SetSelectionPriority, None, AIS_InteractiveObject)
AIS_InteractiveObject.UnsetSelectionPriority = new_instancemethod(_AIS.AIS_InteractiveObject_UnsetSelectionPriority, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasSelectionPriority = new_instancemethod(_AIS.AIS_InteractiveObject_HasSelectionPriority, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasHilightMode = new_instancemethod(_AIS.AIS_InteractiveObject_HasHilightMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.HilightMode = new_instancemethod(_AIS.AIS_InteractiveObject_HilightMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetHilightMode = new_instancemethod(_AIS.AIS_InteractiveObject_SetHilightMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.UnsetHilightMode = new_instancemethod(_AIS.AIS_InteractiveObject_UnsetHilightMode, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasColor = new_instancemethod(_AIS.AIS_InteractiveObject_HasColor, None, AIS_InteractiveObject)
AIS_InteractiveObject.Color = new_instancemethod(_AIS.AIS_InteractiveObject_Color, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasWidth = new_instancemethod(_AIS.AIS_InteractiveObject_HasWidth, None, AIS_InteractiveObject)
AIS_InteractiveObject.Width = new_instancemethod(_AIS.AIS_InteractiveObject_Width, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasMaterial = new_instancemethod(_AIS.AIS_InteractiveObject_HasMaterial, None, AIS_InteractiveObject)
AIS_InteractiveObject.Material = new_instancemethod(_AIS.AIS_InteractiveObject_Material, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetMaterial = new_instancemethod(_AIS.AIS_InteractiveObject_SetMaterial, None, AIS_InteractiveObject)
AIS_InteractiveObject.UnsetMaterial = new_instancemethod(_AIS.AIS_InteractiveObject_UnsetMaterial, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetTransparency = new_instancemethod(_AIS.AIS_InteractiveObject_SetTransparency, None, AIS_InteractiveObject)
AIS_InteractiveObject.IsTransparent = new_instancemethod(_AIS.AIS_InteractiveObject_IsTransparent, None, AIS_InteractiveObject)
AIS_InteractiveObject.Transparency = new_instancemethod(_AIS.AIS_InteractiveObject_Transparency, None, AIS_InteractiveObject)
AIS_InteractiveObject.UnsetTransparency = new_instancemethod(_AIS.AIS_InteractiveObject_UnsetTransparency, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetAttributes = new_instancemethod(_AIS.AIS_InteractiveObject_SetAttributes, None, AIS_InteractiveObject)
AIS_InteractiveObject.Attributes = new_instancemethod(_AIS.AIS_InteractiveObject_Attributes, None, AIS_InteractiveObject)
AIS_InteractiveObject.UnsetAttributes = new_instancemethod(_AIS.AIS_InteractiveObject_UnsetAttributes, None, AIS_InteractiveObject)
AIS_InteractiveObject.State = new_instancemethod(_AIS.AIS_InteractiveObject_State, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasPresentation = new_instancemethod(_AIS.AIS_InteractiveObject_HasPresentation, None, AIS_InteractiveObject)
AIS_InteractiveObject.Presentation = new_instancemethod(_AIS.AIS_InteractiveObject_Presentation, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetAspect = new_instancemethod(_AIS.AIS_InteractiveObject_SetAspect, None, AIS_InteractiveObject)
AIS_InteractiveObject.SetPolygonOffsets = new_instancemethod(_AIS.AIS_InteractiveObject_SetPolygonOffsets, None, AIS_InteractiveObject)
AIS_InteractiveObject.HasPolygonOffsets = new_instancemethod(_AIS.AIS_InteractiveObject_HasPolygonOffsets, None, AIS_InteractiveObject)
AIS_InteractiveObject.PolygonOffsets = new_instancemethod(_AIS.AIS_InteractiveObject_PolygonOffsets, None, AIS_InteractiveObject)
AIS_InteractiveObject_swigregister = _AIS.AIS_InteractiveObject_swigregister
AIS_InteractiveObject_swigregister(AIS_InteractiveObject)

class Handle_AIS_InteractiveObject(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_InteractiveObject_swiginit(self, _AIS.new_Handle_AIS_InteractiveObject(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_InteractiveObject_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_InteractiveObject
Handle_AIS_InteractiveObject.Nullify = new_instancemethod(_AIS.Handle_AIS_InteractiveObject_Nullify, None, Handle_AIS_InteractiveObject)
Handle_AIS_InteractiveObject.IsNull = new_instancemethod(_AIS.Handle_AIS_InteractiveObject_IsNull, None, Handle_AIS_InteractiveObject)
Handle_AIS_InteractiveObject._get_reference = new_instancemethod(_AIS.Handle_AIS_InteractiveObject__get_reference, None, Handle_AIS_InteractiveObject)
Handle_AIS_InteractiveObject_swigregister = _AIS.Handle_AIS_InteractiveObject_swigregister
Handle_AIS_InteractiveObject_swigregister(Handle_AIS_InteractiveObject)

def Handle_AIS_InteractiveObject_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_InteractiveObject const":
    return _AIS.Handle_AIS_InteractiveObject_DownCast(AnObject)
Handle_AIS_InteractiveObject_DownCast = _AIS.Handle_AIS_InteractiveObject_DownCast

class AIS_ListIteratorOfListOfInteractive(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param L:
        :type L: AIS_ListOfInteractive &
        :rtype: None

        """
        _AIS.AIS_ListIteratorOfListOfInteractive_swiginit(self, _AIS.new_AIS_ListIteratorOfListOfInteractive(*args))

    def Initialize(self, *args) -> "void":
        """
        :param L:
        :type L: AIS_ListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_ListIteratorOfListOfInteractive_Initialize(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_ListIteratorOfListOfInteractive_More(self, *args)


    def Next(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_ListIteratorOfListOfInteractive_Next(self, *args)


    def Value(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_ListIteratorOfListOfInteractive_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_ListIteratorOfListOfInteractive
AIS_ListIteratorOfListOfInteractive.Initialize = new_instancemethod(_AIS.AIS_ListIteratorOfListOfInteractive_Initialize, None, AIS_ListIteratorOfListOfInteractive)
AIS_ListIteratorOfListOfInteractive.More = new_instancemethod(_AIS.AIS_ListIteratorOfListOfInteractive_More, None, AIS_ListIteratorOfListOfInteractive)
AIS_ListIteratorOfListOfInteractive.Next = new_instancemethod(_AIS.AIS_ListIteratorOfListOfInteractive_Next, None, AIS_ListIteratorOfListOfInteractive)
AIS_ListIteratorOfListOfInteractive.Value = new_instancemethod(_AIS.AIS_ListIteratorOfListOfInteractive_Value, None, AIS_ListIteratorOfListOfInteractive)
AIS_ListIteratorOfListOfInteractive_swigregister = _AIS.AIS_ListIteratorOfListOfInteractive_swigregister
AIS_ListIteratorOfListOfInteractive_swigregister(AIS_ListIteratorOfListOfInteractive)

class AIS_ListNodeOfListOfInteractive(OCC.TCollection.TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: Handle_AIS_InteractiveObject &
        :param n:
        :type n: TCollection_MapNodePtr &
        :rtype: None

        """
        _AIS.AIS_ListNodeOfListOfInteractive_swiginit(self, _AIS.new_AIS_ListNodeOfListOfInteractive(*args))

    def Value(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_ListNodeOfListOfInteractive_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_ListNodeOfListOfInteractive(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_ListNodeOfListOfInteractive
AIS_ListNodeOfListOfInteractive.Value = new_instancemethod(_AIS.AIS_ListNodeOfListOfInteractive_Value, None, AIS_ListNodeOfListOfInteractive)
AIS_ListNodeOfListOfInteractive_swigregister = _AIS.AIS_ListNodeOfListOfInteractive_swigregister
AIS_ListNodeOfListOfInteractive_swigregister(AIS_ListNodeOfListOfInteractive)

class Handle_AIS_ListNodeOfListOfInteractive(OCC.TCollection.Handle_TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_ListNodeOfListOfInteractive_swiginit(self, _AIS.new_Handle_AIS_ListNodeOfListOfInteractive(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_ListNodeOfListOfInteractive_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_ListNodeOfListOfInteractive
Handle_AIS_ListNodeOfListOfInteractive.Nullify = new_instancemethod(_AIS.Handle_AIS_ListNodeOfListOfInteractive_Nullify, None, Handle_AIS_ListNodeOfListOfInteractive)
Handle_AIS_ListNodeOfListOfInteractive.IsNull = new_instancemethod(_AIS.Handle_AIS_ListNodeOfListOfInteractive_IsNull, None, Handle_AIS_ListNodeOfListOfInteractive)
Handle_AIS_ListNodeOfListOfInteractive._get_reference = new_instancemethod(_AIS.Handle_AIS_ListNodeOfListOfInteractive__get_reference, None, Handle_AIS_ListNodeOfListOfInteractive)
Handle_AIS_ListNodeOfListOfInteractive_swigregister = _AIS.Handle_AIS_ListNodeOfListOfInteractive_swigregister
Handle_AIS_ListNodeOfListOfInteractive_swigregister(Handle_AIS_ListNodeOfListOfInteractive)

def Handle_AIS_ListNodeOfListOfInteractive_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_ListNodeOfListOfInteractive const":
    return _AIS.Handle_AIS_ListNodeOfListOfInteractive_DownCast(AnObject)
Handle_AIS_ListNodeOfListOfInteractive_DownCast = _AIS.Handle_AIS_ListNodeOfListOfInteractive_DownCast

class AIS_ListOfInteractive(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Other:
        :type Other: AIS_ListOfInteractive &
        :rtype: None

        """
        _AIS.AIS_ListOfInteractive_swiginit(self, _AIS.new_AIS_ListOfInteractive(*args))

    def Assign(self, *args) -> "void":
        """
        :param Other:
        :type Other: AIS_ListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_ListOfInteractive_Assign(self, *args)


    def Set(self, *args) -> "void":
        """
        :param Other:
        :type Other: AIS_ListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_ListOfInteractive_Set(self, *args)


    def Extent(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _AIS.AIS_ListOfInteractive_Extent(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_ListOfInteractive_Clear(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_ListOfInteractive_IsEmpty(self, *args)


    def Prepend(self, *args) -> "void":
        """
        :param I:
        :type I: Handle_AIS_InteractiveObject &
        :rtype: None

        :param I:
        :type I: Handle_AIS_InteractiveObject &
        :param theIt:
        :type theIt: AIS_ListIteratorOfListOfInteractive &
        :rtype: None

        :param Other:
        :type Other: AIS_ListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_ListOfInteractive_Prepend(self, *args)


    def Append(self, *args) -> "void":
        """
        :param I:
        :type I: Handle_AIS_InteractiveObject &
        :rtype: None

        :param I:
        :type I: Handle_AIS_InteractiveObject &
        :param theIt:
        :type theIt: AIS_ListIteratorOfListOfInteractive &
        :rtype: None

        :param Other:
        :type Other: AIS_ListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_ListOfInteractive_Append(self, *args)


    def First(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_ListOfInteractive_First(self, *args)


    def Last(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_ListOfInteractive_Last(self, *args)


    def RemoveFirst(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_ListOfInteractive_RemoveFirst(self, *args)


    def Remove(self, *args) -> "void":
        """
        :param It:
        :type It: AIS_ListIteratorOfListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_ListOfInteractive_Remove(self, *args)


    def InsertBefore(self, *args) -> "void":
        """
        :param I:
        :type I: Handle_AIS_InteractiveObject &
        :param It:
        :type It: AIS_ListIteratorOfListOfInteractive &
        :rtype: None

        :param Other:
        :type Other: AIS_ListOfInteractive &
        :param It:
        :type It: AIS_ListIteratorOfListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_ListOfInteractive_InsertBefore(self, *args)


    def InsertAfter(self, *args) -> "void":
        """
        :param I:
        :type I: Handle_AIS_InteractiveObject &
        :param It:
        :type It: AIS_ListIteratorOfListOfInteractive &
        :rtype: None

        :param Other:
        :type Other: AIS_ListOfInteractive &
        :param It:
        :type It: AIS_ListIteratorOfListOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_ListOfInteractive_InsertAfter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_ListOfInteractive
AIS_ListOfInteractive.Assign = new_instancemethod(_AIS.AIS_ListOfInteractive_Assign, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.Set = new_instancemethod(_AIS.AIS_ListOfInteractive_Set, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.Extent = new_instancemethod(_AIS.AIS_ListOfInteractive_Extent, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.Clear = new_instancemethod(_AIS.AIS_ListOfInteractive_Clear, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.IsEmpty = new_instancemethod(_AIS.AIS_ListOfInteractive_IsEmpty, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.Prepend = new_instancemethod(_AIS.AIS_ListOfInteractive_Prepend, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.Append = new_instancemethod(_AIS.AIS_ListOfInteractive_Append, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.First = new_instancemethod(_AIS.AIS_ListOfInteractive_First, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.Last = new_instancemethod(_AIS.AIS_ListOfInteractive_Last, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.RemoveFirst = new_instancemethod(_AIS.AIS_ListOfInteractive_RemoveFirst, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.Remove = new_instancemethod(_AIS.AIS_ListOfInteractive_Remove, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.InsertBefore = new_instancemethod(_AIS.AIS_ListOfInteractive_InsertBefore, None, AIS_ListOfInteractive)
AIS_ListOfInteractive.InsertAfter = new_instancemethod(_AIS.AIS_ListOfInteractive_InsertAfter, None, AIS_ListOfInteractive)
AIS_ListOfInteractive_swigregister = _AIS.AIS_ListOfInteractive_swigregister
AIS_ListOfInteractive_swigregister(AIS_ListOfInteractive)

class AIS_LocalContext(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        * Constructor By Default, the displayed objects are automatically loaded.

        :param aCtx:
        :type aCtx: Handle_AIS_InteractiveContext &
        :param anIndex:
        :type anIndex: int
        :param LoadDisplayed: default value is Standard_True
        :type LoadDisplayed: bool
        :param AcceptStandardModes: default value is Standard_True
        :type AcceptStandardModes: bool
        :param AcceptErase: default value is Standard_False
        :type AcceptErase: bool
        :param UseBothViewers: default value is Standard_False
        :type UseBothViewers: bool
        :rtype: None

        """
        _AIS.AIS_LocalContext_swiginit(self, _AIS.new_AIS_LocalContext(*args))

    def AcceptErase(self, *args) -> "Standard_Boolean":
        """
        * authorize or not others contexts to erase temporary displayed objects here;

        :param aStatus:
        :type aStatus: bool
        :rtype: None

        :rtype: bool

        """
        return _AIS.AIS_LocalContext_AcceptErase(self, *args)


    def SetContext(self, *args) -> "void":
        """
        :param aCtx:
        :type aCtx: Handle_AIS_InteractiveContext &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SetContext(self, *args)


    def SelectionName(self, *args) -> "TCollection_AsciiString const &":
        """
        :rtype: TCollection_AsciiString

        """
        return _AIS.AIS_LocalContext_SelectionName(self, *args)


    def Terminate(self, *args) -> "void":
        """
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_Terminate(self, *args)


    def HasSameProjector(self, *args) -> "Standard_Boolean":
        """
        * compares the current projector of the localContext with <aPrj> returns True if the projectors are identical. (no need to update projection of selection primitives when closing the local context)....

        :param aPrj:
        :type aPrj: Handle_Select3D_Projector &
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_HasSameProjector(self, *args)


    def Display(self, *args) -> "Standard_Boolean":
        """
        * returns true if done...

        :param anInteractive:
        :type anInteractive: Handle_AIS_InteractiveObject &
        :param DisplayMode: default value is 0
        :type DisplayMode: int
        :param AllowShapeDecomposition: default value is Standard_True
        :type AllowShapeDecomposition: bool
        :param ActivationMode: default value is 0
        :type ActivationMode: int
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_Display(self, *args)


    def Load(self, *args) -> "Standard_Boolean":
        """
        * loads <anInteractive> with nodisplay... returns true if done

        :param anInteractive:
        :type anInteractive: Handle_AIS_InteractiveObject &
        :param AllowShapeDecomposition: default value is Standard_True
        :type AllowShapeDecomposition: bool
        :param ActivationMode: default value is 0
        :type ActivationMode: int
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_Load(self, *args)


    def Erase(self, *args) -> "Standard_Boolean":
        """
        * returns true if done...

        :param anInteractive:
        :type anInteractive: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_Erase(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        :param aSelectable:
        :type aSelectable: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_Remove(self, *args)


    def ClearPrs(self, *args) -> "Standard_Boolean":
        """
        :param anInteractive:
        :type anInteractive: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_ClearPrs(self, *args)


    def SetShapeDecomposition(self, *args) -> "void":
        """
        * allows or forbids the shape decomposition into Activated Standard Mode for <aStoredObject> does nothing if the object doesn't inherits BasicShape from AIS

        :param aStoredObject:
        :type aStoredObject: Handle_AIS_InteractiveObject &
        :param aStatus:
        :type aStatus: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SetShapeDecomposition(self, *args)


    def Clear(self, *args) -> "void":
        """
        * according to <atype> , clears the different parts of the selector (filters, modeof activation, objects...)

        :param atype: default value is AIS_CM_All
        :type atype: AIS_ClearMode
        :rtype: None

        """
        return _AIS.AIS_LocalContext_Clear(self, *args)


    def ActivateMode(self, *args) -> "void":
        """
        * optional : activation of a mode which is not 0 for a selectable...

        :param aSelectable:
        :type aSelectable: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_LocalContext_ActivateMode(self, *args)


    def DeactivateMode(self, *args) -> "void":
        """
        :param aSelectable:
        :type aSelectable: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_LocalContext_DeactivateMode(self, *args)


    def Deactivate(self, *args) -> "void":
        """
        :param aSelectable:
        :type aSelectable: Handle_AIS_InteractiveObject &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_Deactivate(self, *args)


    def ActivateStandardMode(self, *args) -> "void":
        """
        * decomposition of shapes into <aType>

        :param aType:
        :type aType: TopAbs_ShapeEnum
        :rtype: None

        """
        return _AIS.AIS_LocalContext_ActivateStandardMode(self, *args)


    def DeactivateStandardMode(self, *args) -> "void":
        """
        :param aType:
        :type aType: TopAbs_ShapeEnum
        :rtype: None

        """
        return _AIS.AIS_LocalContext_DeactivateStandardMode(self, *args)


    def StandardModes(self, *args) -> "TColStd_ListOfInteger const &":
        """
        :rtype: TColStd_ListOfInteger

        """
        return _AIS.AIS_LocalContext_StandardModes(self, *args)


    def AddFilter(self, *args) -> "void":
        """
        :param aFilter:
        :type aFilter: Handle_SelectMgr_Filter &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_AddFilter(self, *args)


    def RemoveFilter(self, *args) -> "void":
        """
        :param aFilter:
        :type aFilter: Handle_SelectMgr_Filter &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_RemoveFilter(self, *args)


    def ListOfFilter(self, *args) -> "SelectMgr_ListOfFilter const &":
        """
        :rtype: SelectMgr_ListOfFilter

        """
        return _AIS.AIS_LocalContext_ListOfFilter(self, *args)


    def Filter(self, *args) -> "Handle_SelectMgr_OrFilter":
        """
        :rtype: Handle_SelectMgr_OrFilter

        """
        return _AIS.AIS_LocalContext_Filter(self, *args)


    def SetAutomaticHilight(self, *args) -> "void":
        """
        * if <aStatus> = True , the shapes or subshapes detected by the selector will be automatically hilighted in the main viewer. Else the user has to manage the detected shape outside the Shape Selector....

        :param aStatus:
        :type aStatus: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SetAutomaticHilight(self, *args)


    def AutomaticHilight(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_AutomaticHilight(self, *args)


    def MoveTo(self, *args) -> "AIS_StatusOfDetection":
        """
        :param theXpix:
        :type theXpix: int
        :param theYpix:
        :type theYpix: int
        :param theView:
        :type theView: Handle_V3d_View &
        :param theToRedrawImmediate:
        :type theToRedrawImmediate: bool
        :rtype: AIS_StatusOfDetection

        """
        return _AIS.AIS_LocalContext_MoveTo(self, *args)


    def HasNextDetected(self, *args) -> "Standard_Boolean":
        """
        * returns True if more than one entity was detected at the last Mouse position.

        :rtype: bool

        """
        return _AIS.AIS_LocalContext_HasNextDetected(self, *args)


    def HilightNextDetected(self, *args) -> "Standard_Integer":
        """
        * returns True if last detected. the next detected will be first one (endless loop)

        :param theView:
        :type theView: Handle_V3d_View &
        :param theToRedrawImmediate:
        :type theToRedrawImmediate: bool
        :rtype: int

        """
        return _AIS.AIS_LocalContext_HilightNextDetected(self, *args)


    def HilightPreviousDetected(self, *args) -> "Standard_Integer":
        """
        :param theView:
        :type theView: Handle_V3d_View &
        :param theToRedrawImmediate:
        :type theToRedrawImmediate: bool
        :rtype: int

        """
        return _AIS.AIS_LocalContext_HilightPreviousDetected(self, *args)


    def UnhilightLastDetected(self, *args) -> "Standard_Boolean":
        """
        * returns True if something was done...

        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_UnhilightLastDetected(self, *args)


    def Select(self, *args) -> "AIS_StatusOfPick":
        """
        * returns the number of selected

        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        :param XPMin:
        :type XPMin: int
        :param YPMin:
        :type YPMin: int
        :param XPMax:
        :type XPMax: int
        :param YPMax:
        :type YPMax: int
        :param aView:
        :type aView: Handle_V3d_View &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        :param Polyline:
        :type Polyline: TColgp_Array1OfPnt2d
        :param aView:
        :type aView: Handle_V3d_View &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        """
        return _AIS.AIS_LocalContext_Select(self, *args)


    def ShiftSelect(self, *args) -> "AIS_StatusOfPick":
        """
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        :param XPMin:
        :type XPMin: int
        :param YPMin:
        :type YPMin: int
        :param XPMax:
        :type XPMax: int
        :param YPMax:
        :type YPMax: int
        :param aView:
        :type aView: Handle_V3d_View &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        :param Polyline:
        :type Polyline: TColgp_Array1OfPnt2d
        :param aView:
        :type aView: Handle_V3d_View &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: AIS_StatusOfPick

        """
        return _AIS.AIS_LocalContext_ShiftSelect(self, *args)


    def HilightPicked(self, *args) -> "void":
        """
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_HilightPicked(self, *args)


    def UnhilightPicked(self, *args) -> "void":
        """
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_UnhilightPicked(self, *args)


    def UpdateSelected(self, *args) -> "void":
        """
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        * Part of advanced selection highlighting mechanism. If no owners belonging to anobj are selected, calls anobj->ClearSelected(), otherwise calls anobj->HilightSelected(). This method can be used to avoid redrawing the whole selection belonging to several Selectable Objects.

        :param anobj:
        :type anobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_UpdateSelected(self, *args)


    def SetSelected(self, *args) -> "void":
        """
        * useful to update selection with objects coming from Collector or stack

        :param anobj:
        :type anobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SetSelected(self, *args)


    def AddOrRemoveSelected(self, *args) -> "void":
        """
        * useful to update selection with objects coming from Collector or stack

        :param anobj:
        :type anobj: Handle_AIS_InteractiveObject &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param updateviewer: default value is Standard_True
        :type updateviewer: bool
        :rtype: None

        :param theOwner:
        :type theOwner: Handle_SelectMgr_EntityOwner &
        :param toUpdateViewer: default value is Standard_True
        :type toUpdateViewer: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_AddOrRemoveSelected(self, *args)


    def ClearSelected(self, *args) -> "void":
        """
        * Clears local context selection. @param toUpdateViewer [in] if True the viewer will be updated.

        :param toUpdateViewer: default value is Standard_True
        :type toUpdateViewer: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_ClearSelected(self, *args)


    def ClearOutdatedSelection(self, *args) -> "void":
        """
        * Clears outdated selection and detection of owners for the interactive object. Use this method if selection structures of the interactive object have changed. The method unhilights and removes outdated entity owners from lists of selected and detected owners. @param theIO [in] the interactive object. @param toClearDeactivated [in] pass True to treat deactivated entity owners as 'outdated' when clearing the selection.

        :param theIO:
        :type theIO: Handle_AIS_InteractiveObject &
        :param toClearDeactivated:
        :type toClearDeactivated: bool
        :rtype: None

        """
        return _AIS.AIS_LocalContext_ClearOutdatedSelection(self, *args)


    def HasDetected(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_HasDetected(self, *args)


    def InitDetected(self, *args) -> "void":
        """
        * Initialization for iteration through mouse-detected objects in local context.

        :rtype: None

        """
        return _AIS.AIS_LocalContext_InitDetected(self, *args)


    def MoreDetected(self, *args) -> "Standard_Boolean":
        """
        * returns true if there is more mouse-detected objects after the current one during iteration through mouse-detected interactive objects.

        :rtype: bool

        """
        return _AIS.AIS_LocalContext_MoreDetected(self, *args)


    def NextDetected(self, *args) -> "void":
        """
        * Gets next current object during iteration through mouse-detected interactive objects.

        :rtype: None

        """
        return _AIS.AIS_LocalContext_NextDetected(self, *args)


    def DetectedCurrentShape(self, *args) -> "TopoDS_Shape const":
        """
        * returns current mouse-detected shape or empty (null) shape, if current interactive object is not a shape (AIS_Shape) or there is no current mouse-detected interactive object at all.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_LocalContext_DetectedCurrentShape(self, *args)


    def DetectedCurrentObject(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        * returns current mouse-detected interactive object or null object if there is no current detected.

        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_DetectedCurrentObject(self, *args)


    def HasDetectedShape(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_HasDetectedShape(self, *args)


    def DetectedShape(self, *args) -> "TopoDS_Shape const":
        """
        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_LocalContext_DetectedShape(self, *args)


    def DetectedInteractive(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_DetectedInteractive(self, *args)


    def DetectedOwner(self, *args) -> "Handle_SelectMgr_EntityOwner":
        """
        :rtype: Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_LocalContext_DetectedOwner(self, *args)


    def InitSelected(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_LocalContext_InitSelected(self, *args)


    def MoreSelected(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_MoreSelected(self, *args)


    def NextSelected(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_LocalContext_NextSelected(self, *args)


    def HasShape(self, *args) -> "Standard_Boolean":
        """
        * returns True if the detected entity is a shape coming from a Decomposition of an element.

        :rtype: bool

        """
        return _AIS.AIS_LocalContext_HasShape(self, *args)


    def SelectedShape(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_LocalContext_SelectedShape(self, *args)


    def SelectedOwner(self, *args) -> "Handle_SelectMgr_EntityOwner":
        """
        :rtype: Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_LocalContext_SelectedOwner(self, *args)


    def IsSelected(self, *args) -> "Standard_Boolean":
        """
        :param aniobj:
        :type aniobj: Handle_AIS_InteractiveObject &
        :rtype: bool

        :param anOwner:
        :type anOwner: Handle_SelectMgr_EntityOwner &
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_IsSelected(self, *args)


    def SelectedInteractive(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_SelectedInteractive(self, *args)


    def HasApplicative(self, *args) -> "Standard_Boolean":
        """
        * returns True if an interactive element was associated with the current picked entity.

        :rtype: bool

        """
        return _AIS.AIS_LocalContext_HasApplicative(self, *args)


    def SelectedApplicative(self, *args) -> "Handle_Standard_Transient":
        """
        :rtype: Handle_Standard_Transient

        """
        return _AIS.AIS_LocalContext_SelectedApplicative(self, *args)


    def SetDisplayPriority(self, *args) -> "void":
        """
        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :param Prior:
        :type Prior: int
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SetDisplayPriority(self, *args)


    def SetZLayer(self, *args) -> "void":
        """
        * Set Z layer id for interactive object. The layer can be specified for displayed object only. The Z layers can be used to display temporarily presentations of some object in front of the other objects in the scene. The ids for Z layers are generated by V3d_Viewer. Note that Z layers differ from under-/overlayer in V3d_View: under-/overlayer are intended for specific 2D drawings that appear behind/in front of all 3D presentations, while SetZLayer() method applies to regular 3D presentations and does not imply any specific drawing methods.

        :param theIObj:
        :type theIObj: Handle_AIS_InteractiveObject &
        :param theLayerId:
        :type theLayerId: int
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SetZLayer(self, *args)


    def GetZLayer(self, *args) -> "Standard_Integer":
        """
        * Get Z layer id set for displayed interactive object. If the object doesn't exists in context or has no computed presentations, the method returns -1.

        :param theIObj:
        :type theIObj: Handle_AIS_InteractiveObject &
        :rtype: int

        """
        return _AIS.AIS_LocalContext_GetZLayer(self, *args)


    def DisplayedObjects(self, *args) -> "Standard_Integer":
        """
        :param theMapToFill:
        :type theMapToFill: TColStd_MapOfTransient &
        :rtype: int

        """
        return _AIS.AIS_LocalContext_DisplayedObjects(self, *args)


    def IsIn(self, *args) -> "Standard_Boolean":
        """
        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_IsIn(self, *args)


    def IsDisplayed(self, *args) -> "Standard_Boolean":
        """
        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :rtype: bool

        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :param aMode:
        :type aMode: int
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_IsDisplayed(self, *args)


    def SelectionModes(self, *args) -> "TColStd_ListOfInteger const &":
        """
        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :rtype: TColStd_ListOfInteger

        """
        return _AIS.AIS_LocalContext_SelectionModes(self, *args)


    def SubIntensityOn(self, *args) -> "void":
        """
        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args) -> "void":
        """
        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SubIntensityOff(self, *args)


    def Hilight(self, *args) -> "void":
        """
        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :rtype: None

        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :param aCol:
        :type aCol: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_LocalContext_Hilight(self, *args)


    def Unhilight(self, *args) -> "void":
        """
        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_Unhilight(self, *args)


    def IsHilighted(self, *args) -> "Standard_Boolean":
        """
        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :rtype: bool

        :param anObject:
        :type anObject: Handle_AIS_InteractiveObject &
        :param WithColor:
        :type WithColor: bool
        :param HiCol:
        :type HiCol: Quantity_NameOfColor &
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_IsHilighted(self, *args)


    def SetSensitivityMode(self, *args) -> "void":
        """
        * Sets the selection sensitivity mode. SM_WINDOW mode uses the specified pixel tolerance to compute the sensitivity value, SM_VIEW mode allows to define the sensitivity manually.

        :param aMode:
        :type aMode: StdSelect_SensitivityMode
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SetSensitivityMode(self, *args)


    def SensitivityMode(self, *args) -> "StdSelect_SensitivityMode":
        """
        * Returns the selection sensitivity mode.

        :rtype: StdSelect_SensitivityMode

        """
        return _AIS.AIS_LocalContext_SensitivityMode(self, *args)


    def SetSensitivity(self, *args) -> "void":
        """
        * Define the current selection sensitivity for this local context according to the view size.

        :param aPrecision:
        :type aPrecision: float
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SetSensitivity(self, *args)


    def Sensitivity(self, *args) -> "Standard_Real":
        """
        * Returns the selection sensitivity value.

        :rtype: float

        """
        return _AIS.AIS_LocalContext_Sensitivity(self, *args)


    def SetPixelTolerance(self, *args) -> "void":
        """
        * Define the current selection sensitivity for this local context according to the view size.

        :param aPrecision: default value is 2
        :type aPrecision: int
        :rtype: None

        """
        return _AIS.AIS_LocalContext_SetPixelTolerance(self, *args)


    def PixelTolerance(self, *args) -> "Standard_Integer":
        """
        * Returns the pixel tolerance.

        :rtype: int

        """
        return _AIS.AIS_LocalContext_PixelTolerance(self, *args)


    def BeginImmediateDraw(self, *args) -> "Standard_Boolean":
        """
        * Resets the transient list of presentations previously displayed in immediate mode and begins accumulation of new list by following AddToImmediateList()/Color()/Highlight() calls.

        :rtype: bool

        """
        return _AIS.AIS_LocalContext_BeginImmediateDraw(self, *args)


    def ClearImmediateDraw(self, *args) -> "void":
        """
        * Resets the transient list of presentations previously displayed in immediate mode.

        :rtype: void

        """
        return _AIS.AIS_LocalContext_ClearImmediateDraw(self, *args)


    def ImmediateAdd(self, *args) -> "Standard_Boolean":
        """
        * Stores presentation theMode of object theObj in the transient list of presentations to be displayed in immediate mode. Will be taken in account in EndImmediateDraw method.

        :param theObj:
        :type theObj: Handle_AIS_InteractiveObject &
        :param theMode: default value is 0
        :type theMode: int
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_ImmediateAdd(self, *args)


    def EndImmediateDraw(self, *args) -> "Standard_Boolean":
        """
        * Allows rapid drawing of the view theView by avoiding an update of the whole background.

        :param theView:
        :type theView: Handle_V3d_View &
        :rtype: bool

        """
        return _AIS.AIS_LocalContext_EndImmediateDraw(self, *args)


    def IsImmediateModeOn(self, *args) -> "Standard_Boolean":
        """
        * Returns true if Presentation Manager is accumulating transient list of presentations to be displayed in immediate mode.

        :rtype: bool

        """
        return _AIS.AIS_LocalContext_IsImmediateModeOn(self, *args)


    def UpdateConversion(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_LocalContext_UpdateConversion(self, *args)


    def UpdateSort(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_LocalContext_UpdateSort(self, *args)


    def LoadContextObjects(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_LocalContext_LoadContextObjects(self, *args)


    def UnloadContextObjects(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_LocalContext_UnloadContextObjects(self, *args)


    def DisplayAreas(self, *args) -> "void":
        """
        :param aviou:
        :type aviou: Handle_V3d_View &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_DisplayAreas(self, *args)


    def ClearAreas(self, *args) -> "void":
        """
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_ClearAreas(self, *args)


    def DisplaySensitive(self, *args) -> "void":
        """
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_DisplaySensitive(self, *args)


    def ClearSensitive(self, *args) -> "void":
        """
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        return _AIS.AIS_LocalContext_ClearSensitive(self, *args)


    def MainSelector(self, *args) -> "Handle_StdSelect_ViewerSelector3d":
        """
        :rtype: Handle_StdSelect_ViewerSelector3d

        """
        return _AIS.AIS_LocalContext_MainSelector(self, *args)


    def FindSelectedOwnerFromIO(self, *args) -> "Handle_SelectMgr_EntityOwner":
        """
        :param anIObj:
        :type anIObj: Handle_AIS_InteractiveObject &
        :rtype: Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_LocalContext_FindSelectedOwnerFromIO(self, *args)


    def FindSelectedOwnerFromShape(self, *args) -> "Handle_SelectMgr_EntityOwner":
        """
        :param aShape:
        :type aShape: TopoDS_Shape &
        :rtype: Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_LocalContext_FindSelectedOwnerFromShape(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_LocalContext(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_LocalContext
AIS_LocalContext.AcceptErase = new_instancemethod(_AIS.AIS_LocalContext_AcceptErase, None, AIS_LocalContext)
AIS_LocalContext.SetContext = new_instancemethod(_AIS.AIS_LocalContext_SetContext, None, AIS_LocalContext)
AIS_LocalContext.SelectionName = new_instancemethod(_AIS.AIS_LocalContext_SelectionName, None, AIS_LocalContext)
AIS_LocalContext.Terminate = new_instancemethod(_AIS.AIS_LocalContext_Terminate, None, AIS_LocalContext)
AIS_LocalContext.HasSameProjector = new_instancemethod(_AIS.AIS_LocalContext_HasSameProjector, None, AIS_LocalContext)
AIS_LocalContext.Display = new_instancemethod(_AIS.AIS_LocalContext_Display, None, AIS_LocalContext)
AIS_LocalContext.Load = new_instancemethod(_AIS.AIS_LocalContext_Load, None, AIS_LocalContext)
AIS_LocalContext.Erase = new_instancemethod(_AIS.AIS_LocalContext_Erase, None, AIS_LocalContext)
AIS_LocalContext.Remove = new_instancemethod(_AIS.AIS_LocalContext_Remove, None, AIS_LocalContext)
AIS_LocalContext.ClearPrs = new_instancemethod(_AIS.AIS_LocalContext_ClearPrs, None, AIS_LocalContext)
AIS_LocalContext.SetShapeDecomposition = new_instancemethod(_AIS.AIS_LocalContext_SetShapeDecomposition, None, AIS_LocalContext)
AIS_LocalContext.Clear = new_instancemethod(_AIS.AIS_LocalContext_Clear, None, AIS_LocalContext)
AIS_LocalContext.ActivateMode = new_instancemethod(_AIS.AIS_LocalContext_ActivateMode, None, AIS_LocalContext)
AIS_LocalContext.DeactivateMode = new_instancemethod(_AIS.AIS_LocalContext_DeactivateMode, None, AIS_LocalContext)
AIS_LocalContext.Deactivate = new_instancemethod(_AIS.AIS_LocalContext_Deactivate, None, AIS_LocalContext)
AIS_LocalContext.ActivateStandardMode = new_instancemethod(_AIS.AIS_LocalContext_ActivateStandardMode, None, AIS_LocalContext)
AIS_LocalContext.DeactivateStandardMode = new_instancemethod(_AIS.AIS_LocalContext_DeactivateStandardMode, None, AIS_LocalContext)
AIS_LocalContext.StandardModes = new_instancemethod(_AIS.AIS_LocalContext_StandardModes, None, AIS_LocalContext)
AIS_LocalContext.AddFilter = new_instancemethod(_AIS.AIS_LocalContext_AddFilter, None, AIS_LocalContext)
AIS_LocalContext.RemoveFilter = new_instancemethod(_AIS.AIS_LocalContext_RemoveFilter, None, AIS_LocalContext)
AIS_LocalContext.ListOfFilter = new_instancemethod(_AIS.AIS_LocalContext_ListOfFilter, None, AIS_LocalContext)
AIS_LocalContext.Filter = new_instancemethod(_AIS.AIS_LocalContext_Filter, None, AIS_LocalContext)
AIS_LocalContext.SetAutomaticHilight = new_instancemethod(_AIS.AIS_LocalContext_SetAutomaticHilight, None, AIS_LocalContext)
AIS_LocalContext.AutomaticHilight = new_instancemethod(_AIS.AIS_LocalContext_AutomaticHilight, None, AIS_LocalContext)
AIS_LocalContext.MoveTo = new_instancemethod(_AIS.AIS_LocalContext_MoveTo, None, AIS_LocalContext)
AIS_LocalContext.HasNextDetected = new_instancemethod(_AIS.AIS_LocalContext_HasNextDetected, None, AIS_LocalContext)
AIS_LocalContext.HilightNextDetected = new_instancemethod(_AIS.AIS_LocalContext_HilightNextDetected, None, AIS_LocalContext)
AIS_LocalContext.HilightPreviousDetected = new_instancemethod(_AIS.AIS_LocalContext_HilightPreviousDetected, None, AIS_LocalContext)
AIS_LocalContext.UnhilightLastDetected = new_instancemethod(_AIS.AIS_LocalContext_UnhilightLastDetected, None, AIS_LocalContext)
AIS_LocalContext.Select = new_instancemethod(_AIS.AIS_LocalContext_Select, None, AIS_LocalContext)
AIS_LocalContext.ShiftSelect = new_instancemethod(_AIS.AIS_LocalContext_ShiftSelect, None, AIS_LocalContext)
AIS_LocalContext.HilightPicked = new_instancemethod(_AIS.AIS_LocalContext_HilightPicked, None, AIS_LocalContext)
AIS_LocalContext.UnhilightPicked = new_instancemethod(_AIS.AIS_LocalContext_UnhilightPicked, None, AIS_LocalContext)
AIS_LocalContext.UpdateSelected = new_instancemethod(_AIS.AIS_LocalContext_UpdateSelected, None, AIS_LocalContext)
AIS_LocalContext.SetSelected = new_instancemethod(_AIS.AIS_LocalContext_SetSelected, None, AIS_LocalContext)
AIS_LocalContext.AddOrRemoveSelected = new_instancemethod(_AIS.AIS_LocalContext_AddOrRemoveSelected, None, AIS_LocalContext)
AIS_LocalContext.ClearSelected = new_instancemethod(_AIS.AIS_LocalContext_ClearSelected, None, AIS_LocalContext)
AIS_LocalContext.ClearOutdatedSelection = new_instancemethod(_AIS.AIS_LocalContext_ClearOutdatedSelection, None, AIS_LocalContext)
AIS_LocalContext.HasDetected = new_instancemethod(_AIS.AIS_LocalContext_HasDetected, None, AIS_LocalContext)
AIS_LocalContext.InitDetected = new_instancemethod(_AIS.AIS_LocalContext_InitDetected, None, AIS_LocalContext)
AIS_LocalContext.MoreDetected = new_instancemethod(_AIS.AIS_LocalContext_MoreDetected, None, AIS_LocalContext)
AIS_LocalContext.NextDetected = new_instancemethod(_AIS.AIS_LocalContext_NextDetected, None, AIS_LocalContext)
AIS_LocalContext.DetectedCurrentShape = new_instancemethod(_AIS.AIS_LocalContext_DetectedCurrentShape, None, AIS_LocalContext)
AIS_LocalContext.DetectedCurrentObject = new_instancemethod(_AIS.AIS_LocalContext_DetectedCurrentObject, None, AIS_LocalContext)
AIS_LocalContext.HasDetectedShape = new_instancemethod(_AIS.AIS_LocalContext_HasDetectedShape, None, AIS_LocalContext)
AIS_LocalContext.DetectedShape = new_instancemethod(_AIS.AIS_LocalContext_DetectedShape, None, AIS_LocalContext)
AIS_LocalContext.DetectedInteractive = new_instancemethod(_AIS.AIS_LocalContext_DetectedInteractive, None, AIS_LocalContext)
AIS_LocalContext.DetectedOwner = new_instancemethod(_AIS.AIS_LocalContext_DetectedOwner, None, AIS_LocalContext)
AIS_LocalContext.InitSelected = new_instancemethod(_AIS.AIS_LocalContext_InitSelected, None, AIS_LocalContext)
AIS_LocalContext.MoreSelected = new_instancemethod(_AIS.AIS_LocalContext_MoreSelected, None, AIS_LocalContext)
AIS_LocalContext.NextSelected = new_instancemethod(_AIS.AIS_LocalContext_NextSelected, None, AIS_LocalContext)
AIS_LocalContext.HasShape = new_instancemethod(_AIS.AIS_LocalContext_HasShape, None, AIS_LocalContext)
AIS_LocalContext.SelectedShape = new_instancemethod(_AIS.AIS_LocalContext_SelectedShape, None, AIS_LocalContext)
AIS_LocalContext.SelectedOwner = new_instancemethod(_AIS.AIS_LocalContext_SelectedOwner, None, AIS_LocalContext)
AIS_LocalContext.IsSelected = new_instancemethod(_AIS.AIS_LocalContext_IsSelected, None, AIS_LocalContext)
AIS_LocalContext.SelectedInteractive = new_instancemethod(_AIS.AIS_LocalContext_SelectedInteractive, None, AIS_LocalContext)
AIS_LocalContext.HasApplicative = new_instancemethod(_AIS.AIS_LocalContext_HasApplicative, None, AIS_LocalContext)
AIS_LocalContext.SelectedApplicative = new_instancemethod(_AIS.AIS_LocalContext_SelectedApplicative, None, AIS_LocalContext)
AIS_LocalContext.SetDisplayPriority = new_instancemethod(_AIS.AIS_LocalContext_SetDisplayPriority, None, AIS_LocalContext)
AIS_LocalContext.SetZLayer = new_instancemethod(_AIS.AIS_LocalContext_SetZLayer, None, AIS_LocalContext)
AIS_LocalContext.GetZLayer = new_instancemethod(_AIS.AIS_LocalContext_GetZLayer, None, AIS_LocalContext)
AIS_LocalContext.DisplayedObjects = new_instancemethod(_AIS.AIS_LocalContext_DisplayedObjects, None, AIS_LocalContext)
AIS_LocalContext.IsIn = new_instancemethod(_AIS.AIS_LocalContext_IsIn, None, AIS_LocalContext)
AIS_LocalContext.IsDisplayed = new_instancemethod(_AIS.AIS_LocalContext_IsDisplayed, None, AIS_LocalContext)
AIS_LocalContext.SelectionModes = new_instancemethod(_AIS.AIS_LocalContext_SelectionModes, None, AIS_LocalContext)
AIS_LocalContext.SubIntensityOn = new_instancemethod(_AIS.AIS_LocalContext_SubIntensityOn, None, AIS_LocalContext)
AIS_LocalContext.SubIntensityOff = new_instancemethod(_AIS.AIS_LocalContext_SubIntensityOff, None, AIS_LocalContext)
AIS_LocalContext.Hilight = new_instancemethod(_AIS.AIS_LocalContext_Hilight, None, AIS_LocalContext)
AIS_LocalContext.Unhilight = new_instancemethod(_AIS.AIS_LocalContext_Unhilight, None, AIS_LocalContext)
AIS_LocalContext.IsHilighted = new_instancemethod(_AIS.AIS_LocalContext_IsHilighted, None, AIS_LocalContext)
AIS_LocalContext.SetSensitivityMode = new_instancemethod(_AIS.AIS_LocalContext_SetSensitivityMode, None, AIS_LocalContext)
AIS_LocalContext.SensitivityMode = new_instancemethod(_AIS.AIS_LocalContext_SensitivityMode, None, AIS_LocalContext)
AIS_LocalContext.SetSensitivity = new_instancemethod(_AIS.AIS_LocalContext_SetSensitivity, None, AIS_LocalContext)
AIS_LocalContext.Sensitivity = new_instancemethod(_AIS.AIS_LocalContext_Sensitivity, None, AIS_LocalContext)
AIS_LocalContext.SetPixelTolerance = new_instancemethod(_AIS.AIS_LocalContext_SetPixelTolerance, None, AIS_LocalContext)
AIS_LocalContext.PixelTolerance = new_instancemethod(_AIS.AIS_LocalContext_PixelTolerance, None, AIS_LocalContext)
AIS_LocalContext.BeginImmediateDraw = new_instancemethod(_AIS.AIS_LocalContext_BeginImmediateDraw, None, AIS_LocalContext)
AIS_LocalContext.ClearImmediateDraw = new_instancemethod(_AIS.AIS_LocalContext_ClearImmediateDraw, None, AIS_LocalContext)
AIS_LocalContext.ImmediateAdd = new_instancemethod(_AIS.AIS_LocalContext_ImmediateAdd, None, AIS_LocalContext)
AIS_LocalContext.EndImmediateDraw = new_instancemethod(_AIS.AIS_LocalContext_EndImmediateDraw, None, AIS_LocalContext)
AIS_LocalContext.IsImmediateModeOn = new_instancemethod(_AIS.AIS_LocalContext_IsImmediateModeOn, None, AIS_LocalContext)
AIS_LocalContext.UpdateConversion = new_instancemethod(_AIS.AIS_LocalContext_UpdateConversion, None, AIS_LocalContext)
AIS_LocalContext.UpdateSort = new_instancemethod(_AIS.AIS_LocalContext_UpdateSort, None, AIS_LocalContext)
AIS_LocalContext.LoadContextObjects = new_instancemethod(_AIS.AIS_LocalContext_LoadContextObjects, None, AIS_LocalContext)
AIS_LocalContext.UnloadContextObjects = new_instancemethod(_AIS.AIS_LocalContext_UnloadContextObjects, None, AIS_LocalContext)
AIS_LocalContext.DisplayAreas = new_instancemethod(_AIS.AIS_LocalContext_DisplayAreas, None, AIS_LocalContext)
AIS_LocalContext.ClearAreas = new_instancemethod(_AIS.AIS_LocalContext_ClearAreas, None, AIS_LocalContext)
AIS_LocalContext.DisplaySensitive = new_instancemethod(_AIS.AIS_LocalContext_DisplaySensitive, None, AIS_LocalContext)
AIS_LocalContext.ClearSensitive = new_instancemethod(_AIS.AIS_LocalContext_ClearSensitive, None, AIS_LocalContext)
AIS_LocalContext.MainSelector = new_instancemethod(_AIS.AIS_LocalContext_MainSelector, None, AIS_LocalContext)
AIS_LocalContext.FindSelectedOwnerFromIO = new_instancemethod(_AIS.AIS_LocalContext_FindSelectedOwnerFromIO, None, AIS_LocalContext)
AIS_LocalContext.FindSelectedOwnerFromShape = new_instancemethod(_AIS.AIS_LocalContext_FindSelectedOwnerFromShape, None, AIS_LocalContext)
AIS_LocalContext_swigregister = _AIS.AIS_LocalContext_swigregister
AIS_LocalContext_swigregister(AIS_LocalContext)

class Handle_AIS_LocalContext(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_LocalContext_swiginit(self, _AIS.new_Handle_AIS_LocalContext(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_LocalContext_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_LocalContext
Handle_AIS_LocalContext.Nullify = new_instancemethod(_AIS.Handle_AIS_LocalContext_Nullify, None, Handle_AIS_LocalContext)
Handle_AIS_LocalContext.IsNull = new_instancemethod(_AIS.Handle_AIS_LocalContext_IsNull, None, Handle_AIS_LocalContext)
Handle_AIS_LocalContext._get_reference = new_instancemethod(_AIS.Handle_AIS_LocalContext__get_reference, None, Handle_AIS_LocalContext)
Handle_AIS_LocalContext_swigregister = _AIS.Handle_AIS_LocalContext_swigregister
Handle_AIS_LocalContext_swigregister(Handle_AIS_LocalContext)

def Handle_AIS_LocalContext_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_LocalContext const":
    return _AIS.Handle_AIS_LocalContext_DownCast(AnObject)
Handle_AIS_LocalContext_DownCast = _AIS.Handle_AIS_LocalContext_DownCast

class AIS_LocalStatus(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param IsTemporary: default value is Standard_True
        :type IsTemporary: bool
        :param Decompose: default value is Standard_False
        :type Decompose: bool
        :param DisplayMode: default value is -1
        :type DisplayMode: int
        :param SelectionMode: default value is -1
        :type SelectionMode: int
        :param HilightMode: default value is 0
        :type HilightMode: int
        :param SubIntensity: default value is 0
        :type SubIntensity: bool
        :param TheHiCol: default value is Quantity_NOC_WHITE
        :type TheHiCol: Quantity_NameOfColor
        :rtype: None

        """
        _AIS.AIS_LocalStatus_swiginit(self, _AIS.new_AIS_LocalStatus(*args))

    def Decomposed(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_LocalStatus_Decomposed(self, *args)


    def IsTemporary(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_LocalStatus_IsTemporary(self, *args)


    def DisplayMode(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _AIS.AIS_LocalStatus_DisplayMode(self, *args)


    def SelectionModes(self, *args) -> "TColStd_ListOfInteger const &":
        """
        :rtype: TColStd_ListOfInteger

        """
        return _AIS.AIS_LocalStatus_SelectionModes(self, *args)


    def IsActivated(self, *args) -> "Standard_Boolean":
        """
        :param aSelMode:
        :type aSelMode: int
        :rtype: bool

        """
        return _AIS.AIS_LocalStatus_IsActivated(self, *args)


    def HilightMode(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _AIS.AIS_LocalStatus_HilightMode(self, *args)


    def IsSubIntensityOn(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_LocalStatus_IsSubIntensityOn(self, *args)


    def HilightColor(self, *args) -> "Quantity_NameOfColor":
        """
        :rtype: Quantity_NameOfColor

        """
        return _AIS.AIS_LocalStatus_HilightColor(self, *args)


    def SetDecomposition(self, *args) -> "void":
        """
        :param astatus:
        :type astatus: bool
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_SetDecomposition(self, *args)


    def SetTemporary(self, *args) -> "void":
        """
        :param astatus:
        :type astatus: bool
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_SetTemporary(self, *args)


    def SetDisplayMode(self, *args) -> "void":
        """
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_SetDisplayMode(self, *args)


    def SetFirstDisplay(self, *args) -> "void":
        """
        :param aStatus:
        :type aStatus: bool
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_SetFirstDisplay(self, *args)


    def IsFirstDisplay(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_LocalStatus_IsFirstDisplay(self, *args)


    def AddSelectionMode(self, *args) -> "void":
        """
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_AddSelectionMode(self, *args)


    def RemoveSelectionMode(self, *args) -> "void":
        """
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_RemoveSelectionMode(self, *args)


    def ClearSelectionModes(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_ClearSelectionModes(self, *args)


    def IsSelModeIn(self, *args) -> "Standard_Boolean":
        """
        :param aMode:
        :type aMode: int
        :rtype: bool

        """
        return _AIS.AIS_LocalStatus_IsSelModeIn(self, *args)


    def SetHilightMode(self, *args) -> "void":
        """
        :param aMode:
        :type aMode: int
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_SetHilightMode(self, *args)


    def SetHilightColor(self, *args) -> "void":
        """
        :param aHiCol:
        :type aHiCol: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_SetHilightColor(self, *args)


    def SubIntensityOn(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_SubIntensityOff(self, *args)


    def SetPreviousState(self, *args) -> "void":
        """
        :param aStatus:
        :type aStatus: Handle_Standard_Transient &
        :rtype: None

        """
        return _AIS.AIS_LocalStatus_SetPreviousState(self, *args)


    def PreviousState(self, *args) -> "Handle_Standard_Transient":
        """
        :rtype: Handle_Standard_Transient

        """
        return _AIS.AIS_LocalStatus_PreviousState(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_LocalStatus(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_LocalStatus
AIS_LocalStatus.Decomposed = new_instancemethod(_AIS.AIS_LocalStatus_Decomposed, None, AIS_LocalStatus)
AIS_LocalStatus.IsTemporary = new_instancemethod(_AIS.AIS_LocalStatus_IsTemporary, None, AIS_LocalStatus)
AIS_LocalStatus.DisplayMode = new_instancemethod(_AIS.AIS_LocalStatus_DisplayMode, None, AIS_LocalStatus)
AIS_LocalStatus.SelectionModes = new_instancemethod(_AIS.AIS_LocalStatus_SelectionModes, None, AIS_LocalStatus)
AIS_LocalStatus.IsActivated = new_instancemethod(_AIS.AIS_LocalStatus_IsActivated, None, AIS_LocalStatus)
AIS_LocalStatus.HilightMode = new_instancemethod(_AIS.AIS_LocalStatus_HilightMode, None, AIS_LocalStatus)
AIS_LocalStatus.IsSubIntensityOn = new_instancemethod(_AIS.AIS_LocalStatus_IsSubIntensityOn, None, AIS_LocalStatus)
AIS_LocalStatus.HilightColor = new_instancemethod(_AIS.AIS_LocalStatus_HilightColor, None, AIS_LocalStatus)
AIS_LocalStatus.SetDecomposition = new_instancemethod(_AIS.AIS_LocalStatus_SetDecomposition, None, AIS_LocalStatus)
AIS_LocalStatus.SetTemporary = new_instancemethod(_AIS.AIS_LocalStatus_SetTemporary, None, AIS_LocalStatus)
AIS_LocalStatus.SetDisplayMode = new_instancemethod(_AIS.AIS_LocalStatus_SetDisplayMode, None, AIS_LocalStatus)
AIS_LocalStatus.SetFirstDisplay = new_instancemethod(_AIS.AIS_LocalStatus_SetFirstDisplay, None, AIS_LocalStatus)
AIS_LocalStatus.IsFirstDisplay = new_instancemethod(_AIS.AIS_LocalStatus_IsFirstDisplay, None, AIS_LocalStatus)
AIS_LocalStatus.AddSelectionMode = new_instancemethod(_AIS.AIS_LocalStatus_AddSelectionMode, None, AIS_LocalStatus)
AIS_LocalStatus.RemoveSelectionMode = new_instancemethod(_AIS.AIS_LocalStatus_RemoveSelectionMode, None, AIS_LocalStatus)
AIS_LocalStatus.ClearSelectionModes = new_instancemethod(_AIS.AIS_LocalStatus_ClearSelectionModes, None, AIS_LocalStatus)
AIS_LocalStatus.IsSelModeIn = new_instancemethod(_AIS.AIS_LocalStatus_IsSelModeIn, None, AIS_LocalStatus)
AIS_LocalStatus.SetHilightMode = new_instancemethod(_AIS.AIS_LocalStatus_SetHilightMode, None, AIS_LocalStatus)
AIS_LocalStatus.SetHilightColor = new_instancemethod(_AIS.AIS_LocalStatus_SetHilightColor, None, AIS_LocalStatus)
AIS_LocalStatus.SubIntensityOn = new_instancemethod(_AIS.AIS_LocalStatus_SubIntensityOn, None, AIS_LocalStatus)
AIS_LocalStatus.SubIntensityOff = new_instancemethod(_AIS.AIS_LocalStatus_SubIntensityOff, None, AIS_LocalStatus)
AIS_LocalStatus.SetPreviousState = new_instancemethod(_AIS.AIS_LocalStatus_SetPreviousState, None, AIS_LocalStatus)
AIS_LocalStatus.PreviousState = new_instancemethod(_AIS.AIS_LocalStatus_PreviousState, None, AIS_LocalStatus)
AIS_LocalStatus_swigregister = _AIS.AIS_LocalStatus_swigregister
AIS_LocalStatus_swigregister(AIS_LocalStatus)

class Handle_AIS_LocalStatus(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_LocalStatus_swiginit(self, _AIS.new_Handle_AIS_LocalStatus(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_LocalStatus_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_LocalStatus
Handle_AIS_LocalStatus.Nullify = new_instancemethod(_AIS.Handle_AIS_LocalStatus_Nullify, None, Handle_AIS_LocalStatus)
Handle_AIS_LocalStatus.IsNull = new_instancemethod(_AIS.Handle_AIS_LocalStatus_IsNull, None, Handle_AIS_LocalStatus)
Handle_AIS_LocalStatus._get_reference = new_instancemethod(_AIS.Handle_AIS_LocalStatus__get_reference, None, Handle_AIS_LocalStatus)
Handle_AIS_LocalStatus_swigregister = _AIS.Handle_AIS_LocalStatus_swigregister
Handle_AIS_LocalStatus_swigregister(Handle_AIS_LocalStatus)

def Handle_AIS_LocalStatus_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_LocalStatus const":
    return _AIS.Handle_AIS_LocalStatus_DownCast(AnObject)
Handle_AIS_LocalStatus_DownCast = _AIS.Handle_AIS_LocalStatus_DownCast

class AIS_MapIteratorOfMapOfInteractive(OCC.TCollection.TCollection_BasicMapIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param aMap:
        :type aMap: AIS_MapOfInteractive &
        :rtype: None

        """
        _AIS.AIS_MapIteratorOfMapOfInteractive_swiginit(self, _AIS.new_AIS_MapIteratorOfMapOfInteractive(*args))

    def Initialize(self, *args) -> "void":
        """
        :param aMap:
        :type aMap: AIS_MapOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_MapIteratorOfMapOfInteractive_Initialize(self, *args)


    def Key(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_MapIteratorOfMapOfInteractive_Key(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_MapIteratorOfMapOfInteractive
AIS_MapIteratorOfMapOfInteractive.Initialize = new_instancemethod(_AIS.AIS_MapIteratorOfMapOfInteractive_Initialize, None, AIS_MapIteratorOfMapOfInteractive)
AIS_MapIteratorOfMapOfInteractive.Key = new_instancemethod(_AIS.AIS_MapIteratorOfMapOfInteractive_Key, None, AIS_MapIteratorOfMapOfInteractive)
AIS_MapIteratorOfMapOfInteractive_swigregister = _AIS.AIS_MapIteratorOfMapOfInteractive_swigregister
AIS_MapIteratorOfMapOfInteractive_swigregister(AIS_MapIteratorOfMapOfInteractive)

class AIS_MapOfInteractive(OCC.TCollection.TCollection_BasicMap):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param NbBuckets: default value is 1
        :type NbBuckets: int
        :rtype: None

        :param Other:
        :type Other: AIS_MapOfInteractive &
        :rtype: None

        """
        _AIS.AIS_MapOfInteractive_swiginit(self, _AIS.new_AIS_MapOfInteractive(*args))

    def Assign(self, *args) -> "AIS_MapOfInteractive &":
        """
        :param Other:
        :type Other: AIS_MapOfInteractive &
        :rtype: AIS_MapOfInteractive

        """
        return _AIS.AIS_MapOfInteractive_Assign(self, *args)


    def Set(self, *args) -> "AIS_MapOfInteractive &":
        """
        :param Other:
        :type Other: AIS_MapOfInteractive &
        :rtype: AIS_MapOfInteractive

        """
        return _AIS.AIS_MapOfInteractive_Set(self, *args)


    def ReSize(self, *args) -> "void":
        """
        :param NbBuckets:
        :type NbBuckets: int
        :rtype: None

        """
        return _AIS.AIS_MapOfInteractive_ReSize(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_MapOfInteractive_Clear(self, *args)


    def Add(self, *args) -> "Standard_Boolean":
        """
        :param aKey:
        :type aKey: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_MapOfInteractive_Add(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        :param aKey:
        :type aKey: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_MapOfInteractive_Contains(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        :param aKey:
        :type aKey: Handle_AIS_InteractiveObject &
        :rtype: bool

        """
        return _AIS.AIS_MapOfInteractive_Remove(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_MapOfInteractive
AIS_MapOfInteractive.Assign = new_instancemethod(_AIS.AIS_MapOfInteractive_Assign, None, AIS_MapOfInteractive)
AIS_MapOfInteractive.Set = new_instancemethod(_AIS.AIS_MapOfInteractive_Set, None, AIS_MapOfInteractive)
AIS_MapOfInteractive.ReSize = new_instancemethod(_AIS.AIS_MapOfInteractive_ReSize, None, AIS_MapOfInteractive)
AIS_MapOfInteractive.Clear = new_instancemethod(_AIS.AIS_MapOfInteractive_Clear, None, AIS_MapOfInteractive)
AIS_MapOfInteractive.Add = new_instancemethod(_AIS.AIS_MapOfInteractive_Add, None, AIS_MapOfInteractive)
AIS_MapOfInteractive.Contains = new_instancemethod(_AIS.AIS_MapOfInteractive_Contains, None, AIS_MapOfInteractive)
AIS_MapOfInteractive.Remove = new_instancemethod(_AIS.AIS_MapOfInteractive_Remove, None, AIS_MapOfInteractive)
AIS_MapOfInteractive_swigregister = _AIS.AIS_MapOfInteractive_swigregister
AIS_MapOfInteractive_swigregister(AIS_MapOfInteractive)

class AIS_Selection(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * creates a new selection and make it current in the session. the selection will be accessible later through its name to make it again current. //! Note that if a session has been created, a session with the name 'default' is created. //! In this case, the is always a current selection which is the last one created until SetCurrentSelection is used. //! The class methods deals with the current selection. //! Warning : Better Call AIS_Selection::CreateSelection.

        :param aName:
        :type aName: char *
        :rtype: None

        """
        _AIS.AIS_Selection_swiginit(self, _AIS.new_AIS_Selection(*args))

    def Remove(*args) -> "void":
        """
        :param aName:
        :type aName: char *
        :rtype: void

        """
        return _AIS.AIS_Selection_Remove(*args)

    Remove = staticmethod(Remove)

    def Find(*args) -> "Standard_Boolean":
        """
        * returns True if a selection having this name exsits.

        :param aName:
        :type aName: char *
        :rtype: bool

        """
        return _AIS.AIS_Selection_Find(*args)

    Find = staticmethod(Find)

    def CreateSelection(*args) -> "Standard_Boolean":
        """
        * calls the private constructor and puts the new Selection in the list of existing selections. returns False if the selection exists.

        :param aName:
        :type aName: char *
        :rtype: bool

        """
        return _AIS.AIS_Selection_CreateSelection(*args)

    CreateSelection = staticmethod(CreateSelection)

    def Selection(*args) -> "Handle_AIS_Selection":
        """
        :param aName:
        :type aName: char *
        :rtype: Handle_AIS_Selection

        """
        return _AIS.AIS_Selection_Selection(*args)

    Selection = staticmethod(Selection)

    def SetCurrentSelection(*args) -> "Standard_Boolean":
        """
        * returns False if There is no selection of name <aName>

        :param aName:
        :type aName: char *
        :rtype: bool

        """
        return _AIS.AIS_Selection_SetCurrentSelection(*args)

    SetCurrentSelection = staticmethod(SetCurrentSelection)

    def CurrentSelection(*args) -> "Handle_AIS_Selection":
        """
        :rtype: Handle_AIS_Selection

        """
        return _AIS.AIS_Selection_CurrentSelection(*args)

    CurrentSelection = staticmethod(CurrentSelection)

    def ClearCurrentSelection(*args) -> "void":
        """
        * Clears selection.

        :rtype: void

        """
        return _AIS.AIS_Selection_ClearCurrentSelection(*args)

    ClearCurrentSelection = staticmethod(ClearCurrentSelection)

    def Select(*args) -> "AIS_SelectStatus":
        """
        * removes all the object of the currentselection.

        :rtype: void

        * if the object is not yet in the current selection, it will be added. if the object is already in the current selection, it will be removed.

        :param anObject:
        :type anObject: Handle_Standard_Transient &
        :rtype: AIS_SelectStatus

        """
        return _AIS.AIS_Selection_Select(*args)

    Select = staticmethod(Select)

    def AddSelect(*args) -> "AIS_SelectStatus":
        """
        * the object is always add int the selection. faster when the number of objects selected is great.

        :param anObject:
        :type anObject: Handle_Standard_Transient &
        :rtype: AIS_SelectStatus

        """
        return _AIS.AIS_Selection_AddSelect(*args)

    AddSelect = staticmethod(AddSelect)

    def ClearAndSelect(*args) -> "void":
        """
        * clears the selection and adds the object in the selection.

        :param anObject:
        :type anObject: Handle_Standard_Transient &
        :rtype: void

        """
        return _AIS.AIS_Selection_ClearAndSelect(*args)

    ClearAndSelect = staticmethod(ClearAndSelect)

    def IsSelected(*args) -> "Standard_Boolean":
        """
        :param anObject:
        :type anObject: Handle_Standard_Transient &
        :rtype: bool

        """
        return _AIS.AIS_Selection_IsSelected(*args)

    IsSelected = staticmethod(IsSelected)

    def Extent(*args) -> "Standard_Integer":
        """
        * returns the number of objects selected.

        :rtype: int

        """
        return _AIS.AIS_Selection_Extent(*args)

    Extent = staticmethod(Extent)

    def Single(*args) -> "Handle_Standard_Transient":
        """
        * returns the single object selected. Warning: raises TypeMismatch from Standard if Extent is not equal to 1.

        :rtype: Handle_Standard_Transient

        """
        return _AIS.AIS_Selection_Single(*args)

    Single = staticmethod(Single)

    def Init(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_Selection_Init(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Selection_More(self, *args)


    def Next(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_Selection_Next(self, *args)


    def Value(self, *args) -> "Handle_Standard_Transient":
        """
        :rtype: Handle_Standard_Transient

        """
        return _AIS.AIS_Selection_Value(self, *args)


    def NbStored(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _AIS.AIS_Selection_NbStored(self, *args)


    def Objects(self, *args) -> "AIS_NListTransient const &":
        """
        :rtype: AIS_NListTransient

        """
        return _AIS.AIS_Selection_Objects(self, *args)


    def Index(*args) -> "Standard_Integer":
        """
        :param aName:
        :type aName: char *
        :rtype: int

        """
        return _AIS.AIS_Selection_Index(*args)

    Index = staticmethod(Index)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Selection(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Selection
AIS_Selection.Init = new_instancemethod(_AIS.AIS_Selection_Init, None, AIS_Selection)
AIS_Selection.More = new_instancemethod(_AIS.AIS_Selection_More, None, AIS_Selection)
AIS_Selection.Next = new_instancemethod(_AIS.AIS_Selection_Next, None, AIS_Selection)
AIS_Selection.Value = new_instancemethod(_AIS.AIS_Selection_Value, None, AIS_Selection)
AIS_Selection.NbStored = new_instancemethod(_AIS.AIS_Selection_NbStored, None, AIS_Selection)
AIS_Selection.Objects = new_instancemethod(_AIS.AIS_Selection_Objects, None, AIS_Selection)
AIS_Selection_swigregister = _AIS.AIS_Selection_swigregister
AIS_Selection_swigregister(AIS_Selection)

def AIS_Selection_Remove(*args) -> "void":
    """
    :param aName:
    :type aName: char *
    :rtype: void

    """
    return _AIS.AIS_Selection_Remove(*args)

def AIS_Selection_Find(*args) -> "Standard_Boolean":
    """
    * returns True if a selection having this name exsits.

    :param aName:
    :type aName: char *
    :rtype: bool

    """
    return _AIS.AIS_Selection_Find(*args)

def AIS_Selection_CreateSelection(*args) -> "Standard_Boolean":
    """
    * calls the private constructor and puts the new Selection in the list of existing selections. returns False if the selection exists.

    :param aName:
    :type aName: char *
    :rtype: bool

    """
    return _AIS.AIS_Selection_CreateSelection(*args)

def AIS_Selection_Selection(*args) -> "Handle_AIS_Selection":
    """
    :param aName:
    :type aName: char *
    :rtype: Handle_AIS_Selection

    """
    return _AIS.AIS_Selection_Selection(*args)

def AIS_Selection_SetCurrentSelection(*args) -> "Standard_Boolean":
    """
    * returns False if There is no selection of name <aName>

    :param aName:
    :type aName: char *
    :rtype: bool

    """
    return _AIS.AIS_Selection_SetCurrentSelection(*args)

def AIS_Selection_CurrentSelection(*args) -> "Handle_AIS_Selection":
    """
    :rtype: Handle_AIS_Selection

    """
    return _AIS.AIS_Selection_CurrentSelection(*args)

def AIS_Selection_ClearCurrentSelection(*args) -> "void":
    """
    * Clears selection.

    :rtype: void

    """
    return _AIS.AIS_Selection_ClearCurrentSelection(*args)

def AIS_Selection_Select(*args) -> "AIS_SelectStatus":
    """
    * removes all the object of the currentselection.

    :rtype: void

    * if the object is not yet in the current selection, it will be added. if the object is already in the current selection, it will be removed.

    :param anObject:
    :type anObject: Handle_Standard_Transient &
    :rtype: AIS_SelectStatus

    """
    return _AIS.AIS_Selection_Select(*args)

def AIS_Selection_AddSelect(*args) -> "AIS_SelectStatus":
    """
    * the object is always add int the selection. faster when the number of objects selected is great.

    :param anObject:
    :type anObject: Handle_Standard_Transient &
    :rtype: AIS_SelectStatus

    """
    return _AIS.AIS_Selection_AddSelect(*args)

def AIS_Selection_ClearAndSelect(*args) -> "void":
    """
    * clears the selection and adds the object in the selection.

    :param anObject:
    :type anObject: Handle_Standard_Transient &
    :rtype: void

    """
    return _AIS.AIS_Selection_ClearAndSelect(*args)

def AIS_Selection_IsSelected(*args) -> "Standard_Boolean":
    """
    :param anObject:
    :type anObject: Handle_Standard_Transient &
    :rtype: bool

    """
    return _AIS.AIS_Selection_IsSelected(*args)

def AIS_Selection_Extent(*args) -> "Standard_Integer":
    """
    * returns the number of objects selected.

    :rtype: int

    """
    return _AIS.AIS_Selection_Extent(*args)

def AIS_Selection_Single(*args) -> "Handle_Standard_Transient":
    """
    * returns the single object selected. Warning: raises TypeMismatch from Standard if Extent is not equal to 1.

    :rtype: Handle_Standard_Transient

    """
    return _AIS.AIS_Selection_Single(*args)

def AIS_Selection_Index(*args) -> "Standard_Integer":
    """
    :param aName:
    :type aName: char *
    :rtype: int

    """
    return _AIS.AIS_Selection_Index(*args)

class Handle_AIS_Selection(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Selection_swiginit(self, _AIS.new_Handle_AIS_Selection(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Selection_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Selection
Handle_AIS_Selection.Nullify = new_instancemethod(_AIS.Handle_AIS_Selection_Nullify, None, Handle_AIS_Selection)
Handle_AIS_Selection.IsNull = new_instancemethod(_AIS.Handle_AIS_Selection_IsNull, None, Handle_AIS_Selection)
Handle_AIS_Selection._get_reference = new_instancemethod(_AIS.Handle_AIS_Selection__get_reference, None, Handle_AIS_Selection)
Handle_AIS_Selection_swigregister = _AIS.Handle_AIS_Selection_swigregister
Handle_AIS_Selection_swigregister(Handle_AIS_Selection)

def Handle_AIS_Selection_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Selection const":
    return _AIS.Handle_AIS_Selection_DownCast(AnObject)
Handle_AIS_Selection_DownCast = _AIS.Handle_AIS_Selection_DownCast

class AIS_SequenceNodeOfSequenceOfDimension(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: Handle_AIS_Relation &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _AIS.AIS_SequenceNodeOfSequenceOfDimension_swiginit(self, _AIS.new_AIS_SequenceNodeOfSequenceOfDimension(*args))

    def Value(self, *args) -> "Handle_AIS_Relation":
        """
        :rtype: Handle_AIS_Relation

        """
        return _AIS.AIS_SequenceNodeOfSequenceOfDimension_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_SequenceNodeOfSequenceOfDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_SequenceNodeOfSequenceOfDimension
AIS_SequenceNodeOfSequenceOfDimension.Value = new_instancemethod(_AIS.AIS_SequenceNodeOfSequenceOfDimension_Value, None, AIS_SequenceNodeOfSequenceOfDimension)
AIS_SequenceNodeOfSequenceOfDimension_swigregister = _AIS.AIS_SequenceNodeOfSequenceOfDimension_swigregister
AIS_SequenceNodeOfSequenceOfDimension_swigregister(AIS_SequenceNodeOfSequenceOfDimension)

class Handle_AIS_SequenceNodeOfSequenceOfDimension(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_SequenceNodeOfSequenceOfDimension_swiginit(self, _AIS.new_Handle_AIS_SequenceNodeOfSequenceOfDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_SequenceNodeOfSequenceOfDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_SequenceNodeOfSequenceOfDimension
Handle_AIS_SequenceNodeOfSequenceOfDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_SequenceNodeOfSequenceOfDimension_Nullify, None, Handle_AIS_SequenceNodeOfSequenceOfDimension)
Handle_AIS_SequenceNodeOfSequenceOfDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_SequenceNodeOfSequenceOfDimension_IsNull, None, Handle_AIS_SequenceNodeOfSequenceOfDimension)
Handle_AIS_SequenceNodeOfSequenceOfDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_SequenceNodeOfSequenceOfDimension__get_reference, None, Handle_AIS_SequenceNodeOfSequenceOfDimension)
Handle_AIS_SequenceNodeOfSequenceOfDimension_swigregister = _AIS.Handle_AIS_SequenceNodeOfSequenceOfDimension_swigregister
Handle_AIS_SequenceNodeOfSequenceOfDimension_swigregister(Handle_AIS_SequenceNodeOfSequenceOfDimension)

def Handle_AIS_SequenceNodeOfSequenceOfDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_SequenceNodeOfSequenceOfDimension const":
    return _AIS.Handle_AIS_SequenceNodeOfSequenceOfDimension_DownCast(AnObject)
Handle_AIS_SequenceNodeOfSequenceOfDimension_DownCast = _AIS.Handle_AIS_SequenceNodeOfSequenceOfDimension_DownCast

class AIS_SequenceNodeOfSequenceOfInteractive(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: Handle_AIS_InteractiveObject &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _AIS.AIS_SequenceNodeOfSequenceOfInteractive_swiginit(self, _AIS.new_AIS_SequenceNodeOfSequenceOfInteractive(*args))

    def Value(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_SequenceNodeOfSequenceOfInteractive_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_SequenceNodeOfSequenceOfInteractive(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_SequenceNodeOfSequenceOfInteractive
AIS_SequenceNodeOfSequenceOfInteractive.Value = new_instancemethod(_AIS.AIS_SequenceNodeOfSequenceOfInteractive_Value, None, AIS_SequenceNodeOfSequenceOfInteractive)
AIS_SequenceNodeOfSequenceOfInteractive_swigregister = _AIS.AIS_SequenceNodeOfSequenceOfInteractive_swigregister
AIS_SequenceNodeOfSequenceOfInteractive_swigregister(AIS_SequenceNodeOfSequenceOfInteractive)

class Handle_AIS_SequenceNodeOfSequenceOfInteractive(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_SequenceNodeOfSequenceOfInteractive_swiginit(self, _AIS.new_Handle_AIS_SequenceNodeOfSequenceOfInteractive(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_SequenceNodeOfSequenceOfInteractive_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_SequenceNodeOfSequenceOfInteractive
Handle_AIS_SequenceNodeOfSequenceOfInteractive.Nullify = new_instancemethod(_AIS.Handle_AIS_SequenceNodeOfSequenceOfInteractive_Nullify, None, Handle_AIS_SequenceNodeOfSequenceOfInteractive)
Handle_AIS_SequenceNodeOfSequenceOfInteractive.IsNull = new_instancemethod(_AIS.Handle_AIS_SequenceNodeOfSequenceOfInteractive_IsNull, None, Handle_AIS_SequenceNodeOfSequenceOfInteractive)
Handle_AIS_SequenceNodeOfSequenceOfInteractive._get_reference = new_instancemethod(_AIS.Handle_AIS_SequenceNodeOfSequenceOfInteractive__get_reference, None, Handle_AIS_SequenceNodeOfSequenceOfInteractive)
Handle_AIS_SequenceNodeOfSequenceOfInteractive_swigregister = _AIS.Handle_AIS_SequenceNodeOfSequenceOfInteractive_swigregister
Handle_AIS_SequenceNodeOfSequenceOfInteractive_swigregister(Handle_AIS_SequenceNodeOfSequenceOfInteractive)

def Handle_AIS_SequenceNodeOfSequenceOfInteractive_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_SequenceNodeOfSequenceOfInteractive const":
    return _AIS.Handle_AIS_SequenceNodeOfSequenceOfInteractive_DownCast(AnObject)
Handle_AIS_SequenceNodeOfSequenceOfInteractive_DownCast = _AIS.Handle_AIS_SequenceNodeOfSequenceOfInteractive_DownCast

class AIS_SequenceOfDimension(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Other:
        :type Other: AIS_SequenceOfDimension &
        :rtype: None

        """
        _AIS.AIS_SequenceOfDimension_swiginit(self, _AIS.new_AIS_SequenceOfDimension(*args))

    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_SequenceOfDimension_Clear(self, *args)


    def Assign(self, *args) -> "AIS_SequenceOfDimension const &":
        """
        :param Other:
        :type Other: AIS_SequenceOfDimension &
        :rtype: AIS_SequenceOfDimension

        """
        return _AIS.AIS_SequenceOfDimension_Assign(self, *args)


    def Set(self, *args) -> "AIS_SequenceOfDimension const &":
        """
        :param Other:
        :type Other: AIS_SequenceOfDimension &
        :rtype: AIS_SequenceOfDimension

        """
        return _AIS.AIS_SequenceOfDimension_Set(self, *args)


    def Append(self, *args) -> "void":
        """
        :param T:
        :type T: Handle_AIS_Relation &
        :rtype: None

        :param S:
        :type S: AIS_SequenceOfDimension &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfDimension_Append(self, *args)


    def Prepend(self, *args) -> "void":
        """
        :param T:
        :type T: Handle_AIS_Relation &
        :rtype: None

        :param S:
        :type S: AIS_SequenceOfDimension &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfDimension_Prepend(self, *args)


    def InsertBefore(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_AIS_Relation &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: AIS_SequenceOfDimension &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfDimension_InsertBefore(self, *args)


    def InsertAfter(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_AIS_Relation &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: AIS_SequenceOfDimension &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfDimension_InsertAfter(self, *args)


    def First(self, *args) -> "Handle_AIS_Relation":
        """
        :rtype: Handle_AIS_Relation

        """
        return _AIS.AIS_SequenceOfDimension_First(self, *args)


    def Last(self, *args) -> "Handle_AIS_Relation":
        """
        :rtype: Handle_AIS_Relation

        """
        return _AIS.AIS_SequenceOfDimension_Last(self, *args)


    def Split(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: AIS_SequenceOfDimension &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfDimension_Split(self, *args)


    def Value(self, *args) -> "Handle_AIS_Relation":
        """
        :param Index:
        :type Index: int
        :rtype: Handle_AIS_Relation

        """
        return _AIS.AIS_SequenceOfDimension_Value(self, *args)


    def SetValue(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_AIS_Relation &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfDimension_SetValue(self, *args)


    def ChangeValue(self, *args) -> "Handle_AIS_Relation":
        """
        :param Index:
        :type Index: int
        :rtype: Handle_AIS_Relation

        """
        return _AIS.AIS_SequenceOfDimension_ChangeValue(self, *args)


    def Remove(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _AIS.AIS_SequenceOfDimension_Remove(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_SequenceOfDimension
AIS_SequenceOfDimension.Clear = new_instancemethod(_AIS.AIS_SequenceOfDimension_Clear, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.Assign = new_instancemethod(_AIS.AIS_SequenceOfDimension_Assign, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.Set = new_instancemethod(_AIS.AIS_SequenceOfDimension_Set, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.Append = new_instancemethod(_AIS.AIS_SequenceOfDimension_Append, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.Prepend = new_instancemethod(_AIS.AIS_SequenceOfDimension_Prepend, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.InsertBefore = new_instancemethod(_AIS.AIS_SequenceOfDimension_InsertBefore, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.InsertAfter = new_instancemethod(_AIS.AIS_SequenceOfDimension_InsertAfter, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.First = new_instancemethod(_AIS.AIS_SequenceOfDimension_First, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.Last = new_instancemethod(_AIS.AIS_SequenceOfDimension_Last, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.Split = new_instancemethod(_AIS.AIS_SequenceOfDimension_Split, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.Value = new_instancemethod(_AIS.AIS_SequenceOfDimension_Value, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.SetValue = new_instancemethod(_AIS.AIS_SequenceOfDimension_SetValue, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.ChangeValue = new_instancemethod(_AIS.AIS_SequenceOfDimension_ChangeValue, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension.Remove = new_instancemethod(_AIS.AIS_SequenceOfDimension_Remove, None, AIS_SequenceOfDimension)
AIS_SequenceOfDimension_swigregister = _AIS.AIS_SequenceOfDimension_swigregister
AIS_SequenceOfDimension_swigregister(AIS_SequenceOfDimension)

class AIS_SequenceOfInteractive(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Other:
        :type Other: AIS_SequenceOfInteractive &
        :rtype: None

        """
        _AIS.AIS_SequenceOfInteractive_swiginit(self, _AIS.new_AIS_SequenceOfInteractive(*args))

    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_SequenceOfInteractive_Clear(self, *args)


    def Assign(self, *args) -> "AIS_SequenceOfInteractive const &":
        """
        :param Other:
        :type Other: AIS_SequenceOfInteractive &
        :rtype: AIS_SequenceOfInteractive

        """
        return _AIS.AIS_SequenceOfInteractive_Assign(self, *args)


    def Set(self, *args) -> "AIS_SequenceOfInteractive const &":
        """
        :param Other:
        :type Other: AIS_SequenceOfInteractive &
        :rtype: AIS_SequenceOfInteractive

        """
        return _AIS.AIS_SequenceOfInteractive_Set(self, *args)


    def Append(self, *args) -> "void":
        """
        :param T:
        :type T: Handle_AIS_InteractiveObject &
        :rtype: None

        :param S:
        :type S: AIS_SequenceOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfInteractive_Append(self, *args)


    def Prepend(self, *args) -> "void":
        """
        :param T:
        :type T: Handle_AIS_InteractiveObject &
        :rtype: None

        :param S:
        :type S: AIS_SequenceOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfInteractive_Prepend(self, *args)


    def InsertBefore(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_AIS_InteractiveObject &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: AIS_SequenceOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfInteractive_InsertBefore(self, *args)


    def InsertAfter(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_AIS_InteractiveObject &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: AIS_SequenceOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfInteractive_InsertAfter(self, *args)


    def First(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_SequenceOfInteractive_First(self, *args)


    def Last(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_SequenceOfInteractive_Last(self, *args)


    def Split(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: AIS_SequenceOfInteractive &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfInteractive_Split(self, *args)


    def Value(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :param Index:
        :type Index: int
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_SequenceOfInteractive_Value(self, *args)


    def SetValue(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_AIS_InteractiveObject &
        :rtype: None

        """
        return _AIS.AIS_SequenceOfInteractive_SetValue(self, *args)


    def ChangeValue(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :param Index:
        :type Index: int
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_SequenceOfInteractive_ChangeValue(self, *args)


    def Remove(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _AIS.AIS_SequenceOfInteractive_Remove(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_SequenceOfInteractive
AIS_SequenceOfInteractive.Clear = new_instancemethod(_AIS.AIS_SequenceOfInteractive_Clear, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.Assign = new_instancemethod(_AIS.AIS_SequenceOfInteractive_Assign, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.Set = new_instancemethod(_AIS.AIS_SequenceOfInteractive_Set, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.Append = new_instancemethod(_AIS.AIS_SequenceOfInteractive_Append, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.Prepend = new_instancemethod(_AIS.AIS_SequenceOfInteractive_Prepend, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.InsertBefore = new_instancemethod(_AIS.AIS_SequenceOfInteractive_InsertBefore, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.InsertAfter = new_instancemethod(_AIS.AIS_SequenceOfInteractive_InsertAfter, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.First = new_instancemethod(_AIS.AIS_SequenceOfInteractive_First, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.Last = new_instancemethod(_AIS.AIS_SequenceOfInteractive_Last, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.Split = new_instancemethod(_AIS.AIS_SequenceOfInteractive_Split, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.Value = new_instancemethod(_AIS.AIS_SequenceOfInteractive_Value, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.SetValue = new_instancemethod(_AIS.AIS_SequenceOfInteractive_SetValue, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.ChangeValue = new_instancemethod(_AIS.AIS_SequenceOfInteractive_ChangeValue, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive.Remove = new_instancemethod(_AIS.AIS_SequenceOfInteractive_Remove, None, AIS_SequenceOfInteractive)
AIS_SequenceOfInteractive_swigregister = _AIS.AIS_SequenceOfInteractive_swigregister
AIS_SequenceOfInteractive_swigregister(AIS_SequenceOfInteractive)

class AIS_StdMapNodeOfMapOfInteractive(OCC.TCollection.TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param K:
        :type K: Handle_AIS_InteractiveObject &
        :param n:
        :type n: TCollection_MapNodePtr &
        :rtype: None

        """
        _AIS.AIS_StdMapNodeOfMapOfInteractive_swiginit(self, _AIS.new_AIS_StdMapNodeOfMapOfInteractive(*args))

    def Key(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_StdMapNodeOfMapOfInteractive_Key(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_StdMapNodeOfMapOfInteractive(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_StdMapNodeOfMapOfInteractive
AIS_StdMapNodeOfMapOfInteractive.Key = new_instancemethod(_AIS.AIS_StdMapNodeOfMapOfInteractive_Key, None, AIS_StdMapNodeOfMapOfInteractive)
AIS_StdMapNodeOfMapOfInteractive_swigregister = _AIS.AIS_StdMapNodeOfMapOfInteractive_swigregister
AIS_StdMapNodeOfMapOfInteractive_swigregister(AIS_StdMapNodeOfMapOfInteractive)

class Handle_AIS_StdMapNodeOfMapOfInteractive(OCC.TCollection.Handle_TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_StdMapNodeOfMapOfInteractive_swiginit(self, _AIS.new_Handle_AIS_StdMapNodeOfMapOfInteractive(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_StdMapNodeOfMapOfInteractive_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_StdMapNodeOfMapOfInteractive
Handle_AIS_StdMapNodeOfMapOfInteractive.Nullify = new_instancemethod(_AIS.Handle_AIS_StdMapNodeOfMapOfInteractive_Nullify, None, Handle_AIS_StdMapNodeOfMapOfInteractive)
Handle_AIS_StdMapNodeOfMapOfInteractive.IsNull = new_instancemethod(_AIS.Handle_AIS_StdMapNodeOfMapOfInteractive_IsNull, None, Handle_AIS_StdMapNodeOfMapOfInteractive)
Handle_AIS_StdMapNodeOfMapOfInteractive._get_reference = new_instancemethod(_AIS.Handle_AIS_StdMapNodeOfMapOfInteractive__get_reference, None, Handle_AIS_StdMapNodeOfMapOfInteractive)
Handle_AIS_StdMapNodeOfMapOfInteractive_swigregister = _AIS.Handle_AIS_StdMapNodeOfMapOfInteractive_swigregister
Handle_AIS_StdMapNodeOfMapOfInteractive_swigregister(Handle_AIS_StdMapNodeOfMapOfInteractive)

def Handle_AIS_StdMapNodeOfMapOfInteractive_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_StdMapNodeOfMapOfInteractive const":
    return _AIS.Handle_AIS_StdMapNodeOfMapOfInteractive_DownCast(AnObject)
Handle_AIS_StdMapNodeOfMapOfInteractive_DownCast = _AIS.Handle_AIS_StdMapNodeOfMapOfInteractive_DownCast

class AIS_TypeFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes filter for type, aGivenKind.

        :param aGivenKind:
        :type aGivenKind: AIS_KindOfInteractive
        :rtype: None

        """
        _AIS.AIS_TypeFilter_swiginit(self, _AIS.new_AIS_TypeFilter(*args))

    def IsOk(self, *args) -> "Standard_Boolean":
        """
        * Returns False if the transient is not an Interactive Object, or if the type of the Interactive Object is not the same as that stored in the filter.

        :param anobj:
        :type anobj: Handle_SelectMgr_EntityOwner &
        :rtype: bool

        """
        return _AIS.AIS_TypeFilter_IsOk(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_TypeFilter(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_TypeFilter
AIS_TypeFilter.IsOk = new_instancemethod(_AIS.AIS_TypeFilter_IsOk, None, AIS_TypeFilter)
AIS_TypeFilter_swigregister = _AIS.AIS_TypeFilter_swigregister
AIS_TypeFilter_swigregister(AIS_TypeFilter)

class Handle_AIS_TypeFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_TypeFilter_swiginit(self, _AIS.new_Handle_AIS_TypeFilter(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_TypeFilter_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_TypeFilter
Handle_AIS_TypeFilter.Nullify = new_instancemethod(_AIS.Handle_AIS_TypeFilter_Nullify, None, Handle_AIS_TypeFilter)
Handle_AIS_TypeFilter.IsNull = new_instancemethod(_AIS.Handle_AIS_TypeFilter_IsNull, None, Handle_AIS_TypeFilter)
Handle_AIS_TypeFilter._get_reference = new_instancemethod(_AIS.Handle_AIS_TypeFilter__get_reference, None, Handle_AIS_TypeFilter)
Handle_AIS_TypeFilter_swigregister = _AIS.Handle_AIS_TypeFilter_swigregister
Handle_AIS_TypeFilter_swigregister(Handle_AIS_TypeFilter)

def Handle_AIS_TypeFilter_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_TypeFilter const":
    return _AIS.Handle_AIS_TypeFilter_DownCast(AnObject)
Handle_AIS_TypeFilter_DownCast = _AIS.Handle_AIS_TypeFilter_DownCast

class AIS_Axis(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the line aComponent

        :param aComponent:
        :type aComponent: Handle_Geom_Line &
        :rtype: None

        * initializes the axis2 position aComponent. The coordinate system used is right-handed.

        :param aComponent:
        :type aComponent: Handle_Geom_Axis2Placement &
        :param anAxisType:
        :type anAxisType: AIS_TypeOfAxis
        :rtype: None

        * Initializes the axis1 position anAxis.

        :param anAxis:
        :type anAxis: Handle_Geom_Axis1Placement &
        :rtype: None

        """
        _AIS.AIS_Axis_swiginit(self, _AIS.new_AIS_Axis(*args))

    def Component(self, *args) -> "Handle_Geom_Line":
        """
        * Returns the axis entity aComponent and identifies it as a component of a shape.

        :rtype: Handle_Geom_Line

        """
        return _AIS.AIS_Axis_Component(self, *args)


    def SetComponent(self, *args) -> "void":
        """
        * Sets the coordinates of the lin aComponent.

        :param aComponent:
        :type aComponent: Handle_Geom_Line &
        :rtype: None

        """
        return _AIS.AIS_Axis_SetComponent(self, *args)


    def Axis2Placement(self, *args) -> "Handle_Geom_Axis2Placement":
        """
        * Returns the position of axis2 and positions it by identifying it as the x, y, or z axis and giving its direction in 3D space. The coordinate system used is right-handed.

        :rtype: Handle_Geom_Axis2Placement

        """
        return _AIS.AIS_Axis_Axis2Placement(self, *args)


    def SetAxis2Placement(self, *args) -> "void":
        """
        * Allows you to provide settings for aComponent:the position and direction of an axis in 3D space. The coordinate system used is right-handed.

        :param aComponent:
        :type aComponent: Handle_Geom_Axis2Placement &
        :param anAxisType:
        :type anAxisType: AIS_TypeOfAxis
        :rtype: None

        """
        return _AIS.AIS_Axis_SetAxis2Placement(self, *args)


    def SetAxis1Placement(self, *args) -> "void":
        """
        * Constructs a new line to serve as the axis anAxis in 3D space.

        :param anAxis:
        :type anAxis: Handle_Geom_Axis1Placement &
        :rtype: None

        """
        return _AIS.AIS_Axis_SetAxis1Placement(self, *args)


    def TypeOfAxis(self, *args) -> "AIS_TypeOfAxis":
        """
        * Returns the type of axis.

        :rtype: AIS_TypeOfAxis

        """
        return _AIS.AIS_Axis_TypeOfAxis(self, *args)


    def SetTypeOfAxis(self, *args) -> "void":
        """
        * Constructs the entity aTypeAxis to stock information concerning type of axis.

        :param aTypeAxis:
        :type aTypeAxis: AIS_TypeOfAxis
        :rtype: None

        """
        return _AIS.AIS_Axis_SetTypeOfAxis(self, *args)


    def IsXYZAxis(self, *args) -> "Standard_Boolean":
        """
        * Returns a signature of 2 for axis datums. When you activate mode 2 by a signature, you pick AIS objects of type AIS_Axis.

        :rtype: bool

        """
        return _AIS.AIS_Axis_IsXYZAxis(self, *args)


    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_Axis_Compute(self, *args)


    def SetColor(self, *args) -> "void":
        """
        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_Axis_SetColor(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Axis(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Axis
AIS_Axis.Component = new_instancemethod(_AIS.AIS_Axis_Component, None, AIS_Axis)
AIS_Axis.SetComponent = new_instancemethod(_AIS.AIS_Axis_SetComponent, None, AIS_Axis)
AIS_Axis.Axis2Placement = new_instancemethod(_AIS.AIS_Axis_Axis2Placement, None, AIS_Axis)
AIS_Axis.SetAxis2Placement = new_instancemethod(_AIS.AIS_Axis_SetAxis2Placement, None, AIS_Axis)
AIS_Axis.SetAxis1Placement = new_instancemethod(_AIS.AIS_Axis_SetAxis1Placement, None, AIS_Axis)
AIS_Axis.TypeOfAxis = new_instancemethod(_AIS.AIS_Axis_TypeOfAxis, None, AIS_Axis)
AIS_Axis.SetTypeOfAxis = new_instancemethod(_AIS.AIS_Axis_SetTypeOfAxis, None, AIS_Axis)
AIS_Axis.IsXYZAxis = new_instancemethod(_AIS.AIS_Axis_IsXYZAxis, None, AIS_Axis)
AIS_Axis.Compute = new_instancemethod(_AIS.AIS_Axis_Compute, None, AIS_Axis)
AIS_Axis.SetColor = new_instancemethod(_AIS.AIS_Axis_SetColor, None, AIS_Axis)
AIS_Axis_swigregister = _AIS.AIS_Axis_swigregister
AIS_Axis_swigregister(AIS_Axis)

class Handle_AIS_Axis(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Axis_swiginit(self, _AIS.new_Handle_AIS_Axis(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Axis_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Axis
Handle_AIS_Axis.Nullify = new_instancemethod(_AIS.Handle_AIS_Axis_Nullify, None, Handle_AIS_Axis)
Handle_AIS_Axis.IsNull = new_instancemethod(_AIS.Handle_AIS_Axis_IsNull, None, Handle_AIS_Axis)
Handle_AIS_Axis._get_reference = new_instancemethod(_AIS.Handle_AIS_Axis__get_reference, None, Handle_AIS_Axis)
Handle_AIS_Axis_swigregister = _AIS.Handle_AIS_Axis_swigregister
Handle_AIS_Axis_swigregister(Handle_AIS_Axis)

def Handle_AIS_Axis_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Axis const":
    return _AIS.Handle_AIS_Axis_DownCast(AnObject)
Handle_AIS_Axis_DownCast = _AIS.Handle_AIS_Axis_DownCast

class AIS_Circle(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes this algorithm for constructing AIS circle datums initializes the circle aCircle

        :param aCircle:
        :type aCircle: Handle_Geom_Circle &
        :rtype: None

        * Initializes this algorithm for constructing AIS circle datums. Initializes the circle theCircle, the arc starting point theUStart, the arc ending point theUEnd, and the type of sensitivity theIsFilledCircleSens.

        :param theCircle:
        :type theCircle: Handle_Geom_Circle &
        :param theUStart:
        :type theUStart: float
        :param theUEnd:
        :type theUEnd: float
        :param theIsFilledCircleSens: default value is Standard_False
        :type theIsFilledCircleSens: bool
        :rtype: None

        """
        _AIS.AIS_Circle_swiginit(self, _AIS.new_AIS_Circle(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_Circle_Compute(self, *args)


    def Circle(self, *args) -> "Handle_Geom_Circle":
        """
        * Returns the circle component defined in SetCircle.

        :rtype: Handle_Geom_Circle

        """
        return _AIS.AIS_Circle_Circle(self, *args)


    def Parameters(self, *args) -> "void":
        """
        * Constructs instances of the starting point and the end point parameters, u1 and u2.

        :param u1:
        :type u1: float &
        :param u2:
        :type u2: float &
        :rtype: None

        """
        return _AIS.AIS_Circle_Parameters(self, *args)


    def SetCircle(self, *args) -> "void":
        """
        * Allows you to provide settings for the circle datum aCircle.

        :param aCircle:
        :type aCircle: Handle_Geom_Circle &
        :rtype: None

        """
        return _AIS.AIS_Circle_SetCircle(self, *args)


    def SetFirstParam(self, *args) -> "void":
        """
        * Allows you to set the parameter u for the starting point of an arc.

        :param u:
        :type u: float
        :rtype: None

        """
        return _AIS.AIS_Circle_SetFirstParam(self, *args)


    def SetLastParam(self, *args) -> "void":
        """
        * Allows you to provide the parameter u for the end point of an arc.

        :param u:
        :type u: float
        :rtype: None

        """
        return _AIS.AIS_Circle_SetLastParam(self, *args)


    def SetColor(self, *args) -> "void":
        """
        * Assigns the color aColor to the solid line boundary of the circle datum.

        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_Circle_SetColor(self, *args)


    def IsFilledCircleSens(self, *args) -> "Standard_Boolean":
        """
        * Returns the type of sensitivity for the circle;

        :rtype: bool

        """
        return _AIS.AIS_Circle_IsFilledCircleSens(self, *args)


    def SetFilledCircleSens(self, *args) -> "void":
        """
        * Sets the type of sensitivity for the circle. If theIsFilledCircleSens set to Standard_True then the whole circle will be detectable, otherwise only the boundary of the circle.

        :param theIsFilledCircleSens:
        :type theIsFilledCircleSens: bool
        :rtype: None

        """
        return _AIS.AIS_Circle_SetFilledCircleSens(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Circle(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Circle
AIS_Circle.Compute = new_instancemethod(_AIS.AIS_Circle_Compute, None, AIS_Circle)
AIS_Circle.Circle = new_instancemethod(_AIS.AIS_Circle_Circle, None, AIS_Circle)
AIS_Circle.Parameters = new_instancemethod(_AIS.AIS_Circle_Parameters, None, AIS_Circle)
AIS_Circle.SetCircle = new_instancemethod(_AIS.AIS_Circle_SetCircle, None, AIS_Circle)
AIS_Circle.SetFirstParam = new_instancemethod(_AIS.AIS_Circle_SetFirstParam, None, AIS_Circle)
AIS_Circle.SetLastParam = new_instancemethod(_AIS.AIS_Circle_SetLastParam, None, AIS_Circle)
AIS_Circle.SetColor = new_instancemethod(_AIS.AIS_Circle_SetColor, None, AIS_Circle)
AIS_Circle.IsFilledCircleSens = new_instancemethod(_AIS.AIS_Circle_IsFilledCircleSens, None, AIS_Circle)
AIS_Circle.SetFilledCircleSens = new_instancemethod(_AIS.AIS_Circle_SetFilledCircleSens, None, AIS_Circle)
AIS_Circle_swigregister = _AIS.AIS_Circle_swigregister
AIS_Circle_swigregister(AIS_Circle)

class Handle_AIS_Circle(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Circle_swiginit(self, _AIS.new_Handle_AIS_Circle(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Circle_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Circle
Handle_AIS_Circle.Nullify = new_instancemethod(_AIS.Handle_AIS_Circle_Nullify, None, Handle_AIS_Circle)
Handle_AIS_Circle.IsNull = new_instancemethod(_AIS.Handle_AIS_Circle_IsNull, None, Handle_AIS_Circle)
Handle_AIS_Circle._get_reference = new_instancemethod(_AIS.Handle_AIS_Circle__get_reference, None, Handle_AIS_Circle)
Handle_AIS_Circle_swigregister = _AIS.Handle_AIS_Circle_swigregister
Handle_AIS_Circle_swigregister(Handle_AIS_Circle)

def Handle_AIS_Circle_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Circle const":
    return _AIS.Handle_AIS_Circle_DownCast(AnObject)
Handle_AIS_Circle_DownCast = _AIS.Handle_AIS_Circle_DownCast

class AIS_ColoredDrawer(AIS_Drawer):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    myIsHidden = _swig_property(_AIS.AIS_ColoredDrawer_myIsHidden_get, _AIS.AIS_ColoredDrawer_myIsHidden_set)
    myHasOwnColor = _swig_property(_AIS.AIS_ColoredDrawer_myHasOwnColor_get, _AIS.AIS_ColoredDrawer_myHasOwnColor_set)
    myHasOwnWidth = _swig_property(_AIS.AIS_ColoredDrawer_myHasOwnWidth_get, _AIS.AIS_ColoredDrawer_myHasOwnWidth_set)

    def __init__(self, *args):
        """
        :param theLink:
        :type theLink: Handle_AIS_Drawer &
        :rtype: None

        """
        _AIS.AIS_ColoredDrawer_swiginit(self, _AIS.new_AIS_ColoredDrawer(*args))

    def IsHidden(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_ColoredDrawer_IsHidden(self, *args)


    def SetHidden(self, *args) -> "void":
        """
        :param theToHide:
        :type theToHide: bool
        :rtype: None

        """
        return _AIS.AIS_ColoredDrawer_SetHidden(self, *args)


    def HasOwnColor(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_ColoredDrawer_HasOwnColor(self, *args)


    def UnsetOwnColor(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_ColoredDrawer_UnsetOwnColor(self, *args)


    def SetOwnColor(self, *args) -> "void":
        """
        :param &:
        :type &: Quantity_Color
        :rtype: None

        """
        return _AIS.AIS_ColoredDrawer_SetOwnColor(self, *args)


    def HasOwnWidth(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_ColoredDrawer_HasOwnWidth(self, *args)


    def UnsetOwnWidth(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_ColoredDrawer_UnsetOwnWidth(self, *args)


    def SetOwnWidth(self, *args) -> "void":
        """
        :param Standard_Real:
        :type Standard_Real: 
        :rtype: None

        """
        return _AIS.AIS_ColoredDrawer_SetOwnWidth(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_ColoredDrawer(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_ColoredDrawer
AIS_ColoredDrawer.IsHidden = new_instancemethod(_AIS.AIS_ColoredDrawer_IsHidden, None, AIS_ColoredDrawer)
AIS_ColoredDrawer.SetHidden = new_instancemethod(_AIS.AIS_ColoredDrawer_SetHidden, None, AIS_ColoredDrawer)
AIS_ColoredDrawer.HasOwnColor = new_instancemethod(_AIS.AIS_ColoredDrawer_HasOwnColor, None, AIS_ColoredDrawer)
AIS_ColoredDrawer.UnsetOwnColor = new_instancemethod(_AIS.AIS_ColoredDrawer_UnsetOwnColor, None, AIS_ColoredDrawer)
AIS_ColoredDrawer.SetOwnColor = new_instancemethod(_AIS.AIS_ColoredDrawer_SetOwnColor, None, AIS_ColoredDrawer)
AIS_ColoredDrawer.HasOwnWidth = new_instancemethod(_AIS.AIS_ColoredDrawer_HasOwnWidth, None, AIS_ColoredDrawer)
AIS_ColoredDrawer.UnsetOwnWidth = new_instancemethod(_AIS.AIS_ColoredDrawer_UnsetOwnWidth, None, AIS_ColoredDrawer)
AIS_ColoredDrawer.SetOwnWidth = new_instancemethod(_AIS.AIS_ColoredDrawer_SetOwnWidth, None, AIS_ColoredDrawer)
AIS_ColoredDrawer_swigregister = _AIS.AIS_ColoredDrawer_swigregister
AIS_ColoredDrawer_swigregister(AIS_ColoredDrawer)

class Handle_AIS_ColoredDrawer(Handle_AIS_Drawer):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_ColoredDrawer_swiginit(self, _AIS.new_Handle_AIS_ColoredDrawer(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_ColoredDrawer_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_ColoredDrawer
Handle_AIS_ColoredDrawer.Nullify = new_instancemethod(_AIS.Handle_AIS_ColoredDrawer_Nullify, None, Handle_AIS_ColoredDrawer)
Handle_AIS_ColoredDrawer.IsNull = new_instancemethod(_AIS.Handle_AIS_ColoredDrawer_IsNull, None, Handle_AIS_ColoredDrawer)
Handle_AIS_ColoredDrawer._get_reference = new_instancemethod(_AIS.Handle_AIS_ColoredDrawer__get_reference, None, Handle_AIS_ColoredDrawer)
Handle_AIS_ColoredDrawer_swigregister = _AIS.Handle_AIS_ColoredDrawer_swigregister
Handle_AIS_ColoredDrawer_swigregister(Handle_AIS_ColoredDrawer)

def Handle_AIS_ColoredDrawer_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_ColoredDrawer const":
    return _AIS.Handle_AIS_ColoredDrawer_DownCast(AnObject)
Handle_AIS_ColoredDrawer_DownCast = _AIS.Handle_AIS_ColoredDrawer_DownCast

class AIS_ConnectedInteractive(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Disconnects the previous view and sets highlight mode to 0. This highlights the wireframe presentation aTypeOfPresentation3d. Top_AllView deactivates hidden line removal.

        :param aTypeOfPresentation3d: default value is PrsMgr_TOP_AllView
        :type aTypeOfPresentation3d: PrsMgr_TypeOfPresentation3d
        :rtype: None

        """
        _AIS.AIS_ConnectedInteractive_swiginit(self, _AIS.new_AIS_ConnectedInteractive(*args))

    def Connect(self, *args) -> "void":
        """
        * Establishes the connection between the Connected Interactive Object, anotherIobj, and its reference.

        :param anotherIObj:
        :type anotherIObj: Handle_AIS_InteractiveObject &
        :rtype: void

        * Establishes the connection between the Connected Interactive Object, anotherIobj, and its reference. Locates instance in aLocation.

        :param anotherIobj:
        :type anotherIobj: Handle_AIS_InteractiveObject &
        :param aLocation:
        :type aLocation: gp_Trsf
        :rtype: void

        """
        return _AIS.AIS_ConnectedInteractive_Connect(self, *args)


    def HasConnection(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is a connection established between the presentation and its source reference.

        :rtype: bool

        """
        return _AIS.AIS_ConnectedInteractive_HasConnection(self, *args)


    def ConnectedTo(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        * Returns the connection with the reference Interactive Object.

        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_ConnectedInteractive_ConnectedTo(self, *args)


    def Disconnect(self, *args) -> "void":
        """
        * Clears the connection with a source reference. The presentation will no longer be displayed. Warning Must be done before deleting the presentation.

        :rtype: None

        """
        return _AIS.AIS_ConnectedInteractive_Disconnect(self, *args)


    def AcceptShapeDecomposition(self, *args) -> "Standard_Boolean":
        """
        * Informs the graphic context that the interactive Object may be decomposed into sub-shapes for dynamic selection.

        :rtype: bool

        """
        return _AIS.AIS_ConnectedInteractive_AcceptShapeDecomposition(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_ConnectedInteractive(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_ConnectedInteractive
AIS_ConnectedInteractive.Connect = new_instancemethod(_AIS.AIS_ConnectedInteractive_Connect, None, AIS_ConnectedInteractive)
AIS_ConnectedInteractive.HasConnection = new_instancemethod(_AIS.AIS_ConnectedInteractive_HasConnection, None, AIS_ConnectedInteractive)
AIS_ConnectedInteractive.ConnectedTo = new_instancemethod(_AIS.AIS_ConnectedInteractive_ConnectedTo, None, AIS_ConnectedInteractive)
AIS_ConnectedInteractive.Disconnect = new_instancemethod(_AIS.AIS_ConnectedInteractive_Disconnect, None, AIS_ConnectedInteractive)
AIS_ConnectedInteractive.AcceptShapeDecomposition = new_instancemethod(_AIS.AIS_ConnectedInteractive_AcceptShapeDecomposition, None, AIS_ConnectedInteractive)
AIS_ConnectedInteractive_swigregister = _AIS.AIS_ConnectedInteractive_swigregister
AIS_ConnectedInteractive_swigregister(AIS_ConnectedInteractive)

class Handle_AIS_ConnectedInteractive(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_ConnectedInteractive_swiginit(self, _AIS.new_Handle_AIS_ConnectedInteractive(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_ConnectedInteractive_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_ConnectedInteractive
Handle_AIS_ConnectedInteractive.Nullify = new_instancemethod(_AIS.Handle_AIS_ConnectedInteractive_Nullify, None, Handle_AIS_ConnectedInteractive)
Handle_AIS_ConnectedInteractive.IsNull = new_instancemethod(_AIS.Handle_AIS_ConnectedInteractive_IsNull, None, Handle_AIS_ConnectedInteractive)
Handle_AIS_ConnectedInteractive._get_reference = new_instancemethod(_AIS.Handle_AIS_ConnectedInteractive__get_reference, None, Handle_AIS_ConnectedInteractive)
Handle_AIS_ConnectedInteractive_swigregister = _AIS.Handle_AIS_ConnectedInteractive_swigregister
Handle_AIS_ConnectedInteractive_swigregister(Handle_AIS_ConnectedInteractive)

def Handle_AIS_ConnectedInteractive_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_ConnectedInteractive const":
    return _AIS.Handle_AIS_ConnectedInteractive_DownCast(AnObject)
Handle_AIS_ConnectedInteractive_DownCast = _AIS.Handle_AIS_ConnectedInteractive_DownCast

class AIS_Dimension(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ComputeMode_All = _AIS.AIS_Dimension_ComputeMode_All
    ComputeMode_Line = _AIS.AIS_Dimension_ComputeMode_Line
    ComputeMode_Text = _AIS.AIS_Dimension_ComputeMode_Text

    def __init__(self, *args):
        """
        * Constructor with default parameters values. @param theType [in] the type of dimension.

        :param theType:
        :type theType: AIS_KindOfDimension
        :rtype: None

        """
        _AIS.AIS_Dimension_swiginit(self, _AIS.new_AIS_Dimension(*args))

    def GetValue(self, *args) -> "Standard_Real":
        """
        * Gets dimension measurement value. If the value to display is not specified by user, then the dimension object is responsible to compute it on its own in model space coordinates. returns the dimension value (in model units) which is used during display of the presentation.

        :rtype: float

        """
        return _AIS.AIS_Dimension_GetValue(self, *args)


    def SetCustomValue(self, *args) -> "void":
        """
        * Sets user-defined dimension value. The user-defined dimension value is specified in model space, and affect by unit conversion during the display. @param theValue [in] the user-defined value to display.

        :param theValue:
        :type theValue: float
        :rtype: None

        """
        return _AIS.AIS_Dimension_SetCustomValue(self, *args)


    def GetPlane(self, *args) -> "gp_Pln const":
        """
        * Get the dimension plane in which the 2D dimension presentation is computed. By default, if plane is not defined by user, it is computed automatically after dimension geometry is computed. If computed dimension geometry (points) can't be placed on the user-defined plane, dimension geometry was set as invalid (validity flag is set to false) and dimension presentation will not be computed. If user-defined plane allow geometry placement on it, it will be used for computing of the dimension presentation. returns dimension plane used for presentation computing.

        :rtype: gp_Pln

        """
        return _AIS.AIS_Dimension_GetPlane(self, *args)


    def GetGeometryType(self, *args) -> "Standard_Integer":
        """
        * Geometry type defines type of shapes on which the dimension is to be built. returns type of geometry on which the dimension will be built.

        :rtype: int

        """
        return _AIS.AIS_Dimension_GetGeometryType(self, *args)


    def SetCustomPlane(self, *args) -> "void":
        """
        * Sets user-defined plane where the 2D dimension presentation will be placed. Checks validity of this plane if geometry has been set already. Validity of the plane is checked according to the geometry set and has different criteria for different kinds of dimensions.

        :param thePlane:
        :type thePlane: gp_Pln
        :rtype: void

        """
        return _AIS.AIS_Dimension_SetCustomPlane(self, *args)


    def UnsetCustomPlane(self, *args) -> "void":
        """
        * Unsets user-defined plane. Therefore the plane for dimension will be computed automatically.

        :rtype: None

        """
        return _AIS.AIS_Dimension_UnsetCustomPlane(self, *args)


    def IsTextPositionCustom(self, *args) -> "Standard_Boolean":
        """
        * returns True if text position is set by user with method SetTextPosition().

        :rtype: bool

        """
        return _AIS.AIS_Dimension_IsTextPositionCustom(self, *args)


    def SetTextPosition(self, *args) -> "void":
        """
        * Fixes the absolute text position and adjusts flyout, plane and text alignment according to it. Updates presentation if the text position is valid. ATTENTION! It does not change vertical text alignment. @param theTextPos [in] the point of text position.

        :param &:
        :type &: gp_Pnt
        :rtype: None

        """
        return _AIS.AIS_Dimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args) -> "gp_Pnt const":
        """
        * Computes absolute text position from dimension parameters (flyout, plane and text alignment).

        :rtype: gp_Pnt

        """
        return _AIS.AIS_Dimension_GetTextPosition(self, *args)


    def DimensionAspect(self, *args) -> "Handle_Prs3d_DimensionAspect":
        """
        * Gets the dimension aspect from AIS object drawer. Dimension aspect contains aspects of line, text and arrows for dimension presentation.

        :rtype: Handle_Prs3d_DimensionAspect

        """
        return _AIS.AIS_Dimension_DimensionAspect(self, *args)


    def SetDimensionAspect(self, *args) -> "void":
        """
        * Sets new dimension aspect for the interactive object drawer. The dimension aspect provides dynamic properties which are generally used during computation of dimension presentations.

        :param theDimensionAspect:
        :type theDimensionAspect: Handle_Prs3d_DimensionAspect &
        :rtype: None

        """
        return _AIS.AIS_Dimension_SetDimensionAspect(self, *args)


    def KindOfDimension(self, *args) -> "AIS_KindOfDimension":
        """
        * returns the kind of dimension.

        :rtype: AIS_KindOfDimension

        """
        return _AIS.AIS_Dimension_KindOfDimension(self, *args)


    def DisplaySpecialSymbol(self, *args) -> "AIS_DisplaySpecialSymbol":
        """
        * returns dimension special symbol display options.

        :rtype: AIS_DisplaySpecialSymbol

        """
        return _AIS.AIS_Dimension_DisplaySpecialSymbol(self, *args)


    def SetDisplaySpecialSymbol(self, *args) -> "void":
        """
        * Specifies whether to display special symbol or not.

        :param theDisplaySpecSymbol:
        :type theDisplaySpecSymbol: AIS_DisplaySpecialSymbol
        :rtype: None

        """
        return _AIS.AIS_Dimension_SetDisplaySpecialSymbol(self, *args)


    def SpecialSymbol(self, *args) -> "Standard_ExtCharacter":
        """
        * returns special symbol.

        :rtype: Standard_ExtCharacter

        """
        return _AIS.AIS_Dimension_SpecialSymbol(self, *args)


    def SetSpecialSymbol(self, *args) -> "void":
        """
        * Specifies special symbol.

        :param theSpecialSymbol:
        :type theSpecialSymbol: Standard_ExtCharacter
        :rtype: None

        """
        return _AIS.AIS_Dimension_SetSpecialSymbol(self, *args)


    def GetDisplayUnits(self, *args) -> "TCollection_AsciiString const &":
        """
        :rtype: TCollection_AsciiString

        """
        return _AIS.AIS_Dimension_GetDisplayUnits(self, *args)


    def GetModelUnits(self, *args) -> "TCollection_AsciiString const &":
        """
        :rtype: TCollection_AsciiString

        """
        return _AIS.AIS_Dimension_GetModelUnits(self, *args)


    def SetDisplayUnits(self, *args) -> "void":
        """
        :param &:
        :type &: TCollection_AsciiString
        :rtype: void

        """
        return _AIS.AIS_Dimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args) -> "void":
        """
        :param &:
        :type &: TCollection_AsciiString
        :rtype: void

        """
        return _AIS.AIS_Dimension_SetModelUnits(self, *args)


    def UnsetFixedTextPosition(self, *args) -> "void":
        """
        * Unsets user defined text positioning and enables text positioning by other parameters: text alignment, extension size, flyout and custom plane.

        :rtype: None

        """
        return _AIS.AIS_Dimension_UnsetFixedTextPosition(self, *args)


    def SelToleranceForText2d(self, *args) -> "Standard_Real":
        """
        * Returns selection tolerance for text2d: For 2d text selection detection sensitive point with tolerance is used Important! Only for 2d text.

        :rtype: float

        """
        return _AIS.AIS_Dimension_SelToleranceForText2d(self, *args)


    def SetSelToleranceForText2d(self, *args) -> "void":
        """
        * Sets selection tolerance for text2d: For 2d text selection detection sensitive point with tolerance is used to change this tolerance use this method Important! Only for 2d text.

        :param theTol:
        :type theTol: float
        :rtype: None

        """
        return _AIS.AIS_Dimension_SetSelToleranceForText2d(self, *args)


    def GetFlyout(self, *args) -> "Standard_Real":
        """
        * returns flyout value for dimension.

        :rtype: float

        """
        return _AIS.AIS_Dimension_GetFlyout(self, *args)


    def SetFlyout(self, *args) -> "void":
        """
        * Sets flyout value for dimension.

        :param theFlyout:
        :type theFlyout: float
        :rtype: None

        """
        return _AIS.AIS_Dimension_SetFlyout(self, *args)


    def IsValid(self, *args) -> "Standard_Boolean":
        """
        * Check that the input geometry for dimension is valid and the presentation can be successfully computed. returns True if dimension geometry is ok.

        :rtype: bool

        """
        return _AIS.AIS_Dimension_IsValid(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Dimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Dimension
AIS_Dimension.GetValue = new_instancemethod(_AIS.AIS_Dimension_GetValue, None, AIS_Dimension)
AIS_Dimension.SetCustomValue = new_instancemethod(_AIS.AIS_Dimension_SetCustomValue, None, AIS_Dimension)
AIS_Dimension.GetPlane = new_instancemethod(_AIS.AIS_Dimension_GetPlane, None, AIS_Dimension)
AIS_Dimension.GetGeometryType = new_instancemethod(_AIS.AIS_Dimension_GetGeometryType, None, AIS_Dimension)
AIS_Dimension.SetCustomPlane = new_instancemethod(_AIS.AIS_Dimension_SetCustomPlane, None, AIS_Dimension)
AIS_Dimension.UnsetCustomPlane = new_instancemethod(_AIS.AIS_Dimension_UnsetCustomPlane, None, AIS_Dimension)
AIS_Dimension.IsTextPositionCustom = new_instancemethod(_AIS.AIS_Dimension_IsTextPositionCustom, None, AIS_Dimension)
AIS_Dimension.SetTextPosition = new_instancemethod(_AIS.AIS_Dimension_SetTextPosition, None, AIS_Dimension)
AIS_Dimension.GetTextPosition = new_instancemethod(_AIS.AIS_Dimension_GetTextPosition, None, AIS_Dimension)
AIS_Dimension.DimensionAspect = new_instancemethod(_AIS.AIS_Dimension_DimensionAspect, None, AIS_Dimension)
AIS_Dimension.SetDimensionAspect = new_instancemethod(_AIS.AIS_Dimension_SetDimensionAspect, None, AIS_Dimension)
AIS_Dimension.KindOfDimension = new_instancemethod(_AIS.AIS_Dimension_KindOfDimension, None, AIS_Dimension)
AIS_Dimension.DisplaySpecialSymbol = new_instancemethod(_AIS.AIS_Dimension_DisplaySpecialSymbol, None, AIS_Dimension)
AIS_Dimension.SetDisplaySpecialSymbol = new_instancemethod(_AIS.AIS_Dimension_SetDisplaySpecialSymbol, None, AIS_Dimension)
AIS_Dimension.SpecialSymbol = new_instancemethod(_AIS.AIS_Dimension_SpecialSymbol, None, AIS_Dimension)
AIS_Dimension.SetSpecialSymbol = new_instancemethod(_AIS.AIS_Dimension_SetSpecialSymbol, None, AIS_Dimension)
AIS_Dimension.GetDisplayUnits = new_instancemethod(_AIS.AIS_Dimension_GetDisplayUnits, None, AIS_Dimension)
AIS_Dimension.GetModelUnits = new_instancemethod(_AIS.AIS_Dimension_GetModelUnits, None, AIS_Dimension)
AIS_Dimension.SetDisplayUnits = new_instancemethod(_AIS.AIS_Dimension_SetDisplayUnits, None, AIS_Dimension)
AIS_Dimension.SetModelUnits = new_instancemethod(_AIS.AIS_Dimension_SetModelUnits, None, AIS_Dimension)
AIS_Dimension.UnsetFixedTextPosition = new_instancemethod(_AIS.AIS_Dimension_UnsetFixedTextPosition, None, AIS_Dimension)
AIS_Dimension.SelToleranceForText2d = new_instancemethod(_AIS.AIS_Dimension_SelToleranceForText2d, None, AIS_Dimension)
AIS_Dimension.SetSelToleranceForText2d = new_instancemethod(_AIS.AIS_Dimension_SetSelToleranceForText2d, None, AIS_Dimension)
AIS_Dimension.GetFlyout = new_instancemethod(_AIS.AIS_Dimension_GetFlyout, None, AIS_Dimension)
AIS_Dimension.SetFlyout = new_instancemethod(_AIS.AIS_Dimension_SetFlyout, None, AIS_Dimension)
AIS_Dimension.IsValid = new_instancemethod(_AIS.AIS_Dimension_IsValid, None, AIS_Dimension)
AIS_Dimension_swigregister = _AIS.AIS_Dimension_swigregister
AIS_Dimension_swigregister(AIS_Dimension)

class Handle_AIS_Dimension(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Dimension_swiginit(self, _AIS.new_Handle_AIS_Dimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Dimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Dimension
Handle_AIS_Dimension.Nullify = new_instancemethod(_AIS.Handle_AIS_Dimension_Nullify, None, Handle_AIS_Dimension)
Handle_AIS_Dimension.IsNull = new_instancemethod(_AIS.Handle_AIS_Dimension_IsNull, None, Handle_AIS_Dimension)
Handle_AIS_Dimension._get_reference = new_instancemethod(_AIS.Handle_AIS_Dimension__get_reference, None, Handle_AIS_Dimension)
Handle_AIS_Dimension_swigregister = _AIS.Handle_AIS_Dimension_swigregister
Handle_AIS_Dimension_swigregister(Handle_AIS_Dimension)

def Handle_AIS_Dimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Dimension const":
    return _AIS.Handle_AIS_Dimension_DownCast(AnObject)
Handle_AIS_Dimension_DownCast = _AIS.Handle_AIS_Dimension_DownCast

class AIS_Line(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the line aLine.

        :param aLine:
        :type aLine: Handle_Geom_Line &
        :rtype: None

        * Initializes a starting point aStartPoint and a finishing point aEndPoint for the line.

        :param aStartPoint:
        :type aStartPoint: Handle_Geom_Point &
        :param aEndPoint:
        :type aEndPoint: Handle_Geom_Point &
        :rtype: None

        """
        _AIS.AIS_Line_swiginit(self, _AIS.new_AIS_Line(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_Line_Compute(self, *args)


    def Line(self, *args) -> "Handle_Geom_Line":
        """
        * Constructs an infinite line.

        :rtype: Handle_Geom_Line

        """
        return _AIS.AIS_Line_Line(self, *args)


    def Points(self, *args) -> "void":
        """
        * Returns the starting point PStart and the end point PEnd of the line set by SetPoints.

        :param PStart:
        :type PStart: Handle_Geom_Point &
        :param PEnd:
        :type PEnd: Handle_Geom_Point &
        :rtype: None

        """
        return _AIS.AIS_Line_Points(self, *args)


    def SetLine(self, *args) -> "void":
        """
        * instantiates an infinite line.

        :param L:
        :type L: Handle_Geom_Line &
        :rtype: None

        """
        return _AIS.AIS_Line_SetLine(self, *args)


    def SetPoints(self, *args) -> "void":
        """
        * Sets the starting point P1 and ending point P2 of the infinite line to create a finite line segment.

        :param P1:
        :type P1: Handle_Geom_Point &
        :param P2:
        :type P2: Handle_Geom_Point &
        :rtype: None

        """
        return _AIS.AIS_Line_SetPoints(self, *args)


    def SetColor(self, *args) -> "void":
        """
        * Provides a new color setting aColor for the line in the drawing tool, or 'Drawer'.

        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_Line_SetColor(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Line(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Line
AIS_Line.Compute = new_instancemethod(_AIS.AIS_Line_Compute, None, AIS_Line)
AIS_Line.Line = new_instancemethod(_AIS.AIS_Line_Line, None, AIS_Line)
AIS_Line.Points = new_instancemethod(_AIS.AIS_Line_Points, None, AIS_Line)
AIS_Line.SetLine = new_instancemethod(_AIS.AIS_Line_SetLine, None, AIS_Line)
AIS_Line.SetPoints = new_instancemethod(_AIS.AIS_Line_SetPoints, None, AIS_Line)
AIS_Line.SetColor = new_instancemethod(_AIS.AIS_Line_SetColor, None, AIS_Line)
AIS_Line_swigregister = _AIS.AIS_Line_swigregister
AIS_Line_swigregister(AIS_Line)

class Handle_AIS_Line(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Line_swiginit(self, _AIS.new_Handle_AIS_Line(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Line_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Line
Handle_AIS_Line.Nullify = new_instancemethod(_AIS.Handle_AIS_Line_Nullify, None, Handle_AIS_Line)
Handle_AIS_Line.IsNull = new_instancemethod(_AIS.Handle_AIS_Line_IsNull, None, Handle_AIS_Line)
Handle_AIS_Line._get_reference = new_instancemethod(_AIS.Handle_AIS_Line__get_reference, None, Handle_AIS_Line)
Handle_AIS_Line_swigregister = _AIS.Handle_AIS_Line_swigregister
Handle_AIS_Line_swigregister(Handle_AIS_Line)

def Handle_AIS_Line_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Line const":
    return _AIS.Handle_AIS_Line_DownCast(AnObject)
Handle_AIS_Line_DownCast = _AIS.Handle_AIS_Line_DownCast

class AIS_MultipleConnectedInteractive(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the Interactive Object with multiple connections to AIS_Interactive objects.

        :rtype: None

        """
        _AIS.AIS_MultipleConnectedInteractive_swiginit(self, _AIS.new_AIS_MultipleConnectedInteractive(*args))

    def Connect(self, *args) -> "Handle_AIS_InteractiveObject":
        """
        * Establishes the connection between the Connected Interactive Object, theInteractive, and its reference. Copies local transformation and transformation persistence mode from theInteractive. returns created instance object (AIS_ConnectedInteractive or AIS_MultipleConnectedInteractive)

        :param theInteractive:
        :type theInteractive: Handle_AIS_InteractiveObject &
        :rtype: Handle_AIS_InteractiveObject

        * Establishes the connection between the Connected Interactive Object, theInteractive, and its reference. Locates instance in theLocation and copies transformation persistence mode from theInteractive. returns created instance object (AIS_ConnectedInteractive or AIS_MultipleConnectedInteractive)

        :param theInteractive:
        :type theInteractive: Handle_AIS_InteractiveObject &
        :param theLocation:
        :type theLocation: gp_Trsf
        :rtype: Handle_AIS_InteractiveObject

        * Establishes the connection between the Connected Interactive Object, theInteractive, and its reference. Locates instance in theLocation and applies specified transformation persistence mode. returns created instance object (AIS_ConnectedInteractive or AIS_MultipleConnectedInteractive)

        :param theInteractive:
        :type theInteractive: Handle_AIS_InteractiveObject &
        :param theLocation:
        :type theLocation: gp_Trsf
        :param theTrsfPersFlag:
        :type theTrsfPersFlag: Graphic3d_TransModeFlags &
        :param theTrsfPersPoint:
        :type theTrsfPersPoint: gp_Pnt
        :rtype: Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_MultipleConnectedInteractive_Connect(self, *args)


    def HasConnection(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the object is connected to others.

        :rtype: bool

        """
        return _AIS.AIS_MultipleConnectedInteractive_HasConnection(self, *args)


    def Disconnect(self, *args) -> "void":
        """
        * Removes the connection with theInteractive.

        :param theInteractive:
        :type theInteractive: Handle_AIS_InteractiveObject &
        :rtype: None

        """
        return _AIS.AIS_MultipleConnectedInteractive_Disconnect(self, *args)


    def DisconnectAll(self, *args) -> "void":
        """
        * Clears all the connections to objects.

        :rtype: None

        """
        return _AIS.AIS_MultipleConnectedInteractive_DisconnectAll(self, *args)


    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_MultipleConnectedInteractive_Compute(self, *args)


    def AcceptShapeDecomposition(self, *args) -> "Standard_Boolean":
        """
        * Informs the graphic context that the interactive Object may be decomposed into sub-shapes for dynamic selection.

        :rtype: bool

        """
        return _AIS.AIS_MultipleConnectedInteractive_AcceptShapeDecomposition(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_MultipleConnectedInteractive(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_MultipleConnectedInteractive
AIS_MultipleConnectedInteractive.Connect = new_instancemethod(_AIS.AIS_MultipleConnectedInteractive_Connect, None, AIS_MultipleConnectedInteractive)
AIS_MultipleConnectedInteractive.HasConnection = new_instancemethod(_AIS.AIS_MultipleConnectedInteractive_HasConnection, None, AIS_MultipleConnectedInteractive)
AIS_MultipleConnectedInteractive.Disconnect = new_instancemethod(_AIS.AIS_MultipleConnectedInteractive_Disconnect, None, AIS_MultipleConnectedInteractive)
AIS_MultipleConnectedInteractive.DisconnectAll = new_instancemethod(_AIS.AIS_MultipleConnectedInteractive_DisconnectAll, None, AIS_MultipleConnectedInteractive)
AIS_MultipleConnectedInteractive.Compute = new_instancemethod(_AIS.AIS_MultipleConnectedInteractive_Compute, None, AIS_MultipleConnectedInteractive)
AIS_MultipleConnectedInteractive.AcceptShapeDecomposition = new_instancemethod(_AIS.AIS_MultipleConnectedInteractive_AcceptShapeDecomposition, None, AIS_MultipleConnectedInteractive)
AIS_MultipleConnectedInteractive_swigregister = _AIS.AIS_MultipleConnectedInteractive_swigregister
AIS_MultipleConnectedInteractive_swigregister(AIS_MultipleConnectedInteractive)

class Handle_AIS_MultipleConnectedInteractive(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_MultipleConnectedInteractive_swiginit(self, _AIS.new_Handle_AIS_MultipleConnectedInteractive(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_MultipleConnectedInteractive_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_MultipleConnectedInteractive
Handle_AIS_MultipleConnectedInteractive.Nullify = new_instancemethod(_AIS.Handle_AIS_MultipleConnectedInteractive_Nullify, None, Handle_AIS_MultipleConnectedInteractive)
Handle_AIS_MultipleConnectedInteractive.IsNull = new_instancemethod(_AIS.Handle_AIS_MultipleConnectedInteractive_IsNull, None, Handle_AIS_MultipleConnectedInteractive)
Handle_AIS_MultipleConnectedInteractive._get_reference = new_instancemethod(_AIS.Handle_AIS_MultipleConnectedInteractive__get_reference, None, Handle_AIS_MultipleConnectedInteractive)
Handle_AIS_MultipleConnectedInteractive_swigregister = _AIS.Handle_AIS_MultipleConnectedInteractive_swigregister
Handle_AIS_MultipleConnectedInteractive_swigregister(Handle_AIS_MultipleConnectedInteractive)

def Handle_AIS_MultipleConnectedInteractive_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_MultipleConnectedInteractive const":
    return _AIS.Handle_AIS_MultipleConnectedInteractive_DownCast(AnObject)
Handle_AIS_MultipleConnectedInteractive_DownCast = _AIS.Handle_AIS_MultipleConnectedInteractive_DownCast

class AIS_Plane(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the plane aComponent. If the mode aCurrentMode equals true, the drawing tool, 'Drawer' is not initialized.

        :param aComponent:
        :type aComponent: Handle_Geom_Plane &
        :param aCurrentMode: default value is Standard_False
        :type aCurrentMode: bool
        :rtype: None

        * initializes the plane aComponent and the point aCenter. If the mode aCurrentMode equals true, the drawing tool, 'Drawer' is not initialized. aCurrentMode equals true, the drawing tool, 'Drawer' is not initialized.

        :param aComponent:
        :type aComponent: Handle_Geom_Plane &
        :param aCenter:
        :type aCenter: gp_Pnt
        :param aCurrentMode: default value is Standard_False
        :type aCurrentMode: bool
        :rtype: None

        * initializes the plane aComponent, the point aCenter, and the minimum and maximum points, aPmin and aPmax. If the mode aCurrentMode equals true, the drawing tool, 'Drawer' is not initialized.

        :param aComponent:
        :type aComponent: Handle_Geom_Plane &
        :param aCenter:
        :type aCenter: gp_Pnt
        :param aPmin:
        :type aPmin: gp_Pnt
        :param aPmax:
        :type aPmax: gp_Pnt
        :param aCurrentMode: default value is Standard_False
        :type aCurrentMode: bool
        :rtype: None

        :param aComponent:
        :type aComponent: Handle_Geom_Axis2Placement &
        :param aPlaneType:
        :type aPlaneType: AIS_TypeOfPlane
        :param aCurrentMode: default value is Standard_False
        :type aCurrentMode: bool
        :rtype: None

        """
        _AIS.AIS_Plane_swiginit(self, _AIS.new_AIS_Plane(*args))

    def SetSize(self, *args) -> "void":
        """
        * Same value for x and y directions

        :param aValue:
        :type aValue: float
        :rtype: None

        * Sets the size defined by the length along the X axis XVal and the length along the Y axis YVal.

        :param Xval:
        :type Xval: float
        :param YVal:
        :type YVal: float
        :rtype: None

        """
        return _AIS.AIS_Plane_SetSize(self, *args)


    def UnsetSize(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_Plane_UnsetSize(self, *args)


    def Size(self, *args) -> "Standard_Boolean":
        """
        :param X:
        :type X: float &
        :param Y:
        :type Y: float &
        :rtype: bool

        """
        return _AIS.AIS_Plane_Size(self, *args)


    def HasOwnSize(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Plane_HasOwnSize(self, *args)


    def Component(self, *args) -> "Handle_Geom_Plane":
        """
        * Returns the component specified in SetComponent.

        :rtype: Handle_Geom_Plane

        """
        return _AIS.AIS_Plane_Component(self, *args)


    def SetComponent(self, *args) -> "void":
        """
        * Creates an instance of the plane aComponent.

        :param aComponent:
        :type aComponent: Handle_Geom_Plane &
        :rtype: None

        """
        return _AIS.AIS_Plane_SetComponent(self, *args)


    def PlaneAttributes(self, *args) -> "Standard_Boolean":
        """
        * Returns the settings for the selected plane aComponent, provided in SetPlaneAttributes. These include the points aCenter, aPmin, and aPmax

        :param aComponent:
        :type aComponent: Handle_Geom_Plane &
        :param aCenter:
        :type aCenter: gp_Pnt
        :param aPmin:
        :type aPmin: gp_Pnt
        :param aPmax:
        :type aPmax: gp_Pnt
        :rtype: bool

        """
        return _AIS.AIS_Plane_PlaneAttributes(self, *args)


    def SetPlaneAttributes(self, *args) -> "void":
        """
        * Allows you to provide settings other than default ones for the selected plane. These include: center point aCenter, maximum aPmax and minimum aPmin.

        :param aComponent:
        :type aComponent: Handle_Geom_Plane &
        :param aCenter:
        :type aCenter: gp_Pnt
        :param aPmin:
        :type aPmin: gp_Pnt
        :param aPmax:
        :type aPmax: gp_Pnt
        :rtype: None

        """
        return _AIS.AIS_Plane_SetPlaneAttributes(self, *args)


    def Center(self, *args) -> "gp_Pnt const":
        """
        * Returns the coordinates of the center point.

        :rtype: gp_Pnt

        """
        return _AIS.AIS_Plane_Center(self, *args)


    def SetCenter(self, *args) -> "void":
        """
        * Provides settings for the center aCenter other than (0, 0, 0).

        :param aCenter:
        :type aCenter: gp_Pnt
        :rtype: None

        """
        return _AIS.AIS_Plane_SetCenter(self, *args)


    def SetAxis2Placement(self, *args) -> "void":
        """
        * Allows you to provide settings for the position and direction of one of the plane's axes, aComponent, in 3D space. The coordinate system used is right-handed, and the type of plane aPlaneType is one of: - AIS_ TOPL_Unknown - AIS_ TOPL_XYPlane - AIS_ TOPL_XZPlane - AIS_ TOPL_YZPlane}.

        :param aComponent:
        :type aComponent: Handle_Geom_Axis2Placement &
        :param aPlaneType:
        :type aPlaneType: AIS_TypeOfPlane
        :rtype: None

        """
        return _AIS.AIS_Plane_SetAxis2Placement(self, *args)


    def Axis2Placement(self, *args) -> "Handle_Geom_Axis2Placement":
        """
        * Returns the position of the plane's axis2 system identifying the x, y, or z axis and giving the plane a direction in 3D space. An axis2 system is a right-handed coordinate system.

        :rtype: Handle_Geom_Axis2Placement

        """
        return _AIS.AIS_Plane_Axis2Placement(self, *args)


    def TypeOfPlane(self, *args) -> "AIS_TypeOfPlane":
        """
        * Returns the type of plane - xy, yz, xz or unknown.

        :rtype: AIS_TypeOfPlane

        """
        return _AIS.AIS_Plane_TypeOfPlane(self, *args)


    def IsXYZPlane(self, *args) -> "Standard_Boolean":
        """
        * Returns the type of plane - xy, yz, or xz.

        :rtype: bool

        """
        return _AIS.AIS_Plane_IsXYZPlane(self, *args)


    def CurrentMode(self, *args) -> "Standard_Boolean":
        """
        * Returns the non-default current display mode set by SetCurrentMode.

        :rtype: bool

        """
        return _AIS.AIS_Plane_CurrentMode(self, *args)


    def SetCurrentMode(self, *args) -> "void":
        """
        * Allows you to provide settings for a non-default current display mode.

        :param aCurrentMode:
        :type aCurrentMode: bool
        :rtype: None

        """
        return _AIS.AIS_Plane_SetCurrentMode(self, *args)


    def TypeOfSensitivity(self, *args) -> "Select3D_TypeOfSensitivity":
        """
        * Returns the type of sensitivity for the plane;

        :rtype: Select3D_TypeOfSensitivity

        """
        return _AIS.AIS_Plane_TypeOfSensitivity(self, *args)


    def SetTypeOfSensitivity(self, *args) -> "void":
        """
        * Sets the type of sensitivity for the plane.

        :param theTypeOfSensitivity:
        :type theTypeOfSensitivity: Select3D_TypeOfSensitivity
        :rtype: None

        """
        return _AIS.AIS_Plane_SetTypeOfSensitivity(self, *args)


    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_Plane_Compute(self, *args)


    def ComputeSelection(self, *args) -> "void":
        """
        :param theSelection:
        :type theSelection: Handle_SelectMgr_Selection &
        :param theMode:
        :type theMode: int
        :rtype: void

        """
        return _AIS.AIS_Plane_ComputeSelection(self, *args)


    def SetColor(self, *args) -> "void":
        """
        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_Plane_SetColor(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Plane(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Plane
AIS_Plane.SetSize = new_instancemethod(_AIS.AIS_Plane_SetSize, None, AIS_Plane)
AIS_Plane.UnsetSize = new_instancemethod(_AIS.AIS_Plane_UnsetSize, None, AIS_Plane)
AIS_Plane.Size = new_instancemethod(_AIS.AIS_Plane_Size, None, AIS_Plane)
AIS_Plane.HasOwnSize = new_instancemethod(_AIS.AIS_Plane_HasOwnSize, None, AIS_Plane)
AIS_Plane.Component = new_instancemethod(_AIS.AIS_Plane_Component, None, AIS_Plane)
AIS_Plane.SetComponent = new_instancemethod(_AIS.AIS_Plane_SetComponent, None, AIS_Plane)
AIS_Plane.PlaneAttributes = new_instancemethod(_AIS.AIS_Plane_PlaneAttributes, None, AIS_Plane)
AIS_Plane.SetPlaneAttributes = new_instancemethod(_AIS.AIS_Plane_SetPlaneAttributes, None, AIS_Plane)
AIS_Plane.Center = new_instancemethod(_AIS.AIS_Plane_Center, None, AIS_Plane)
AIS_Plane.SetCenter = new_instancemethod(_AIS.AIS_Plane_SetCenter, None, AIS_Plane)
AIS_Plane.SetAxis2Placement = new_instancemethod(_AIS.AIS_Plane_SetAxis2Placement, None, AIS_Plane)
AIS_Plane.Axis2Placement = new_instancemethod(_AIS.AIS_Plane_Axis2Placement, None, AIS_Plane)
AIS_Plane.TypeOfPlane = new_instancemethod(_AIS.AIS_Plane_TypeOfPlane, None, AIS_Plane)
AIS_Plane.IsXYZPlane = new_instancemethod(_AIS.AIS_Plane_IsXYZPlane, None, AIS_Plane)
AIS_Plane.CurrentMode = new_instancemethod(_AIS.AIS_Plane_CurrentMode, None, AIS_Plane)
AIS_Plane.SetCurrentMode = new_instancemethod(_AIS.AIS_Plane_SetCurrentMode, None, AIS_Plane)
AIS_Plane.TypeOfSensitivity = new_instancemethod(_AIS.AIS_Plane_TypeOfSensitivity, None, AIS_Plane)
AIS_Plane.SetTypeOfSensitivity = new_instancemethod(_AIS.AIS_Plane_SetTypeOfSensitivity, None, AIS_Plane)
AIS_Plane.Compute = new_instancemethod(_AIS.AIS_Plane_Compute, None, AIS_Plane)
AIS_Plane.ComputeSelection = new_instancemethod(_AIS.AIS_Plane_ComputeSelection, None, AIS_Plane)
AIS_Plane.SetColor = new_instancemethod(_AIS.AIS_Plane_SetColor, None, AIS_Plane)
AIS_Plane_swigregister = _AIS.AIS_Plane_swigregister
AIS_Plane_swigregister(AIS_Plane)

class Handle_AIS_Plane(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Plane_swiginit(self, _AIS.new_Handle_AIS_Plane(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Plane_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Plane
Handle_AIS_Plane.Nullify = new_instancemethod(_AIS.Handle_AIS_Plane_Nullify, None, Handle_AIS_Plane)
Handle_AIS_Plane.IsNull = new_instancemethod(_AIS.Handle_AIS_Plane_IsNull, None, Handle_AIS_Plane)
Handle_AIS_Plane._get_reference = new_instancemethod(_AIS.Handle_AIS_Plane__get_reference, None, Handle_AIS_Plane)
Handle_AIS_Plane_swigregister = _AIS.Handle_AIS_Plane_swigregister
Handle_AIS_Plane_swigregister(Handle_AIS_Plane)

def Handle_AIS_Plane_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Plane const":
    return _AIS.Handle_AIS_Plane_DownCast(AnObject)
Handle_AIS_Plane_DownCast = _AIS.Handle_AIS_Plane_DownCast

class AIS_PlaneTrihedron(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the plane aPlane. The plane trihedron is constructed from this and an axis.

        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        """
        _AIS.AIS_PlaneTrihedron_swiginit(self, _AIS.new_AIS_PlaneTrihedron(*args))

    def Component(self, *args) -> "Handle_Geom_Plane":
        """
        * Returns the component specified in SetComponent.

        :rtype: Handle_Geom_Plane

        """
        return _AIS.AIS_PlaneTrihedron_Component(self, *args)


    def SetComponent(self, *args) -> "void":
        """
        * Creates an instance of the component object aPlane.

        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        """
        return _AIS.AIS_PlaneTrihedron_SetComponent(self, *args)


    def XAxis(self, *args) -> "Handle_AIS_Line":
        """
        * Returns the 'XAxis'.

        :rtype: Handle_AIS_Line

        """
        return _AIS.AIS_PlaneTrihedron_XAxis(self, *args)


    def YAxis(self, *args) -> "Handle_AIS_Line":
        """
        * Returns the 'YAxis'.

        :rtype: Handle_AIS_Line

        """
        return _AIS.AIS_PlaneTrihedron_YAxis(self, *args)


    def Position(self, *args) -> "Handle_AIS_Point":
        """
        * Returns the point of origin of the plane trihedron.

        :rtype: Handle_AIS_Point

        """
        return _AIS.AIS_PlaneTrihedron_Position(self, *args)


    def SetLength(self, *args) -> "void":
        """
        * Sets the length of the X and Y axes.

        :param theLength:
        :type theLength: float
        :rtype: None

        """
        return _AIS.AIS_PlaneTrihedron_SetLength(self, *args)


    def GetLength(self, *args) -> "Standard_Real":
        """
        * Returns the length of X and Y axes.

        :rtype: float

        """
        return _AIS.AIS_PlaneTrihedron_GetLength(self, *args)


    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_PlaneTrihedron_Compute(self, *args)


    def SetColor(self, *args) -> "void":
        """
        * Allows you to provide settings for the color aColor.

        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_PlaneTrihedron_SetColor(self, *args)


    def SetXLabel(self, *args) -> "void":
        """
        :param aLabel:
        :type aLabel: TCollection_AsciiString &
        :rtype: None

        """
        return _AIS.AIS_PlaneTrihedron_SetXLabel(self, *args)


    def SetYLabel(self, *args) -> "void":
        """
        :param aLabel:
        :type aLabel: TCollection_AsciiString &
        :rtype: None

        """
        return _AIS.AIS_PlaneTrihedron_SetYLabel(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_PlaneTrihedron(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_PlaneTrihedron
AIS_PlaneTrihedron.Component = new_instancemethod(_AIS.AIS_PlaneTrihedron_Component, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.SetComponent = new_instancemethod(_AIS.AIS_PlaneTrihedron_SetComponent, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.XAxis = new_instancemethod(_AIS.AIS_PlaneTrihedron_XAxis, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.YAxis = new_instancemethod(_AIS.AIS_PlaneTrihedron_YAxis, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.Position = new_instancemethod(_AIS.AIS_PlaneTrihedron_Position, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.SetLength = new_instancemethod(_AIS.AIS_PlaneTrihedron_SetLength, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.GetLength = new_instancemethod(_AIS.AIS_PlaneTrihedron_GetLength, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.Compute = new_instancemethod(_AIS.AIS_PlaneTrihedron_Compute, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.SetColor = new_instancemethod(_AIS.AIS_PlaneTrihedron_SetColor, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.SetXLabel = new_instancemethod(_AIS.AIS_PlaneTrihedron_SetXLabel, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron.SetYLabel = new_instancemethod(_AIS.AIS_PlaneTrihedron_SetYLabel, None, AIS_PlaneTrihedron)
AIS_PlaneTrihedron_swigregister = _AIS.AIS_PlaneTrihedron_swigregister
AIS_PlaneTrihedron_swigregister(AIS_PlaneTrihedron)

class Handle_AIS_PlaneTrihedron(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_PlaneTrihedron_swiginit(self, _AIS.new_Handle_AIS_PlaneTrihedron(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_PlaneTrihedron_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_PlaneTrihedron
Handle_AIS_PlaneTrihedron.Nullify = new_instancemethod(_AIS.Handle_AIS_PlaneTrihedron_Nullify, None, Handle_AIS_PlaneTrihedron)
Handle_AIS_PlaneTrihedron.IsNull = new_instancemethod(_AIS.Handle_AIS_PlaneTrihedron_IsNull, None, Handle_AIS_PlaneTrihedron)
Handle_AIS_PlaneTrihedron._get_reference = new_instancemethod(_AIS.Handle_AIS_PlaneTrihedron__get_reference, None, Handle_AIS_PlaneTrihedron)
Handle_AIS_PlaneTrihedron_swigregister = _AIS.Handle_AIS_PlaneTrihedron_swigregister
Handle_AIS_PlaneTrihedron_swigregister(Handle_AIS_PlaneTrihedron)

def Handle_AIS_PlaneTrihedron_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_PlaneTrihedron const":
    return _AIS.Handle_AIS_PlaneTrihedron_DownCast(AnObject)
Handle_AIS_PlaneTrihedron_DownCast = _AIS.Handle_AIS_PlaneTrihedron_DownCast

class AIS_Point(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the point aComponent from which the point datum will be built.

        :param aComponent:
        :type aComponent: Handle_Geom_Point &
        :rtype: None

        """
        _AIS.AIS_Point_swiginit(self, _AIS.new_AIS_Point(*args))

    def Component(self, *args) -> "Handle_Geom_Point":
        """
        * Returns the component specified in SetComponent.

        :rtype: Handle_Geom_Point

        """
        return _AIS.AIS_Point_Component(self, *args)


    def SetComponent(self, *args) -> "void":
        """
        * Constructs an instance of the point aComponent.

        :param aComponent:
        :type aComponent: Handle_Geom_Point &
        :rtype: None

        """
        return _AIS.AIS_Point_SetComponent(self, *args)


    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_Point_Compute(self, *args)


    def SetColor(self, *args) -> "void":
        """
        * Allows you to provide settings for the cp;pr aColor.

        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_Point_SetColor(self, *args)


    def SetMarker(self, *args) -> "void":
        """
        * Allows you to provide settings for a marker. These include - type of marker, - marker color, - scale factor.

        :param aType:
        :type aType: Aspect_TypeOfMarker
        :rtype: None

        """
        return _AIS.AIS_Point_SetMarker(self, *args)


    def UnsetMarker(self, *args) -> "void":
        """
        * Removes the marker settings.

        :rtype: None

        """
        return _AIS.AIS_Point_UnsetMarker(self, *args)


    def HasMarker(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the point datum has a marker.

        :rtype: bool

        """
        return _AIS.AIS_Point_HasMarker(self, *args)


    def Vertex(self, *args) -> "TopoDS_Vertex":
        """
        * Converts a point into a vertex.

        :rtype: TopoDS_Vertex

        """
        return _AIS.AIS_Point_Vertex(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Point(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Point
AIS_Point.Component = new_instancemethod(_AIS.AIS_Point_Component, None, AIS_Point)
AIS_Point.SetComponent = new_instancemethod(_AIS.AIS_Point_SetComponent, None, AIS_Point)
AIS_Point.Compute = new_instancemethod(_AIS.AIS_Point_Compute, None, AIS_Point)
AIS_Point.SetColor = new_instancemethod(_AIS.AIS_Point_SetColor, None, AIS_Point)
AIS_Point.SetMarker = new_instancemethod(_AIS.AIS_Point_SetMarker, None, AIS_Point)
AIS_Point.UnsetMarker = new_instancemethod(_AIS.AIS_Point_UnsetMarker, None, AIS_Point)
AIS_Point.HasMarker = new_instancemethod(_AIS.AIS_Point_HasMarker, None, AIS_Point)
AIS_Point.Vertex = new_instancemethod(_AIS.AIS_Point_Vertex, None, AIS_Point)
AIS_Point_swigregister = _AIS.AIS_Point_swigregister
AIS_Point_swigregister(AIS_Point)

class Handle_AIS_Point(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Point_swiginit(self, _AIS.new_Handle_AIS_Point(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Point_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Point
Handle_AIS_Point.Nullify = new_instancemethod(_AIS.Handle_AIS_Point_Nullify, None, Handle_AIS_Point)
Handle_AIS_Point.IsNull = new_instancemethod(_AIS.Handle_AIS_Point_IsNull, None, Handle_AIS_Point)
Handle_AIS_Point._get_reference = new_instancemethod(_AIS.Handle_AIS_Point__get_reference, None, Handle_AIS_Point)
Handle_AIS_Point_swigregister = _AIS.Handle_AIS_Point_swigregister
Handle_AIS_Point_swigregister(Handle_AIS_Point)

def Handle_AIS_Point_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Point const":
    return _AIS.Handle_AIS_Point_DownCast(AnObject)
Handle_AIS_Point_DownCast = _AIS.Handle_AIS_Point_DownCast

class AIS_PointCloud(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    DM_Points = _AIS.AIS_PointCloud_DM_Points
    DM_BndBox = _AIS.AIS_PointCloud_DM_BndBox

    def __init__(self, *args):
        """
        * Constructor.

        :rtype: None

        """
        _AIS.AIS_PointCloud_swiginit(self, _AIS.new_AIS_PointCloud(*args))

    def SetPoints(self, *args) -> "void":
        """
        * Sets the points from array of points. Method will not copy the input data - array will be stored as handle. @param thePoints [in] the array of points

        :param thePoints:
        :type thePoints: Handle_Graphic3d_ArrayOfPoints &
        :rtype: void

        * Sets the points with optional colors. The input data will be copied into internal buffer. The input arrays should have equal length, otherwise the presentation will not be computed and displayed. @param theCoords [in] the array of coordinates @param theColors [in] optional array of colors @param theNormals [in] optional array of normals

        :param theCoords:
        :type theCoords: Handle_TColgp_HArray1OfPnt
        :param theColors: default value is NULL
        :type theColors: Handle_Quantity_HArray1OfColor &
        :param theNormals: default value is NULL
        :type theNormals: Handle_TColgp_HArray1OfDir
        :rtype: void

        """
        return _AIS.AIS_PointCloud_SetPoints(self, *args)


    def GetPoints(self, *args) -> "Handle_Graphic3d_ArrayOfPoints const":
        """
        * Get the points array. Method might be overridden to fill in points array dynamically from application data structures. returns the array of points

        :rtype: Handle_Graphic3d_ArrayOfPoints

        """
        return _AIS.AIS_PointCloud_GetPoints(self, *args)


    def GetBoundingBox(self, *args) -> "Bnd_Box":
        """
        * Get bounding box for presentation.

        :rtype: Bnd_Box

        """
        return _AIS.AIS_PointCloud_GetBoundingBox(self, *args)


    def SetColor(self, *args) -> "void":
        """
        * Setup custom color. Affects presentation only when no per-point color attribute has been assigned.

        :param theColor:
        :type theColor: Quantity_NameOfColor
        :rtype: void

        * Setup custom color. Affects presentation only when no per-point color attribute has been assigned.

        :param theColor:
        :type theColor: Quantity_Color &
        :rtype: void

        """
        return _AIS.AIS_PointCloud_SetColor(self, *args)


    def SetMaterial(self, *args) -> "void":
        """
        * Setup custom material. Affects presentation only when normals are defined.

        :param theMatName:
        :type theMatName: Graphic3d_NameOfMaterial
        :rtype: void

        * Setup custom material. Affects presentation only when normals are defined.

        :param theMat:
        :type theMat: Graphic3d_MaterialAspect &
        :rtype: void

        """
        return _AIS.AIS_PointCloud_SetMaterial(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_PointCloud(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_PointCloud
AIS_PointCloud.SetPoints = new_instancemethod(_AIS.AIS_PointCloud_SetPoints, None, AIS_PointCloud)
AIS_PointCloud.GetPoints = new_instancemethod(_AIS.AIS_PointCloud_GetPoints, None, AIS_PointCloud)
AIS_PointCloud.GetBoundingBox = new_instancemethod(_AIS.AIS_PointCloud_GetBoundingBox, None, AIS_PointCloud)
AIS_PointCloud.SetColor = new_instancemethod(_AIS.AIS_PointCloud_SetColor, None, AIS_PointCloud)
AIS_PointCloud.SetMaterial = new_instancemethod(_AIS.AIS_PointCloud_SetMaterial, None, AIS_PointCloud)
AIS_PointCloud_swigregister = _AIS.AIS_PointCloud_swigregister
AIS_PointCloud_swigregister(AIS_PointCloud)

class Handle_AIS_PointCloud(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_PointCloud_swiginit(self, _AIS.new_Handle_AIS_PointCloud(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_PointCloud_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_PointCloud
Handle_AIS_PointCloud.Nullify = new_instancemethod(_AIS.Handle_AIS_PointCloud_Nullify, None, Handle_AIS_PointCloud)
Handle_AIS_PointCloud.IsNull = new_instancemethod(_AIS.Handle_AIS_PointCloud_IsNull, None, Handle_AIS_PointCloud)
Handle_AIS_PointCloud._get_reference = new_instancemethod(_AIS.Handle_AIS_PointCloud__get_reference, None, Handle_AIS_PointCloud)
Handle_AIS_PointCloud_swigregister = _AIS.Handle_AIS_PointCloud_swigregister
Handle_AIS_PointCloud_swigregister(Handle_AIS_PointCloud)

def Handle_AIS_PointCloud_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_PointCloud const":
    return _AIS.Handle_AIS_PointCloud_DownCast(AnObject)
Handle_AIS_PointCloud_DownCast = _AIS.Handle_AIS_PointCloud_DownCast

class AIS_Relation(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetColor(self, *args) -> "void":
        """
        * Allows you to provide settings for the color aColor of the lines representing the relation between the two shapes.

        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_Relation_SetColor(self, *args)


    def KindOfDimension(self, *args) -> "AIS_KindOfDimension":
        """
        * Indicates that the type of dimension is unknown.

        :rtype: AIS_KindOfDimension

        """
        return _AIS.AIS_Relation_KindOfDimension(self, *args)


    def IsMovable(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the interactive object is movable.

        :rtype: bool

        """
        return _AIS.AIS_Relation_IsMovable(self, *args)


    def FirstShape(self, *args) -> "TopoDS_Shape const":
        """
        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_Relation_FirstShape(self, *args)


    def SetFirstShape(self, *args) -> "void":
        """
        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :rtype: void

        """
        return _AIS.AIS_Relation_SetFirstShape(self, *args)


    def SecondShape(self, *args) -> "TopoDS_Shape const":
        """
        * Returns the second shape.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_Relation_SecondShape(self, *args)


    def SetSecondShape(self, *args) -> "void":
        """
        * Allows you to identify the second shape aSShape relative to the first.

        :param aSShape:
        :type aSShape: TopoDS_Shape &
        :rtype: void

        """
        return _AIS.AIS_Relation_SetSecondShape(self, *args)


    def SetBndBox(self, *args) -> "void":
        """
        :param Xmin:
        :type Xmin: float
        :param Ymin:
        :type Ymin: float
        :param Zmin:
        :type Zmin: float
        :param Xmax:
        :type Xmax: float
        :param Ymax:
        :type Ymax: float
        :param Zmax:
        :type Zmax: float
        :rtype: None

        """
        return _AIS.AIS_Relation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_Relation_UnsetBndBox(self, *args)


    def Plane(self, *args) -> "Handle_Geom_Plane":
        """
        * Returns the plane.

        :rtype: Handle_Geom_Plane

        """
        return _AIS.AIS_Relation_Plane(self, *args)


    def SetPlane(self, *args) -> "void":
        """
        * Allows you to set the plane aPlane. This is used to define relations and dimensions in several daughter classes.

        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        """
        return _AIS.AIS_Relation_SetPlane(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * Returns the value of each object in the relation.

        :rtype: float

        """
        return _AIS.AIS_Relation_Value(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Allows you to provide settings for the value aVal for each object in the relation.

        :param aVal:
        :type aVal: float
        :rtype: None

        """
        return _AIS.AIS_Relation_SetValue(self, *args)


    def Position(self, *args) -> "gp_Pnt const":
        """
        * Returns the position set using SetPosition.

        :rtype: gp_Pnt

        """
        return _AIS.AIS_Relation_Position(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Allows you to provide the objects in the relation with settings for a non-default position.

        :param aPosition:
        :type aPosition: gp_Pnt
        :rtype: None

        """
        return _AIS.AIS_Relation_SetPosition(self, *args)


    def Text(self, *args) -> "TCollection_ExtendedString const &":
        """
        * Returns settings for text aspect.

        :rtype: TCollection_ExtendedString

        """
        return _AIS.AIS_Relation_Text(self, *args)


    def SetText(self, *args) -> "void":
        """
        * Allows you to provide the settings aText for text aspect.

        :param aText:
        :type aText: TCollection_ExtendedString &
        :rtype: None

        """
        return _AIS.AIS_Relation_SetText(self, *args)


    def ArrowSize(self, *args) -> "Standard_Real":
        """
        * Returns the value for the size of the arrow identifying the relation between the two shapes.

        :rtype: float

        """
        return _AIS.AIS_Relation_ArrowSize(self, *args)


    def SetArrowSize(self, *args) -> "void":
        """
        * Allows you to provide settings for the size of the arrow anArrowsize identifying the relation between the two shapes.

        :param anArrowSize:
        :type anArrowSize: float
        :rtype: None

        """
        return _AIS.AIS_Relation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args) -> "DsgPrs_ArrowSide":
        """
        * Returns the value of the symbol presentation. This will be one of: - AS_NONE - none - AS_FIRSTAR - first arrow - AS_LASTAR - last arrow - AS_BOTHAR - both arrows - AS_FIRSTPT - first point - AS_LASTPT - last point - AS_BOTHPT - both points - AS_FIRSTAR_LASTPT - first arrow, last point - AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: DsgPrs_ArrowSide

        """
        return _AIS.AIS_Relation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args) -> "void":
        """
        * Allows you to provide settings for the symbol presentation.

        :param aSymbolPrs:
        :type aSymbolPrs: DsgPrs_ArrowSide
        :rtype: None

        """
        return _AIS.AIS_Relation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args) -> "void":
        """
        * Allows you to set the status of the extension shape by the index aIndex. The status will be one of the following: - 0 - there is no connection to a shape; - 1 - there is a connection to the first shape; - 2 - there is a connection to the second shape.

        :param aIndex:
        :type aIndex: int
        :rtype: None

        """
        return _AIS.AIS_Relation_SetExtShape(self, *args)


    def ExtShape(self, *args) -> "Standard_Integer":
        """
        * Returns the status index of the extension shape.

        :rtype: int

        """
        return _AIS.AIS_Relation_ExtShape(self, *args)


    def SetAutomaticPosition(self, *args) -> "void":
        """
        :param aStatus:
        :type aStatus: bool
        :rtype: None

        """
        return _AIS.AIS_Relation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Relation_AutomaticPosition(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Relation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Relation
AIS_Relation.SetColor = new_instancemethod(_AIS.AIS_Relation_SetColor, None, AIS_Relation)
AIS_Relation.KindOfDimension = new_instancemethod(_AIS.AIS_Relation_KindOfDimension, None, AIS_Relation)
AIS_Relation.IsMovable = new_instancemethod(_AIS.AIS_Relation_IsMovable, None, AIS_Relation)
AIS_Relation.FirstShape = new_instancemethod(_AIS.AIS_Relation_FirstShape, None, AIS_Relation)
AIS_Relation.SetFirstShape = new_instancemethod(_AIS.AIS_Relation_SetFirstShape, None, AIS_Relation)
AIS_Relation.SecondShape = new_instancemethod(_AIS.AIS_Relation_SecondShape, None, AIS_Relation)
AIS_Relation.SetSecondShape = new_instancemethod(_AIS.AIS_Relation_SetSecondShape, None, AIS_Relation)
AIS_Relation.SetBndBox = new_instancemethod(_AIS.AIS_Relation_SetBndBox, None, AIS_Relation)
AIS_Relation.UnsetBndBox = new_instancemethod(_AIS.AIS_Relation_UnsetBndBox, None, AIS_Relation)
AIS_Relation.Plane = new_instancemethod(_AIS.AIS_Relation_Plane, None, AIS_Relation)
AIS_Relation.SetPlane = new_instancemethod(_AIS.AIS_Relation_SetPlane, None, AIS_Relation)
AIS_Relation.Value = new_instancemethod(_AIS.AIS_Relation_Value, None, AIS_Relation)
AIS_Relation.SetValue = new_instancemethod(_AIS.AIS_Relation_SetValue, None, AIS_Relation)
AIS_Relation.Position = new_instancemethod(_AIS.AIS_Relation_Position, None, AIS_Relation)
AIS_Relation.SetPosition = new_instancemethod(_AIS.AIS_Relation_SetPosition, None, AIS_Relation)
AIS_Relation.Text = new_instancemethod(_AIS.AIS_Relation_Text, None, AIS_Relation)
AIS_Relation.SetText = new_instancemethod(_AIS.AIS_Relation_SetText, None, AIS_Relation)
AIS_Relation.ArrowSize = new_instancemethod(_AIS.AIS_Relation_ArrowSize, None, AIS_Relation)
AIS_Relation.SetArrowSize = new_instancemethod(_AIS.AIS_Relation_SetArrowSize, None, AIS_Relation)
AIS_Relation.SymbolPrs = new_instancemethod(_AIS.AIS_Relation_SymbolPrs, None, AIS_Relation)
AIS_Relation.SetSymbolPrs = new_instancemethod(_AIS.AIS_Relation_SetSymbolPrs, None, AIS_Relation)
AIS_Relation.SetExtShape = new_instancemethod(_AIS.AIS_Relation_SetExtShape, None, AIS_Relation)
AIS_Relation.ExtShape = new_instancemethod(_AIS.AIS_Relation_ExtShape, None, AIS_Relation)
AIS_Relation.SetAutomaticPosition = new_instancemethod(_AIS.AIS_Relation_SetAutomaticPosition, None, AIS_Relation)
AIS_Relation.AutomaticPosition = new_instancemethod(_AIS.AIS_Relation_AutomaticPosition, None, AIS_Relation)
AIS_Relation_swigregister = _AIS.AIS_Relation_swigregister
AIS_Relation_swigregister(AIS_Relation)

class Handle_AIS_Relation(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Relation_swiginit(self, _AIS.new_Handle_AIS_Relation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Relation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Relation
Handle_AIS_Relation.Nullify = new_instancemethod(_AIS.Handle_AIS_Relation_Nullify, None, Handle_AIS_Relation)
Handle_AIS_Relation.IsNull = new_instancemethod(_AIS.Handle_AIS_Relation_IsNull, None, Handle_AIS_Relation)
Handle_AIS_Relation._get_reference = new_instancemethod(_AIS.Handle_AIS_Relation__get_reference, None, Handle_AIS_Relation)
Handle_AIS_Relation_swigregister = _AIS.Handle_AIS_Relation_swigregister
Handle_AIS_Relation_swigregister(Handle_AIS_Relation)

def Handle_AIS_Relation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Relation const":
    return _AIS.Handle_AIS_Relation_DownCast(AnObject)
Handle_AIS_Relation_DownCast = _AIS.Handle_AIS_Relation_DownCast

class AIS_Shape(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes construction of the shape shap from wires, edges and vertices.

        :param shap:
        :type shap: TopoDS_Shape &
        :rtype: None

        """
        _AIS.AIS_Shape_swiginit(self, _AIS.new_AIS_Shape(*args))

    def AcceptShapeDecomposition(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Interactive Object accepts shape decomposition.

        :rtype: bool

        """
        return _AIS.AIS_Shape_AcceptShapeDecomposition(self, *args)


    def Set(self, *args) -> "void":
        """
        * Constructs an instance of the shape object ashape.

        :param ashap:
        :type ashap: TopoDS_Shape &
        :rtype: None

        """
        return _AIS.AIS_Shape_Set(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape const":
        """
        * Returns this shape object.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_Shape_Shape(self, *args)


    def SetOwnDeviationCoefficient(self, *args) -> "void":
        """
        * Sets a local value for deviation coefficient for this specific shape.

        :rtype: bool

        * Sets a local value for deviation coefficient for this specific shape.

        :param aCoefficient:
        :type aCoefficient: float
        :rtype: None

        """
        return _AIS.AIS_Shape_SetOwnDeviationCoefficient(self, *args)


    def SetOwnHLRDeviationCoefficient(self, *args) -> "void":
        """
        * Sets a local value for HLR deviation coefficient for this specific shape.

        :rtype: bool

        * sets myOwnHLRDeviationCoefficient field in AIS_Drawer & recomputes presentation

        :param aCoefficient:
        :type aCoefficient: float
        :rtype: None

        """
        return _AIS.AIS_Shape_SetOwnHLRDeviationCoefficient(self, *args)


    def SetAngleAndDeviation(self, *args) -> "void":
        """
        * this compute a new angle and Deviation from the value anAngle and set the values stored in myDrawer with these that become local to the shape

        :param anAngle:
        :type anAngle: float
        :rtype: None

        """
        return _AIS.AIS_Shape_SetAngleAndDeviation(self, *args)


    def UserAngle(self, *args) -> "Standard_Real":
        """
        * gives back the angle initial value put by the User.

        :rtype: float

        """
        return _AIS.AIS_Shape_UserAngle(self, *args)


    def SetOwnDeviationAngle(self, *args) -> "void":
        """
        * Sets a local value for deviation angle for this specific shape.

        :rtype: bool

        * sets myOwnDeviationAngle field in AIS_Drawer & recomputes presentation

        :param anAngle:
        :type anAngle: float
        :rtype: None

        """
        return _AIS.AIS_Shape_SetOwnDeviationAngle(self, *args)


    def SetHLRAngleAndDeviation(self, *args) -> "void":
        """
        * this compute a new Angle and Deviation from the value anAngle for HLR and set the values stored in myDrawer for with these that become local to the shape

        :param anAngle:
        :type anAngle: float
        :rtype: None

        """
        return _AIS.AIS_Shape_SetHLRAngleAndDeviation(self, *args)


    def SetOwnHLRDeviationAngle(self, *args) -> "void":
        """
        * Sets a local value for HLR deviation angle for this specific shape.

        :rtype: bool

        * sets myOwnHLRDeviationAngle field in AIS_Drawer & recomputes presentation

        :param anAngle:
        :type anAngle: float
        :rtype: None

        """
        return _AIS.AIS_Shape_SetOwnHLRDeviationAngle(self, *args)


    def OwnDeviationCoefficient(self, *args) -> "Standard_Boolean":
        """
        * Returns true and the values of the deviation coefficient aCoefficient and the previous deviation coefficient aPreviousCoefficient. If these values are not already set, false is returned.

        :param aCoefficient:
        :type aCoefficient: float &
        :param aPreviousCoefficient:
        :type aPreviousCoefficient: float &
        :rtype: bool

        """
        return _AIS.AIS_Shape_OwnDeviationCoefficient(self, *args)


    def OwnHLRDeviationCoefficient(self, *args) -> "Standard_Boolean":
        """
        * Returns true and the values of the HLR deviation coefficient aCoefficient and the previous HLR deviation coefficient aPreviousCoefficient. If these values are not already set, false is returned.

        :param aCoefficient:
        :type aCoefficient: float &
        :param aPreviousCoefficient:
        :type aPreviousCoefficient: float &
        :rtype: bool

        """
        return _AIS.AIS_Shape_OwnHLRDeviationCoefficient(self, *args)


    def OwnDeviationAngle(self, *args) -> "Standard_Boolean":
        """
        * Returns true and the values of the deviation angle anAngle and the previous deviation angle aPreviousAngle. If these values are not already set, false is returned.

        :param anAngle:
        :type anAngle: float &
        :param aPreviousAngle:
        :type aPreviousAngle: float &
        :rtype: bool

        """
        return _AIS.AIS_Shape_OwnDeviationAngle(self, *args)


    def OwnHLRDeviationAngle(self, *args) -> "Standard_Boolean":
        """
        * Returns true and the values of the HLR deviation angle anAngle and of the previous HLR deviation angle aPreviousAngle. If these values are not already set, false is returned.

        :param anAngle:
        :type anAngle: float &
        :param aPreviousAngle:
        :type aPreviousAngle: float &
        :rtype: bool

        """
        return _AIS.AIS_Shape_OwnHLRDeviationAngle(self, *args)


    def SetTypeOfHLR(self, *args) -> "void":
        """
        * Sets the type of HLR algorithm used by the shape

        :param theTypeOfHLR:
        :type theTypeOfHLR: Prs3d_TypeOfHLR
        :rtype: None

        """
        return _AIS.AIS_Shape_SetTypeOfHLR(self, *args)


    def TypeOfHLR(self, *args) -> "Prs3d_TypeOfHLR":
        """
        * Gets the type of HLR algorithm

        :rtype: Prs3d_TypeOfHLR

        """
        return _AIS.AIS_Shape_TypeOfHLR(self, *args)


    def SetColor(self, *args) -> "void":
        """
        * Sets the color aColor in the reconstructed compound shape. Acts via the Drawer methods below on the appearance of: - free boundaries: AIS_Drawer_FreeBoundaryAspect, - isos: AIS_Drawer_UIsoAspect, AIS_Drawer_VIsoAspect, - shared boundaries: AIS_Drawer_UnFreeBoundaryAspect, - shading: AIS_Drawer_ShadingAspect, - visible line color in hidden line mode: AIS_Drawer_SeenLineAspect - hidden line color in hidden line mode: AIS_Drawer_HiddenLineAspect.

        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: void

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: void

        """
        return _AIS.AIS_Shape_SetColor(self, *args)


    def SetMaterial(self, *args) -> "void":
        """
        :param aName:
        :type aName: Graphic3d_NameOfMaterial
        :rtype: void

        * Allows you to provide settings for the material aName in the reconstructed compound shape.

        :param aName:
        :type aName: Graphic3d_MaterialAspect &
        :rtype: void

        """
        return _AIS.AIS_Shape_SetMaterial(self, *args)


    def BoundingBox(self, *args) -> "Bnd_Box const &":
        """
        * Constructs a bounding box with which to reconstruct compound topological shapes for presentation.

        :rtype: Bnd_Box

        """
        return _AIS.AIS_Shape_BoundingBox(self, *args)


    def Color(self, *args) -> "void":
        """
        * Returns the NameOfColor attributes of the shape accordingly to the current facing model;

        :rtype: Quantity_NameOfColor

        * Returns the Color attributes of the shape accordingly to the current facing model;

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: void

        """
        return _AIS.AIS_Shape_Color(self, *args)


    def SelectionType(*args) -> "TopAbs_ShapeEnum":
        """
        * Activates the same TopAbs shape enumerations as those used by SelectionMode assigning a type to the mode aDecompositionMode.

        :param aDecompositionMode:
        :type aDecompositionMode: int
        :rtype: TopAbs_ShapeEnum

        """
        return _AIS.AIS_Shape_SelectionType(*args)

    SelectionType = staticmethod(SelectionType)

    def SelectionMode(*args) -> "Standard_Integer":
        """
        * Establishes an equivalence between a mode and the type, aShapeType, of selection. The correspondences are as follows: - mode 0 - Shape - mode 1 - Vertex - mode 2 - Edge - mode 3 - Wire - mode 4 - Face - mode 5 - Shell - mode 6 - Solid - mode 7 - Compsolid - mode 8 - Compound

        :param aShapeType:
        :type aShapeType: TopAbs_ShapeEnum
        :rtype: int

        """
        return _AIS.AIS_Shape_SelectionMode(*args)

    SelectionMode = staticmethod(SelectionMode)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Shape(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Shape
AIS_Shape.AcceptShapeDecomposition = new_instancemethod(_AIS.AIS_Shape_AcceptShapeDecomposition, None, AIS_Shape)
AIS_Shape.Set = new_instancemethod(_AIS.AIS_Shape_Set, None, AIS_Shape)
AIS_Shape.Shape = new_instancemethod(_AIS.AIS_Shape_Shape, None, AIS_Shape)
AIS_Shape.SetOwnDeviationCoefficient = new_instancemethod(_AIS.AIS_Shape_SetOwnDeviationCoefficient, None, AIS_Shape)
AIS_Shape.SetOwnHLRDeviationCoefficient = new_instancemethod(_AIS.AIS_Shape_SetOwnHLRDeviationCoefficient, None, AIS_Shape)
AIS_Shape.SetAngleAndDeviation = new_instancemethod(_AIS.AIS_Shape_SetAngleAndDeviation, None, AIS_Shape)
AIS_Shape.UserAngle = new_instancemethod(_AIS.AIS_Shape_UserAngle, None, AIS_Shape)
AIS_Shape.SetOwnDeviationAngle = new_instancemethod(_AIS.AIS_Shape_SetOwnDeviationAngle, None, AIS_Shape)
AIS_Shape.SetHLRAngleAndDeviation = new_instancemethod(_AIS.AIS_Shape_SetHLRAngleAndDeviation, None, AIS_Shape)
AIS_Shape.SetOwnHLRDeviationAngle = new_instancemethod(_AIS.AIS_Shape_SetOwnHLRDeviationAngle, None, AIS_Shape)
AIS_Shape.OwnDeviationCoefficient = new_instancemethod(_AIS.AIS_Shape_OwnDeviationCoefficient, None, AIS_Shape)
AIS_Shape.OwnHLRDeviationCoefficient = new_instancemethod(_AIS.AIS_Shape_OwnHLRDeviationCoefficient, None, AIS_Shape)
AIS_Shape.OwnDeviationAngle = new_instancemethod(_AIS.AIS_Shape_OwnDeviationAngle, None, AIS_Shape)
AIS_Shape.OwnHLRDeviationAngle = new_instancemethod(_AIS.AIS_Shape_OwnHLRDeviationAngle, None, AIS_Shape)
AIS_Shape.SetTypeOfHLR = new_instancemethod(_AIS.AIS_Shape_SetTypeOfHLR, None, AIS_Shape)
AIS_Shape.TypeOfHLR = new_instancemethod(_AIS.AIS_Shape_TypeOfHLR, None, AIS_Shape)
AIS_Shape.SetColor = new_instancemethod(_AIS.AIS_Shape_SetColor, None, AIS_Shape)
AIS_Shape.SetMaterial = new_instancemethod(_AIS.AIS_Shape_SetMaterial, None, AIS_Shape)
AIS_Shape.BoundingBox = new_instancemethod(_AIS.AIS_Shape_BoundingBox, None, AIS_Shape)
AIS_Shape.Color = new_instancemethod(_AIS.AIS_Shape_Color, None, AIS_Shape)
AIS_Shape_swigregister = _AIS.AIS_Shape_swigregister
AIS_Shape_swigregister(AIS_Shape)

def AIS_Shape_SelectionType(*args) -> "TopAbs_ShapeEnum":
    """
    * Activates the same TopAbs shape enumerations as those used by SelectionMode assigning a type to the mode aDecompositionMode.

    :param aDecompositionMode:
    :type aDecompositionMode: int
    :rtype: TopAbs_ShapeEnum

    """
    return _AIS.AIS_Shape_SelectionType(*args)

def AIS_Shape_SelectionMode(*args) -> "Standard_Integer":
    """
    * Establishes an equivalence between a mode and the type, aShapeType, of selection. The correspondences are as follows: - mode 0 - Shape - mode 1 - Vertex - mode 2 - Edge - mode 3 - Wire - mode 4 - Face - mode 5 - Shell - mode 6 - Solid - mode 7 - Compsolid - mode 8 - Compound

    :param aShapeType:
    :type aShapeType: TopAbs_ShapeEnum
    :rtype: int

    """
    return _AIS.AIS_Shape_SelectionMode(*args)

class Handle_AIS_Shape(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Shape_swiginit(self, _AIS.new_Handle_AIS_Shape(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Shape_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Shape
Handle_AIS_Shape.Nullify = new_instancemethod(_AIS.Handle_AIS_Shape_Nullify, None, Handle_AIS_Shape)
Handle_AIS_Shape.IsNull = new_instancemethod(_AIS.Handle_AIS_Shape_IsNull, None, Handle_AIS_Shape)
Handle_AIS_Shape._get_reference = new_instancemethod(_AIS.Handle_AIS_Shape__get_reference, None, Handle_AIS_Shape)
Handle_AIS_Shape_swigregister = _AIS.Handle_AIS_Shape_swigregister
Handle_AIS_Shape_swigregister(Handle_AIS_Shape)

def Handle_AIS_Shape_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Shape const":
    return _AIS.Handle_AIS_Shape_DownCast(AnObject)
Handle_AIS_Shape_DownCast = _AIS.Handle_AIS_Shape_DownCast

class AIS_SignatureFilter(AIS_TypeFilter):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the signature filter, adding the signature specification, aGivenSignature, to that for type, aGivenKind, in AIS_TypeFilter.

        :param aGivenKind:
        :type aGivenKind: AIS_KindOfInteractive
        :param aGivenSignature:
        :type aGivenSignature: int
        :rtype: None

        """
        _AIS.AIS_SignatureFilter_swiginit(self, _AIS.new_AIS_SignatureFilter(*args))

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_SignatureFilter(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_SignatureFilter
AIS_SignatureFilter_swigregister = _AIS.AIS_SignatureFilter_swigregister
AIS_SignatureFilter_swigregister(AIS_SignatureFilter)

class Handle_AIS_SignatureFilter(Handle_AIS_TypeFilter):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_SignatureFilter_swiginit(self, _AIS.new_Handle_AIS_SignatureFilter(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_SignatureFilter_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_SignatureFilter
Handle_AIS_SignatureFilter.Nullify = new_instancemethod(_AIS.Handle_AIS_SignatureFilter_Nullify, None, Handle_AIS_SignatureFilter)
Handle_AIS_SignatureFilter.IsNull = new_instancemethod(_AIS.Handle_AIS_SignatureFilter_IsNull, None, Handle_AIS_SignatureFilter)
Handle_AIS_SignatureFilter._get_reference = new_instancemethod(_AIS.Handle_AIS_SignatureFilter__get_reference, None, Handle_AIS_SignatureFilter)
Handle_AIS_SignatureFilter_swigregister = _AIS.Handle_AIS_SignatureFilter_swigregister
Handle_AIS_SignatureFilter_swigregister(Handle_AIS_SignatureFilter)

def Handle_AIS_SignatureFilter_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_SignatureFilter const":
    return _AIS.Handle_AIS_SignatureFilter_DownCast(AnObject)
Handle_AIS_SignatureFilter_DownCast = _AIS.Handle_AIS_SignatureFilter_DownCast

class AIS_Triangulation(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs the Triangulation display object

        :param aTriangulation:
        :type aTriangulation: Handle_Poly_Triangulation &
        :rtype: None

        """
        _AIS.AIS_Triangulation_swiginit(self, _AIS.new_AIS_Triangulation(*args))

    def SetColors(self, *args) -> "void":
        """
        * Set the color for each node. Each 32-bit color is Alpha << 24 + Blue << 16 + Green << 8 + Red Order of color components is essential for further usage by OpenGL

        :param aColor:
        :type aColor: Handle_TColStd_HArray1OfInteger &
        :rtype: None

        """
        return _AIS.AIS_Triangulation_SetColors(self, *args)


    def GetColors(self, *args) -> "Handle_TColStd_HArray1OfInteger":
        """
        * Get the color for each node. Each 32-bit color is Alpha << 24 + Blue << 16 + Green << 8 + Red

        :rtype: Handle_TColStd_HArray1OfInteger

        """
        return _AIS.AIS_Triangulation_GetColors(self, *args)


    def SetTriangulation(self, *args) -> "void":
        """
        :param aTriangulation:
        :type aTriangulation: Handle_Poly_Triangulation &
        :rtype: None

        """
        return _AIS.AIS_Triangulation_SetTriangulation(self, *args)


    def GetTriangulation(self, *args) -> "Handle_Poly_Triangulation":
        """
        * Returns Poly_Triangulation .

        :rtype: Handle_Poly_Triangulation

        """
        return _AIS.AIS_Triangulation_GetTriangulation(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Triangulation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Triangulation
AIS_Triangulation.SetColors = new_instancemethod(_AIS.AIS_Triangulation_SetColors, None, AIS_Triangulation)
AIS_Triangulation.GetColors = new_instancemethod(_AIS.AIS_Triangulation_GetColors, None, AIS_Triangulation)
AIS_Triangulation.SetTriangulation = new_instancemethod(_AIS.AIS_Triangulation_SetTriangulation, None, AIS_Triangulation)
AIS_Triangulation.GetTriangulation = new_instancemethod(_AIS.AIS_Triangulation_GetTriangulation, None, AIS_Triangulation)
AIS_Triangulation_swigregister = _AIS.AIS_Triangulation_swigregister
AIS_Triangulation_swigregister(AIS_Triangulation)

class Handle_AIS_Triangulation(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Triangulation_swiginit(self, _AIS.new_Handle_AIS_Triangulation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Triangulation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Triangulation
Handle_AIS_Triangulation.Nullify = new_instancemethod(_AIS.Handle_AIS_Triangulation_Nullify, None, Handle_AIS_Triangulation)
Handle_AIS_Triangulation.IsNull = new_instancemethod(_AIS.Handle_AIS_Triangulation_IsNull, None, Handle_AIS_Triangulation)
Handle_AIS_Triangulation._get_reference = new_instancemethod(_AIS.Handle_AIS_Triangulation__get_reference, None, Handle_AIS_Triangulation)
Handle_AIS_Triangulation_swigregister = _AIS.Handle_AIS_Triangulation_swigregister
Handle_AIS_Triangulation_swigregister(Handle_AIS_Triangulation)

def Handle_AIS_Triangulation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Triangulation const":
    return _AIS.Handle_AIS_Triangulation_DownCast(AnObject)
Handle_AIS_Triangulation_DownCast = _AIS.Handle_AIS_Triangulation_DownCast

class AIS_Trihedron(AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes a trihedron entity.

        :param aComponent:
        :type aComponent: Handle_Geom_Axis2Placement &
        :rtype: None

        """
        _AIS.AIS_Trihedron_swiginit(self, _AIS.new_AIS_Trihedron(*args))

    def Component(self, *args) -> "Handle_Geom_Axis2Placement":
        """
        * Returns the right-handed coordinate system set in SetComponent.

        :rtype: Handle_Geom_Axis2Placement

        """
        return _AIS.AIS_Trihedron_Component(self, *args)


    def SetComponent(self, *args) -> "void":
        """
        * Constructs the right-handed coordinate system aComponent.

        :param aComponent:
        :type aComponent: Handle_Geom_Axis2Placement &
        :rtype: None

        """
        return _AIS.AIS_Trihedron_SetComponent(self, *args)


    def HasOwnSize(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the trihedron object has a size other than the default size of 100 mm. along each axis.

        :rtype: bool

        """
        return _AIS.AIS_Trihedron_HasOwnSize(self, *args)


    def SetSize(self, *args) -> "void":
        """
        * Sets the size aValue for the trihedron object. The default value is 100 mm.

        :param aValue:
        :type aValue: float
        :rtype: None

        """
        return _AIS.AIS_Trihedron_SetSize(self, *args)


    def UnsetSize(self, *args) -> "void":
        """
        * Removes any non-default settings for size of this trihedron object.

        :rtype: None

        """
        return _AIS.AIS_Trihedron_UnsetSize(self, *args)


    def Size(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _AIS.AIS_Trihedron_Size(self, *args)


    def XAxis(self, *args) -> "Handle_AIS_Axis":
        """
        * Returns the 'XAxis'.

        :rtype: Handle_AIS_Axis

        """
        return _AIS.AIS_Trihedron_XAxis(self, *args)


    def YAxis(self, *args) -> "Handle_AIS_Axis":
        """
        * Returns the 'YAxis'.

        :rtype: Handle_AIS_Axis

        """
        return _AIS.AIS_Trihedron_YAxis(self, *args)


    def Axis(self, *args) -> "Handle_AIS_Axis":
        """
        * Returns the main Axis.

        :rtype: Handle_AIS_Axis

        """
        return _AIS.AIS_Trihedron_Axis(self, *args)


    def Position(self, *args) -> "Handle_AIS_Point":
        """
        * Returns the origine.

        :rtype: Handle_AIS_Point

        """
        return _AIS.AIS_Trihedron_Position(self, *args)


    def XYPlane(self, *args) -> "Handle_AIS_Plane":
        """
        * Returns the 'XYPlane'.

        :rtype: Handle_AIS_Plane

        """
        return _AIS.AIS_Trihedron_XYPlane(self, *args)


    def XZPlane(self, *args) -> "Handle_AIS_Plane":
        """
        * Returns the 'XZPlane'.

        :rtype: Handle_AIS_Plane

        """
        return _AIS.AIS_Trihedron_XZPlane(self, *args)


    def YZPlane(self, *args) -> "Handle_AIS_Plane":
        """
        * Returns the 'YZPlane'.

        :rtype: Handle_AIS_Plane

        """
        return _AIS.AIS_Trihedron_YZPlane(self, *args)


    def Compute(self, *args) -> "void":
        """
        * Computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_Trihedron_Compute(self, *args)


    def SetLocalTransformation(self, *args) -> "void":
        """
        :param theTransformation:
        :type theTransformation: gp_Trsf
        :rtype: None

        """
        return _AIS.AIS_Trihedron_SetLocalTransformation(self, *args)


    def SetColor(self, *args) -> "void":
        """
        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        * Sets the color aColor for this trihedron object.

        :param aColor:
        :type aColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_Trihedron_SetColor(self, *args)


    def SetTextColor(self, *args) -> "void":
        """
        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_Trihedron_SetTextColor(self, *args)


    def HasTextColor(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Trihedron_HasTextColor(self, *args)


    def TextColor(self, *args) -> "Quantity_NameOfColor":
        """
        :rtype: Quantity_NameOfColor

        """
        return _AIS.AIS_Trihedron_TextColor(self, *args)


    def SetArrowColor(self, *args) -> "void":
        """
        :param aColor:
        :type aColor: Quantity_NameOfColor
        :rtype: None

        """
        return _AIS.AIS_Trihedron_SetArrowColor(self, *args)


    def HasArrowColor(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _AIS.AIS_Trihedron_HasArrowColor(self, *args)


    def ArrowColor(self, *args) -> "Quantity_NameOfColor":
        """
        :rtype: Quantity_NameOfColor

        """
        return _AIS.AIS_Trihedron_ArrowColor(self, *args)


    def ExtremityPoints(self, *args) -> "void":
        """
        * Returns the four extremities of the trihedron from the array of points, TheExtrem.

        :param TheExtrem:
        :type TheExtrem: TColgp_Array1OfPnt
        :rtype: None

        """
        return _AIS.AIS_Trihedron_ExtremityPoints(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Trihedron(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Trihedron
AIS_Trihedron.Component = new_instancemethod(_AIS.AIS_Trihedron_Component, None, AIS_Trihedron)
AIS_Trihedron.SetComponent = new_instancemethod(_AIS.AIS_Trihedron_SetComponent, None, AIS_Trihedron)
AIS_Trihedron.HasOwnSize = new_instancemethod(_AIS.AIS_Trihedron_HasOwnSize, None, AIS_Trihedron)
AIS_Trihedron.SetSize = new_instancemethod(_AIS.AIS_Trihedron_SetSize, None, AIS_Trihedron)
AIS_Trihedron.UnsetSize = new_instancemethod(_AIS.AIS_Trihedron_UnsetSize, None, AIS_Trihedron)
AIS_Trihedron.Size = new_instancemethod(_AIS.AIS_Trihedron_Size, None, AIS_Trihedron)
AIS_Trihedron.XAxis = new_instancemethod(_AIS.AIS_Trihedron_XAxis, None, AIS_Trihedron)
AIS_Trihedron.YAxis = new_instancemethod(_AIS.AIS_Trihedron_YAxis, None, AIS_Trihedron)
AIS_Trihedron.Axis = new_instancemethod(_AIS.AIS_Trihedron_Axis, None, AIS_Trihedron)
AIS_Trihedron.Position = new_instancemethod(_AIS.AIS_Trihedron_Position, None, AIS_Trihedron)
AIS_Trihedron.XYPlane = new_instancemethod(_AIS.AIS_Trihedron_XYPlane, None, AIS_Trihedron)
AIS_Trihedron.XZPlane = new_instancemethod(_AIS.AIS_Trihedron_XZPlane, None, AIS_Trihedron)
AIS_Trihedron.YZPlane = new_instancemethod(_AIS.AIS_Trihedron_YZPlane, None, AIS_Trihedron)
AIS_Trihedron.Compute = new_instancemethod(_AIS.AIS_Trihedron_Compute, None, AIS_Trihedron)
AIS_Trihedron.SetLocalTransformation = new_instancemethod(_AIS.AIS_Trihedron_SetLocalTransformation, None, AIS_Trihedron)
AIS_Trihedron.SetColor = new_instancemethod(_AIS.AIS_Trihedron_SetColor, None, AIS_Trihedron)
AIS_Trihedron.SetTextColor = new_instancemethod(_AIS.AIS_Trihedron_SetTextColor, None, AIS_Trihedron)
AIS_Trihedron.HasTextColor = new_instancemethod(_AIS.AIS_Trihedron_HasTextColor, None, AIS_Trihedron)
AIS_Trihedron.TextColor = new_instancemethod(_AIS.AIS_Trihedron_TextColor, None, AIS_Trihedron)
AIS_Trihedron.SetArrowColor = new_instancemethod(_AIS.AIS_Trihedron_SetArrowColor, None, AIS_Trihedron)
AIS_Trihedron.HasArrowColor = new_instancemethod(_AIS.AIS_Trihedron_HasArrowColor, None, AIS_Trihedron)
AIS_Trihedron.ArrowColor = new_instancemethod(_AIS.AIS_Trihedron_ArrowColor, None, AIS_Trihedron)
AIS_Trihedron.ExtremityPoints = new_instancemethod(_AIS.AIS_Trihedron_ExtremityPoints, None, AIS_Trihedron)
AIS_Trihedron_swigregister = _AIS.AIS_Trihedron_swigregister
AIS_Trihedron_swigregister(AIS_Trihedron)

class Handle_AIS_Trihedron(Handle_AIS_InteractiveObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Trihedron_swiginit(self, _AIS.new_Handle_AIS_Trihedron(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Trihedron_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Trihedron
Handle_AIS_Trihedron.Nullify = new_instancemethod(_AIS.Handle_AIS_Trihedron_Nullify, None, Handle_AIS_Trihedron)
Handle_AIS_Trihedron.IsNull = new_instancemethod(_AIS.Handle_AIS_Trihedron_IsNull, None, Handle_AIS_Trihedron)
Handle_AIS_Trihedron._get_reference = new_instancemethod(_AIS.Handle_AIS_Trihedron__get_reference, None, Handle_AIS_Trihedron)
Handle_AIS_Trihedron_swigregister = _AIS.Handle_AIS_Trihedron_swigregister
Handle_AIS_Trihedron_swigregister(Handle_AIS_Trihedron)

def Handle_AIS_Trihedron_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Trihedron const":
    return _AIS.Handle_AIS_Trihedron_DownCast(AnObject)
Handle_AIS_Trihedron_DownCast = _AIS.Handle_AIS_Trihedron_DownCast

class AIS_AngleDimension(AIS_Dimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs minimum angle dimension between two linear edges (where possible). These two edges should be intersected by each other. Otherwise the geometry is not valid. @param theFirstEdge [in] the first edge. @param theSecondEdge [in] the second edge.

        :param theFirstEdge:
        :type theFirstEdge: TopoDS_Edge &
        :param theSecondEdge:
        :type theSecondEdge: TopoDS_Edge &
        :rtype: None

        * Constructs the angle display object defined by three points. @param theFirstPoint [in] the first point (point on first angle flyout). @param theSecondPoint [in] the center point of angle dimension. @param theThirdPoint [in] the second point (point on second angle flyout).

        :param theFirstPoint:
        :type theFirstPoint: gp_Pnt
        :param theSecondPoint:
        :type theSecondPoint: gp_Pnt
        :param theThirdPoint:
        :type theThirdPoint: gp_Pnt
        :rtype: None

        * Constructs the angle display object defined by three vertices. @param theFirstVertex [in] the first vertex (vertex for first angle flyout). @param theSecondVertex [in] the center vertex of angle dimension. @param theThirdPoint [in] the second vertex (vertex for second angle flyout).

        :param theFirstVertex:
        :type theFirstVertex: TopoDS_Vertex &
        :param theSecondVertex:
        :type theSecondVertex: TopoDS_Vertex &
        :param theThirdVertex:
        :type theThirdVertex: TopoDS_Vertex &
        :rtype: None

        * Constructs angle dimension for the cone face. @param theCone [in] the conical face.

        :param theCone:
        :type theCone: TopoDS_Face &
        :rtype: None

        * Constructs angle dimension between two planar faces. @param theFirstFace [in] the first face. @param theSecondFace [in] the second face.

        :param theFirstFace:
        :type theFirstFace: TopoDS_Face &
        :param theSecondFace:
        :type theSecondFace: TopoDS_Face &
        :rtype: None

        * Constructs angle dimension between two planar faces. @param theFirstFace [in] the first face. @param theSecondFace [in] the second face. @param thePoint [in] the point which the dimension plane should pass through. This point can lay on the one of the faces or not.

        :param theFirstFace:
        :type theFirstFace: TopoDS_Face &
        :param theSecondFace:
        :type theSecondFace: TopoDS_Face &
        :param thePoint:
        :type thePoint: gp_Pnt
        :rtype: None

        """
        _AIS.AIS_AngleDimension_swiginit(self, _AIS.new_AIS_AngleDimension(*args))

    def FirstPoint(self, *args) -> "gp_Pnt const":
        """
        * returns first point forming the angle.

        :rtype: gp_Pnt

        """
        return _AIS.AIS_AngleDimension_FirstPoint(self, *args)


    def SecondPoint(self, *args) -> "gp_Pnt const":
        """
        * returns second point forming the angle.

        :rtype: gp_Pnt

        """
        return _AIS.AIS_AngleDimension_SecondPoint(self, *args)


    def CenterPoint(self, *args) -> "gp_Pnt const":
        """
        * returns center point forming the angle.

        :rtype: gp_Pnt

        """
        return _AIS.AIS_AngleDimension_CenterPoint(self, *args)


    def FirstShape(self, *args) -> "TopoDS_Shape const":
        """
        * returns first argument shape.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_AngleDimension_FirstShape(self, *args)


    def SecondShape(self, *args) -> "TopoDS_Shape const":
        """
        * returns second argument shape.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_AngleDimension_SecondShape(self, *args)


    def ThirdShape(self, *args) -> "TopoDS_Shape const":
        """
        * returns third argument shape.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_AngleDimension_ThirdShape(self, *args)


    def SetMeasuredGeometry(self, *args) -> "void":
        """
        * Measures minimum angle dimension between two linear edges. These two edges should be intersected by each other. Otherwise the geometry is not valid. @param theFirstEdge [in] the first edge. @param theSecondEdge [in] the second edge.

        :param theFirstEdge:
        :type theFirstEdge: TopoDS_Edge &
        :param theSecondEdge:
        :type theSecondEdge: TopoDS_Edge &
        :rtype: None

        * Measures angle defined by three points. @param theFirstPoint [in] the first point (point on first angle flyout). @param theSecondPoint [in] the center point of angle dimension. @param theThirdPoint [in] the second point (point on second angle flyout).

        :param theFirstPoint:
        :type theFirstPoint: gp_Pnt
        :param theSecondPoint:
        :type theSecondPoint: gp_Pnt
        :param theThridPoint:
        :type theThridPoint: gp_Pnt
        :rtype: None

        * Measures angle defined by three vertices. @param theFirstVertex [in] the first vertex (vertex for first angle flyout). @param theSecondVertex [in] the center vertex of angle dimension. @param theThirdPoint [in] the second vertex (vertex for second angle flyout).

        :param theFirstVertex:
        :type theFirstVertex: TopoDS_Vertex &
        :param theSecondVertex:
        :type theSecondVertex: TopoDS_Vertex &
        :param theThirdVertex:
        :type theThirdVertex: TopoDS_Vertex &
        :rtype: None

        * Measures angle of conical face. @param theCone [in] the shape to measure.

        :param theCone:
        :type theCone: TopoDS_Face &
        :rtype: None

        * Measures angle between two planar faces. @param theFirstFace [in] the first face. @param theSecondFace [in] the second face..

        :param theFirstFace:
        :type theFirstFace: TopoDS_Face &
        :param theSecondFace:
        :type theSecondFace: TopoDS_Face &
        :rtype: None

        * Measures angle between two planar faces. @param theFirstFace [in] the first face. @param theSecondFace [in] the second face. @param thePoint [in] the point which the dimension plane should pass through. This point can lay on the one of the faces or not.

        :param theFirstFace:
        :type theFirstFace: TopoDS_Face &
        :param theSecondFace:
        :type theSecondFace: TopoDS_Face &
        :param thePoint:
        :type thePoint: gp_Pnt
        :rtype: None

        """
        return _AIS.AIS_AngleDimension_SetMeasuredGeometry(self, *args)


    def SetTextPosition(self, *args) -> "void":
        """
        * Principle of horizontal text alignment settings: - divide circle into two halves according to attachment points - if aTextPos is between attach points -> Center + positive flyout - if aTextPos is not between attach points but in this half -> Left or Right + positive flyout - if aTextPos is between reflections of attach points -> Center + negative flyout - if aTextPos is not between reflections of attach points -> Left or Right + negative flyout

        :param theTextPos:
        :type theTextPos: gp_Pnt
        :rtype: void

        """
        return _AIS.AIS_AngleDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args) -> "gp_Pnt const":
        """
        :rtype: gp_Pnt

        """
        return _AIS.AIS_AngleDimension_GetTextPosition(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_AngleDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_AngleDimension
AIS_AngleDimension.FirstPoint = new_instancemethod(_AIS.AIS_AngleDimension_FirstPoint, None, AIS_AngleDimension)
AIS_AngleDimension.SecondPoint = new_instancemethod(_AIS.AIS_AngleDimension_SecondPoint, None, AIS_AngleDimension)
AIS_AngleDimension.CenterPoint = new_instancemethod(_AIS.AIS_AngleDimension_CenterPoint, None, AIS_AngleDimension)
AIS_AngleDimension.FirstShape = new_instancemethod(_AIS.AIS_AngleDimension_FirstShape, None, AIS_AngleDimension)
AIS_AngleDimension.SecondShape = new_instancemethod(_AIS.AIS_AngleDimension_SecondShape, None, AIS_AngleDimension)
AIS_AngleDimension.ThirdShape = new_instancemethod(_AIS.AIS_AngleDimension_ThirdShape, None, AIS_AngleDimension)
AIS_AngleDimension.SetMeasuredGeometry = new_instancemethod(_AIS.AIS_AngleDimension_SetMeasuredGeometry, None, AIS_AngleDimension)
AIS_AngleDimension.SetTextPosition = new_instancemethod(_AIS.AIS_AngleDimension_SetTextPosition, None, AIS_AngleDimension)
AIS_AngleDimension.GetTextPosition = new_instancemethod(_AIS.AIS_AngleDimension_GetTextPosition, None, AIS_AngleDimension)
AIS_AngleDimension_swigregister = _AIS.AIS_AngleDimension_swigregister
AIS_AngleDimension_swigregister(AIS_AngleDimension)

class Handle_AIS_AngleDimension(Handle_AIS_Dimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_AngleDimension_swiginit(self, _AIS.new_Handle_AIS_AngleDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_AngleDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_AngleDimension
Handle_AIS_AngleDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_AngleDimension_Nullify, None, Handle_AIS_AngleDimension)
Handle_AIS_AngleDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_AngleDimension_IsNull, None, Handle_AIS_AngleDimension)
Handle_AIS_AngleDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_AngleDimension__get_reference, None, Handle_AIS_AngleDimension)
Handle_AIS_AngleDimension_swigregister = _AIS.Handle_AIS_AngleDimension_swigregister
Handle_AIS_AngleDimension_swigregister(Handle_AIS_AngleDimension)

def Handle_AIS_AngleDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_AngleDimension const":
    return _AIS.Handle_AIS_AngleDimension_DownCast(AnObject)
Handle_AIS_AngleDimension_DownCast = _AIS.Handle_AIS_AngleDimension_DownCast

class AIS_Chamf2dDimension(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs the display object for 2D chamfers. This object is defined by the face aFShape, the dimension aVal, the plane aPlane and the text aText.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :param aVal:
        :type aVal: float
        :param aText:
        :type aText: TCollection_ExtendedString &
        :rtype: None

        * Constructs the display object for 2D chamfers. This object is defined by the face aFShape, the plane aPlane, the dimension aVal, the position aPosition, the type of arrow aSymbolPrs with the size anArrowSize, and the text aText.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :param aVal:
        :type aVal: float
        :param aText:
        :type aText: TCollection_ExtendedString &
        :param aPosition:
        :type aPosition: gp_Pnt
        :param aSymbolPrs:
        :type aSymbolPrs: DsgPrs_ArrowSide
        :param anArrowSize: default value is 0.0
        :type anArrowSize: float
        :rtype: None

        """
        _AIS.AIS_Chamf2dDimension_swiginit(self, _AIS.new_AIS_Chamf2dDimension(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_Chamf2dDimension_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Chamf2dDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Chamf2dDimension
AIS_Chamf2dDimension.Compute = new_instancemethod(_AIS.AIS_Chamf2dDimension_Compute, None, AIS_Chamf2dDimension)
AIS_Chamf2dDimension_swigregister = _AIS.AIS_Chamf2dDimension_swigregister
AIS_Chamf2dDimension_swigregister(AIS_Chamf2dDimension)

class Handle_AIS_Chamf2dDimension(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Chamf2dDimension_swiginit(self, _AIS.new_Handle_AIS_Chamf2dDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Chamf2dDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Chamf2dDimension
Handle_AIS_Chamf2dDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_Chamf2dDimension_Nullify, None, Handle_AIS_Chamf2dDimension)
Handle_AIS_Chamf2dDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_Chamf2dDimension_IsNull, None, Handle_AIS_Chamf2dDimension)
Handle_AIS_Chamf2dDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_Chamf2dDimension__get_reference, None, Handle_AIS_Chamf2dDimension)
Handle_AIS_Chamf2dDimension_swigregister = _AIS.Handle_AIS_Chamf2dDimension_swigregister
Handle_AIS_Chamf2dDimension_swigregister(Handle_AIS_Chamf2dDimension)

def Handle_AIS_Chamf2dDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Chamf2dDimension const":
    return _AIS.Handle_AIS_Chamf2dDimension_DownCast(AnObject)
Handle_AIS_Chamf2dDimension_DownCast = _AIS.Handle_AIS_Chamf2dDimension_DownCast

class AIS_Chamf3dDimension(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs a display object for 3D chamfers. This object is defined by the shape aFShape, the dimension aVal and the text aText.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aVal:
        :type aVal: float
        :param aText:
        :type aText: TCollection_ExtendedString &
        :rtype: None

        * Constructs a display object for 3D chamfers. This object is defined by the shape aFShape, the dimension aVal, the text aText, the point of origin of the chamfer aPosition, the type of arrow aSymbolPrs with the size anArrowSize.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aVal:
        :type aVal: float
        :param aText:
        :type aText: TCollection_ExtendedString &
        :param aPosition:
        :type aPosition: gp_Pnt
        :param aSymbolPrs:
        :type aSymbolPrs: DsgPrs_ArrowSide
        :param anArrowSize: default value is 0.0
        :type anArrowSize: float
        :rtype: None

        """
        _AIS.AIS_Chamf3dDimension_swiginit(self, _AIS.new_AIS_Chamf3dDimension(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_Chamf3dDimension_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_Chamf3dDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_Chamf3dDimension
AIS_Chamf3dDimension.Compute = new_instancemethod(_AIS.AIS_Chamf3dDimension_Compute, None, AIS_Chamf3dDimension)
AIS_Chamf3dDimension_swigregister = _AIS.AIS_Chamf3dDimension_swigregister
AIS_Chamf3dDimension_swigregister(AIS_Chamf3dDimension)

class Handle_AIS_Chamf3dDimension(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_Chamf3dDimension_swiginit(self, _AIS.new_Handle_AIS_Chamf3dDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_Chamf3dDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_Chamf3dDimension
Handle_AIS_Chamf3dDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_Chamf3dDimension_Nullify, None, Handle_AIS_Chamf3dDimension)
Handle_AIS_Chamf3dDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_Chamf3dDimension_IsNull, None, Handle_AIS_Chamf3dDimension)
Handle_AIS_Chamf3dDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_Chamf3dDimension__get_reference, None, Handle_AIS_Chamf3dDimension)
Handle_AIS_Chamf3dDimension_swigregister = _AIS.Handle_AIS_Chamf3dDimension_swigregister
Handle_AIS_Chamf3dDimension_swigregister(Handle_AIS_Chamf3dDimension)

def Handle_AIS_Chamf3dDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_Chamf3dDimension const":
    return _AIS.Handle_AIS_Chamf3dDimension_DownCast(AnObject)
Handle_AIS_Chamf3dDimension_DownCast = _AIS.Handle_AIS_Chamf3dDimension_DownCast

class AIS_ColoredShape(AIS_Shape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Default constructor

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        * Copy constructor

        :param theShape:
        :type theShape: Handle_AIS_Shape &
        :rtype: None

        """
        _AIS.AIS_ColoredShape_swiginit(self, _AIS.new_AIS_ColoredShape(*args))

    def CustomAspects(self, *args) -> "Handle_AIS_ColoredDrawer":
        """
        * @name sub-shape aspects Customize properties of specified sub-shape. The shape will be stored in the map but ignored, if it is not sub-shape of main Shape! This method can be used to mark sub-shapes with customizable properties.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: Handle_AIS_ColoredDrawer

        """
        return _AIS.AIS_ColoredShape_CustomAspects(self, *args)


    def ClearCustomAspects(self, *args) -> "void":
        """
        * Reset the map of custom sub-shape aspects.

        :rtype: None

        """
        return _AIS.AIS_ColoredShape_ClearCustomAspects(self, *args)


    def UnsetCustomAspects(self, *args) -> "void":
        """
        * Reset custom properties of specified sub-shape. @param theToUnregister unregister or not sub-shape from the map

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theToUnregister: default value is Standard_False
        :type theToUnregister: bool
        :rtype: None

        """
        return _AIS.AIS_ColoredShape_UnsetCustomAspects(self, *args)


    def SetCustomColor(self, *args) -> "void":
        """
        * Customize color of specified sub-shape

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theColor:
        :type theColor: Quantity_Color &
        :rtype: None

        """
        return _AIS.AIS_ColoredShape_SetCustomColor(self, *args)


    def SetCustomWidth(self, *args) -> "void":
        """
        * Customize line width of specified sub-shape

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theLineWidth:
        :type theLineWidth: float
        :rtype: None

        """
        return _AIS.AIS_ColoredShape_SetCustomWidth(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_ColoredShape(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_ColoredShape
AIS_ColoredShape.CustomAspects = new_instancemethod(_AIS.AIS_ColoredShape_CustomAspects, None, AIS_ColoredShape)
AIS_ColoredShape.ClearCustomAspects = new_instancemethod(_AIS.AIS_ColoredShape_ClearCustomAspects, None, AIS_ColoredShape)
AIS_ColoredShape.UnsetCustomAspects = new_instancemethod(_AIS.AIS_ColoredShape_UnsetCustomAspects, None, AIS_ColoredShape)
AIS_ColoredShape.SetCustomColor = new_instancemethod(_AIS.AIS_ColoredShape_SetCustomColor, None, AIS_ColoredShape)
AIS_ColoredShape.SetCustomWidth = new_instancemethod(_AIS.AIS_ColoredShape_SetCustomWidth, None, AIS_ColoredShape)
AIS_ColoredShape_swigregister = _AIS.AIS_ColoredShape_swigregister
AIS_ColoredShape_swigregister(AIS_ColoredShape)

class Handle_AIS_ColoredShape(Handle_AIS_Shape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_ColoredShape_swiginit(self, _AIS.new_Handle_AIS_ColoredShape(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_ColoredShape_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_ColoredShape
Handle_AIS_ColoredShape.Nullify = new_instancemethod(_AIS.Handle_AIS_ColoredShape_Nullify, None, Handle_AIS_ColoredShape)
Handle_AIS_ColoredShape.IsNull = new_instancemethod(_AIS.Handle_AIS_ColoredShape_IsNull, None, Handle_AIS_ColoredShape)
Handle_AIS_ColoredShape._get_reference = new_instancemethod(_AIS.Handle_AIS_ColoredShape__get_reference, None, Handle_AIS_ColoredShape)
Handle_AIS_ColoredShape_swigregister = _AIS.Handle_AIS_ColoredShape_swigregister
Handle_AIS_ColoredShape_swigregister(Handle_AIS_ColoredShape)

def Handle_AIS_ColoredShape_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_ColoredShape const":
    return _AIS.Handle_AIS_ColoredShape_DownCast(AnObject)
Handle_AIS_ColoredShape_DownCast = _AIS.Handle_AIS_ColoredShape_DownCast

class AIS_ConcentricRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs the display object for concentric relations between shapes. This object is defined by the two shapes, aFShape and aSShape and the plane aPlane. aPlane is provided to create an axis along which the relation of concentricity can be extended.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aSShape:
        :type aSShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        """
        _AIS.AIS_ConcentricRelation_swiginit(self, _AIS.new_AIS_ConcentricRelation(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_ConcentricRelation_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_ConcentricRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_ConcentricRelation
AIS_ConcentricRelation.Compute = new_instancemethod(_AIS.AIS_ConcentricRelation_Compute, None, AIS_ConcentricRelation)
AIS_ConcentricRelation_swigregister = _AIS.AIS_ConcentricRelation_swigregister
AIS_ConcentricRelation_swigregister(AIS_ConcentricRelation)

class Handle_AIS_ConcentricRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_ConcentricRelation_swiginit(self, _AIS.new_Handle_AIS_ConcentricRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_ConcentricRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_ConcentricRelation
Handle_AIS_ConcentricRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_ConcentricRelation_Nullify, None, Handle_AIS_ConcentricRelation)
Handle_AIS_ConcentricRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_ConcentricRelation_IsNull, None, Handle_AIS_ConcentricRelation)
Handle_AIS_ConcentricRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_ConcentricRelation__get_reference, None, Handle_AIS_ConcentricRelation)
Handle_AIS_ConcentricRelation_swigregister = _AIS.Handle_AIS_ConcentricRelation_swigregister
Handle_AIS_ConcentricRelation_swigregister(Handle_AIS_ConcentricRelation)

def Handle_AIS_ConcentricRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_ConcentricRelation const":
    return _AIS.Handle_AIS_ConcentricRelation_DownCast(AnObject)
Handle_AIS_ConcentricRelation_DownCast = _AIS.Handle_AIS_ConcentricRelation_DownCast

class AIS_DiameterDimension(AIS_Dimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Construct diameter dimension for the circle. @param theCircle [in] the circle to measure.

        :param theCircle:
        :type theCircle: gp_Circ
        :rtype: None

        * Construct diameter dimension for the circle and orient it correspondingly to the passed plane. @param theCircle [in] the circle to measure. @param thePlane [in] the plane defining preferred orientation for dimension.

        :param theCircle:
        :type theCircle: gp_Circ
        :param thePlane:
        :type thePlane: gp_Pln
        :rtype: None

        * Construct diameter on the passed shape, if applicable. @param theShape [in] the shape to measure.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        * Construct diameter on the passed shape, if applicable - and define the preferred plane to orient the dimension. @param theShape [in] the shape to measure. @param thePlane [in] the plane defining preferred orientation for dimension.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param thePlane:
        :type thePlane: gp_Pln
        :rtype: None

        """
        _AIS.AIS_DiameterDimension_swiginit(self, _AIS.new_AIS_DiameterDimension(*args))

    def Circle(self, *args) -> "gp_Circ const":
        """
        * returns measured geometry circle.

        :rtype: gp_Circ

        """
        return _AIS.AIS_DiameterDimension_Circle(self, *args)


    def AnchorPoint(self, *args) -> "gp_Pnt":
        """
        * returns anchor point on circle for diameter dimension.

        :rtype: gp_Pnt

        """
        return _AIS.AIS_DiameterDimension_AnchorPoint(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape const":
        """
        * returns the measured shape.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_DiameterDimension_Shape(self, *args)


    def SetMeasuredGeometry(self, *args) -> "void":
        """
        * Measure diameter of the circle. The actual dimension plane is used for determining anchor points on the circle to attach the dimension lines to. The dimension will become invalid if the diameter of the circle is less than Precision::Confusion(). @param theCircle [in] the circle to measure.

        :param theCircle:
        :type theCircle: gp_Circ
        :rtype: None

        * Measure diameter on the passed shape, if applicable. The dimension will become invalid if the passed shape is not measurable or if measured diameter value is less than Precision::Confusion(). @param theShape [in] the shape to measure.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        """
        return _AIS.AIS_DiameterDimension_SetMeasuredGeometry(self, *args)


    def SetTextPosition(self, *args) -> "void":
        """
        :param theTextPos:
        :type theTextPos: gp_Pnt
        :rtype: void

        """
        return _AIS.AIS_DiameterDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args) -> "gp_Pnt const":
        """
        :rtype: gp_Pnt

        """
        return _AIS.AIS_DiameterDimension_GetTextPosition(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_DiameterDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_DiameterDimension
AIS_DiameterDimension.Circle = new_instancemethod(_AIS.AIS_DiameterDimension_Circle, None, AIS_DiameterDimension)
AIS_DiameterDimension.AnchorPoint = new_instancemethod(_AIS.AIS_DiameterDimension_AnchorPoint, None, AIS_DiameterDimension)
AIS_DiameterDimension.Shape = new_instancemethod(_AIS.AIS_DiameterDimension_Shape, None, AIS_DiameterDimension)
AIS_DiameterDimension.SetMeasuredGeometry = new_instancemethod(_AIS.AIS_DiameterDimension_SetMeasuredGeometry, None, AIS_DiameterDimension)
AIS_DiameterDimension.SetTextPosition = new_instancemethod(_AIS.AIS_DiameterDimension_SetTextPosition, None, AIS_DiameterDimension)
AIS_DiameterDimension.GetTextPosition = new_instancemethod(_AIS.AIS_DiameterDimension_GetTextPosition, None, AIS_DiameterDimension)
AIS_DiameterDimension_swigregister = _AIS.AIS_DiameterDimension_swigregister
AIS_DiameterDimension_swigregister(AIS_DiameterDimension)

class Handle_AIS_DiameterDimension(Handle_AIS_Dimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_DiameterDimension_swiginit(self, _AIS.new_Handle_AIS_DiameterDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_DiameterDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_DiameterDimension
Handle_AIS_DiameterDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_DiameterDimension_Nullify, None, Handle_AIS_DiameterDimension)
Handle_AIS_DiameterDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_DiameterDimension_IsNull, None, Handle_AIS_DiameterDimension)
Handle_AIS_DiameterDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_DiameterDimension__get_reference, None, Handle_AIS_DiameterDimension)
Handle_AIS_DiameterDimension_swigregister = _AIS.Handle_AIS_DiameterDimension_swigregister
Handle_AIS_DiameterDimension_swigregister(Handle_AIS_DiameterDimension)

def Handle_AIS_DiameterDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_DiameterDimension const":
    return _AIS.Handle_AIS_DiameterDimension_DownCast(AnObject)
Handle_AIS_DiameterDimension_DownCast = _AIS.Handle_AIS_DiameterDimension_DownCast

class AIS_EllipseRadiusDimension(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ComputeGeometry(self, *args) -> "void":
        """
        :rtype: None

        """
        return _AIS.AIS_EllipseRadiusDimension_ComputeGeometry(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_EllipseRadiusDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_EllipseRadiusDimension
AIS_EllipseRadiusDimension.ComputeGeometry = new_instancemethod(_AIS.AIS_EllipseRadiusDimension_ComputeGeometry, None, AIS_EllipseRadiusDimension)
AIS_EllipseRadiusDimension_swigregister = _AIS.AIS_EllipseRadiusDimension_swigregister
AIS_EllipseRadiusDimension_swigregister(AIS_EllipseRadiusDimension)

class Handle_AIS_EllipseRadiusDimension(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_EllipseRadiusDimension_swiginit(self, _AIS.new_Handle_AIS_EllipseRadiusDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_EllipseRadiusDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_EllipseRadiusDimension
Handle_AIS_EllipseRadiusDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_EllipseRadiusDimension_Nullify, None, Handle_AIS_EllipseRadiusDimension)
Handle_AIS_EllipseRadiusDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_EllipseRadiusDimension_IsNull, None, Handle_AIS_EllipseRadiusDimension)
Handle_AIS_EllipseRadiusDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_EllipseRadiusDimension__get_reference, None, Handle_AIS_EllipseRadiusDimension)
Handle_AIS_EllipseRadiusDimension_swigregister = _AIS.Handle_AIS_EllipseRadiusDimension_swigregister
Handle_AIS_EllipseRadiusDimension_swigregister(Handle_AIS_EllipseRadiusDimension)

def Handle_AIS_EllipseRadiusDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_EllipseRadiusDimension const":
    return _AIS.Handle_AIS_EllipseRadiusDimension_DownCast(AnObject)
Handle_AIS_EllipseRadiusDimension_DownCast = _AIS.Handle_AIS_EllipseRadiusDimension_DownCast

class AIS_EqualDistanceRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs a framework to display equivalent distances between the shapes aShape1, aShape2, aShape3, aShape4 and the plane aPlane. The distance is the length of a projection from the shape to the plane.

        :param aShape1:
        :type aShape1: TopoDS_Shape &
        :param aShape2:
        :type aShape2: TopoDS_Shape &
        :param aShape3:
        :type aShape3: TopoDS_Shape &
        :param aShape4:
        :type aShape4: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        """
        _AIS.AIS_EqualDistanceRelation_swiginit(self, _AIS.new_AIS_EqualDistanceRelation(*args))

    def SetShape3(self, *args) -> "void":
        """
        * Sets the shape aShape to be used as the shape aShape3 in the framework created at construction time.

        :param aShape:
        :type aShape: TopoDS_Shape &
        :rtype: None

        """
        return _AIS.AIS_EqualDistanceRelation_SetShape3(self, *args)


    def Shape3(self, *args) -> "TopoDS_Shape const":
        """
        * Returns the shape aShape3 from the framework created at construction time.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_EqualDistanceRelation_Shape3(self, *args)


    def SetShape4(self, *args) -> "void":
        """
        * Sets the shape aShape to be used as the shape aShape4 in the framework created at construction time.

        :param aShape:
        :type aShape: TopoDS_Shape &
        :rtype: None

        """
        return _AIS.AIS_EqualDistanceRelation_SetShape4(self, *args)


    def Shape4(self, *args) -> "TopoDS_Shape const":
        """
        * Returns the shape aShape4 from the framework created at construction time.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_EqualDistanceRelation_Shape4(self, *args)


    def Compute(self, *args) -> "void":
        """
        * Computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_EqualDistanceRelation_Compute(self, *args)


    def ComputeTwoEdgesLength(*args) -> "void":
        """
        * Computes the location of an intreval between between two edges. FirstAttach , SecondAttach are the returned extreme points of the interval.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aDrawer:
        :type aDrawer: Handle_AIS_Drawer &
        :param ArrowSize:
        :type ArrowSize: float
        :param FirstEdge:
        :type FirstEdge: TopoDS_Edge &
        :param SecondEdge:
        :type SecondEdge: TopoDS_Edge &
        :param Plane:
        :type Plane: Handle_Geom_Plane &
        :param AutomaticPos:
        :type AutomaticPos: bool
        :param IsSetBndBox:
        :type IsSetBndBox: bool
        :param BndBox:
        :type BndBox: Bnd_Box &
        :param Position:
        :type Position: gp_Pnt
        :param FirstAttach:
        :type FirstAttach: gp_Pnt
        :param SecondAttach:
        :type SecondAttach: gp_Pnt
        :param FirstExtreme:
        :type FirstExtreme: gp_Pnt
        :param SecondExtreme:
        :type SecondExtreme: gp_Pnt
        :param SymbolPrs:
        :type SymbolPrs: DsgPrs_ArrowSide &
        :rtype: void

        """
        return _AIS.AIS_EqualDistanceRelation_ComputeTwoEdgesLength(*args)

    ComputeTwoEdgesLength = staticmethod(ComputeTwoEdgesLength)

    def ComputeTwoVerticesLength(*args) -> "void":
        """
        * Computes the interval position between two vertexs. FirstAttach, SecondAttach are the returned extreme points of the interval.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aDrawer:
        :type aDrawer: Handle_AIS_Drawer &
        :param ArrowSize:
        :type ArrowSize: float
        :param FirstVertex:
        :type FirstVertex: TopoDS_Vertex &
        :param SecondVertex:
        :type SecondVertex: TopoDS_Vertex &
        :param Plane:
        :type Plane: Handle_Geom_Plane &
        :param AutomaticPos:
        :type AutomaticPos: bool
        :param IsSetBndBox:
        :type IsSetBndBox: bool
        :param BndBox:
        :type BndBox: Bnd_Box &
        :param TypeDist:
        :type TypeDist: AIS_TypeOfDist
        :param Position:
        :type Position: gp_Pnt
        :param FirstAttach:
        :type FirstAttach: gp_Pnt
        :param SecondAttach:
        :type SecondAttach: gp_Pnt
        :param FirstExtreme:
        :type FirstExtreme: gp_Pnt
        :param SecondExtreme:
        :type SecondExtreme: gp_Pnt
        :param SymbolPrs:
        :type SymbolPrs: DsgPrs_ArrowSide &
        :rtype: void

        """
        return _AIS.AIS_EqualDistanceRelation_ComputeTwoVerticesLength(*args)

    ComputeTwoVerticesLength = staticmethod(ComputeTwoVerticesLength)

    def ComputeOneEdgeOneVertexLength(*args) -> "void":
        """
        * Compute the interval location between a vertex and an edge. Edge may be a line or a circle.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aDrawer:
        :type aDrawer: Handle_AIS_Drawer &
        :param ArrowSize:
        :type ArrowSize: float
        :param FirstShape:
        :type FirstShape: TopoDS_Shape &
        :param SecondShape:
        :type SecondShape: TopoDS_Shape &
        :param Plane:
        :type Plane: Handle_Geom_Plane &
        :param AutomaticPos:
        :type AutomaticPos: bool
        :param IsSetBndBox:
        :type IsSetBndBox: bool
        :param BndBox:
        :type BndBox: Bnd_Box &
        :param Position:
        :type Position: gp_Pnt
        :param FirstAttach:
        :type FirstAttach: gp_Pnt
        :param SecondAttach:
        :type SecondAttach: gp_Pnt
        :param FirstExtreme:
        :type FirstExtreme: gp_Pnt
        :param SecondExtreme:
        :type SecondExtreme: gp_Pnt
        :param SymbolPrs:
        :type SymbolPrs: DsgPrs_ArrowSide &
        :rtype: void

        """
        return _AIS.AIS_EqualDistanceRelation_ComputeOneEdgeOneVertexLength(*args)

    ComputeOneEdgeOneVertexLength = staticmethod(ComputeOneEdgeOneVertexLength)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_EqualDistanceRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_EqualDistanceRelation
AIS_EqualDistanceRelation.SetShape3 = new_instancemethod(_AIS.AIS_EqualDistanceRelation_SetShape3, None, AIS_EqualDistanceRelation)
AIS_EqualDistanceRelation.Shape3 = new_instancemethod(_AIS.AIS_EqualDistanceRelation_Shape3, None, AIS_EqualDistanceRelation)
AIS_EqualDistanceRelation.SetShape4 = new_instancemethod(_AIS.AIS_EqualDistanceRelation_SetShape4, None, AIS_EqualDistanceRelation)
AIS_EqualDistanceRelation.Shape4 = new_instancemethod(_AIS.AIS_EqualDistanceRelation_Shape4, None, AIS_EqualDistanceRelation)
AIS_EqualDistanceRelation.Compute = new_instancemethod(_AIS.AIS_EqualDistanceRelation_Compute, None, AIS_EqualDistanceRelation)
AIS_EqualDistanceRelation_swigregister = _AIS.AIS_EqualDistanceRelation_swigregister
AIS_EqualDistanceRelation_swigregister(AIS_EqualDistanceRelation)

def AIS_EqualDistanceRelation_ComputeTwoEdgesLength(*args) -> "void":
    """
    * Computes the location of an intreval between between two edges. FirstAttach , SecondAttach are the returned extreme points of the interval.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aDrawer:
    :type aDrawer: Handle_AIS_Drawer &
    :param ArrowSize:
    :type ArrowSize: float
    :param FirstEdge:
    :type FirstEdge: TopoDS_Edge &
    :param SecondEdge:
    :type SecondEdge: TopoDS_Edge &
    :param Plane:
    :type Plane: Handle_Geom_Plane &
    :param AutomaticPos:
    :type AutomaticPos: bool
    :param IsSetBndBox:
    :type IsSetBndBox: bool
    :param BndBox:
    :type BndBox: Bnd_Box &
    :param Position:
    :type Position: gp_Pnt
    :param FirstAttach:
    :type FirstAttach: gp_Pnt
    :param SecondAttach:
    :type SecondAttach: gp_Pnt
    :param FirstExtreme:
    :type FirstExtreme: gp_Pnt
    :param SecondExtreme:
    :type SecondExtreme: gp_Pnt
    :param SymbolPrs:
    :type SymbolPrs: DsgPrs_ArrowSide &
    :rtype: void

    """
    return _AIS.AIS_EqualDistanceRelation_ComputeTwoEdgesLength(*args)

def AIS_EqualDistanceRelation_ComputeTwoVerticesLength(*args) -> "void":
    """
    * Computes the interval position between two vertexs. FirstAttach, SecondAttach are the returned extreme points of the interval.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aDrawer:
    :type aDrawer: Handle_AIS_Drawer &
    :param ArrowSize:
    :type ArrowSize: float
    :param FirstVertex:
    :type FirstVertex: TopoDS_Vertex &
    :param SecondVertex:
    :type SecondVertex: TopoDS_Vertex &
    :param Plane:
    :type Plane: Handle_Geom_Plane &
    :param AutomaticPos:
    :type AutomaticPos: bool
    :param IsSetBndBox:
    :type IsSetBndBox: bool
    :param BndBox:
    :type BndBox: Bnd_Box &
    :param TypeDist:
    :type TypeDist: AIS_TypeOfDist
    :param Position:
    :type Position: gp_Pnt
    :param FirstAttach:
    :type FirstAttach: gp_Pnt
    :param SecondAttach:
    :type SecondAttach: gp_Pnt
    :param FirstExtreme:
    :type FirstExtreme: gp_Pnt
    :param SecondExtreme:
    :type SecondExtreme: gp_Pnt
    :param SymbolPrs:
    :type SymbolPrs: DsgPrs_ArrowSide &
    :rtype: void

    """
    return _AIS.AIS_EqualDistanceRelation_ComputeTwoVerticesLength(*args)

def AIS_EqualDistanceRelation_ComputeOneEdgeOneVertexLength(*args) -> "void":
    """
    * Compute the interval location between a vertex and an edge. Edge may be a line or a circle.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aDrawer:
    :type aDrawer: Handle_AIS_Drawer &
    :param ArrowSize:
    :type ArrowSize: float
    :param FirstShape:
    :type FirstShape: TopoDS_Shape &
    :param SecondShape:
    :type SecondShape: TopoDS_Shape &
    :param Plane:
    :type Plane: Handle_Geom_Plane &
    :param AutomaticPos:
    :type AutomaticPos: bool
    :param IsSetBndBox:
    :type IsSetBndBox: bool
    :param BndBox:
    :type BndBox: Bnd_Box &
    :param Position:
    :type Position: gp_Pnt
    :param FirstAttach:
    :type FirstAttach: gp_Pnt
    :param SecondAttach:
    :type SecondAttach: gp_Pnt
    :param FirstExtreme:
    :type FirstExtreme: gp_Pnt
    :param SecondExtreme:
    :type SecondExtreme: gp_Pnt
    :param SymbolPrs:
    :type SymbolPrs: DsgPrs_ArrowSide &
    :rtype: void

    """
    return _AIS.AIS_EqualDistanceRelation_ComputeOneEdgeOneVertexLength(*args)

class Handle_AIS_EqualDistanceRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_EqualDistanceRelation_swiginit(self, _AIS.new_Handle_AIS_EqualDistanceRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_EqualDistanceRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_EqualDistanceRelation
Handle_AIS_EqualDistanceRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_EqualDistanceRelation_Nullify, None, Handle_AIS_EqualDistanceRelation)
Handle_AIS_EqualDistanceRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_EqualDistanceRelation_IsNull, None, Handle_AIS_EqualDistanceRelation)
Handle_AIS_EqualDistanceRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_EqualDistanceRelation__get_reference, None, Handle_AIS_EqualDistanceRelation)
Handle_AIS_EqualDistanceRelation_swigregister = _AIS.Handle_AIS_EqualDistanceRelation_swigregister
Handle_AIS_EqualDistanceRelation_swigregister(Handle_AIS_EqualDistanceRelation)

def Handle_AIS_EqualDistanceRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_EqualDistanceRelation const":
    return _AIS.Handle_AIS_EqualDistanceRelation_DownCast(AnObject)
Handle_AIS_EqualDistanceRelation_DownCast = _AIS.Handle_AIS_EqualDistanceRelation_DownCast

class AIS_EqualRadiusRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates equal relation of two arc's radiuses. If one of edges is not in the given plane, the presentation method projects it onto the plane.

        :param aFirstEdge:
        :type aFirstEdge: TopoDS_Edge &
        :param aSecondEdge:
        :type aSecondEdge: TopoDS_Edge &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        """
        _AIS.AIS_EqualRadiusRelation_swiginit(self, _AIS.new_AIS_EqualRadiusRelation(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_EqualRadiusRelation_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_EqualRadiusRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_EqualRadiusRelation
AIS_EqualRadiusRelation.Compute = new_instancemethod(_AIS.AIS_EqualRadiusRelation_Compute, None, AIS_EqualRadiusRelation)
AIS_EqualRadiusRelation_swigregister = _AIS.AIS_EqualRadiusRelation_swigregister
AIS_EqualRadiusRelation_swigregister(AIS_EqualRadiusRelation)

class Handle_AIS_EqualRadiusRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_EqualRadiusRelation_swiginit(self, _AIS.new_Handle_AIS_EqualRadiusRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_EqualRadiusRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_EqualRadiusRelation
Handle_AIS_EqualRadiusRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_EqualRadiusRelation_Nullify, None, Handle_AIS_EqualRadiusRelation)
Handle_AIS_EqualRadiusRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_EqualRadiusRelation_IsNull, None, Handle_AIS_EqualRadiusRelation)
Handle_AIS_EqualRadiusRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_EqualRadiusRelation__get_reference, None, Handle_AIS_EqualRadiusRelation)
Handle_AIS_EqualRadiusRelation_swigregister = _AIS.Handle_AIS_EqualRadiusRelation_swigregister
Handle_AIS_EqualRadiusRelation_swigregister(Handle_AIS_EqualRadiusRelation)

def Handle_AIS_EqualRadiusRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_EqualRadiusRelation const":
    return _AIS.Handle_AIS_EqualRadiusRelation_DownCast(AnObject)
Handle_AIS_EqualRadiusRelation_DownCast = _AIS.Handle_AIS_EqualRadiusRelation_DownCast

class AIS_FixRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the vertex aShape, the plane aPlane and the wire aWire, which connects the two vertices in a fixed relation.

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :param aWire:
        :type aWire: TopoDS_Wire &
        :rtype: None

        * initializes the vertex aShape, the plane aPlane and the wire aWire, the position aPosition, the arrow size anArrowSize and the wire aWire, which connects the two vertices in a fixed relation.

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :param aWire:
        :type aWire: TopoDS_Wire &
        :param aPosition:
        :type aPosition: gp_Pnt
        :param anArrowSize: default value is 0.01
        :type anArrowSize: float
        :rtype: None

        * initializes the edge aShape and the plane aPlane.

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        * initializes the edge aShape, the plane aPlane, the position aPosition and the arrow size anArrowSize.

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :param aPosition:
        :type aPosition: gp_Pnt
        :param anArrowSize: default value is 0.01
        :type anArrowSize: float
        :rtype: None

        """
        _AIS.AIS_FixRelation_swiginit(self, _AIS.new_AIS_FixRelation(*args))

    def Wire(self, *args) -> "TopoDS_Wire":
        """
        * Returns the wire which connects vertices in a fixed relation.

        :rtype: TopoDS_Wire

        """
        return _AIS.AIS_FixRelation_Wire(self, *args)


    def SetWire(self, *args) -> "void":
        """
        * Constructs the wire aWire. This connects vertices which are in a fixed relation.

        :param aWire:
        :type aWire: TopoDS_Wire &
        :rtype: None

        """
        return _AIS.AIS_FixRelation_SetWire(self, *args)


    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_FixRelation_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_FixRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_FixRelation
AIS_FixRelation.Wire = new_instancemethod(_AIS.AIS_FixRelation_Wire, None, AIS_FixRelation)
AIS_FixRelation.SetWire = new_instancemethod(_AIS.AIS_FixRelation_SetWire, None, AIS_FixRelation)
AIS_FixRelation.Compute = new_instancemethod(_AIS.AIS_FixRelation_Compute, None, AIS_FixRelation)
AIS_FixRelation_swigregister = _AIS.AIS_FixRelation_swigregister
AIS_FixRelation_swigregister(AIS_FixRelation)

class Handle_AIS_FixRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_FixRelation_swiginit(self, _AIS.new_Handle_AIS_FixRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_FixRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_FixRelation
Handle_AIS_FixRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_FixRelation_Nullify, None, Handle_AIS_FixRelation)
Handle_AIS_FixRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_FixRelation_IsNull, None, Handle_AIS_FixRelation)
Handle_AIS_FixRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_FixRelation__get_reference, None, Handle_AIS_FixRelation)
Handle_AIS_FixRelation_swigregister = _AIS.Handle_AIS_FixRelation_swigregister
Handle_AIS_FixRelation_swigregister(Handle_AIS_FixRelation)

def Handle_AIS_FixRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_FixRelation const":
    return _AIS.Handle_AIS_FixRelation_DownCast(AnObject)
Handle_AIS_FixRelation_DownCast = _AIS.Handle_AIS_FixRelation_DownCast

class AIS_IdenticRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the relation of identity between the two entities, FirstShape and SecondShape. The plane aPlane is initialized in case a visual reference is needed to show identity.

        :param FirstShape:
        :type FirstShape: TopoDS_Shape &
        :param SecondShape:
        :type SecondShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        """
        _AIS.AIS_IdenticRelation_swiginit(self, _AIS.new_AIS_IdenticRelation(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_IdenticRelation_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_IdenticRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_IdenticRelation
AIS_IdenticRelation.Compute = new_instancemethod(_AIS.AIS_IdenticRelation_Compute, None, AIS_IdenticRelation)
AIS_IdenticRelation_swigregister = _AIS.AIS_IdenticRelation_swigregister
AIS_IdenticRelation_swigregister(AIS_IdenticRelation)

class Handle_AIS_IdenticRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_IdenticRelation_swiginit(self, _AIS.new_Handle_AIS_IdenticRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_IdenticRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_IdenticRelation
Handle_AIS_IdenticRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_IdenticRelation_Nullify, None, Handle_AIS_IdenticRelation)
Handle_AIS_IdenticRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_IdenticRelation_IsNull, None, Handle_AIS_IdenticRelation)
Handle_AIS_IdenticRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_IdenticRelation__get_reference, None, Handle_AIS_IdenticRelation)
Handle_AIS_IdenticRelation_swigregister = _AIS.Handle_AIS_IdenticRelation_swigregister
Handle_AIS_IdenticRelation_swigregister(Handle_AIS_IdenticRelation)

def Handle_AIS_IdenticRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_IdenticRelation const":
    return _AIS.Handle_AIS_IdenticRelation_DownCast(AnObject)
Handle_AIS_IdenticRelation_DownCast = _AIS.Handle_AIS_IdenticRelation_DownCast

class AIS_LengthDimension(AIS_Dimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Construct length dimension between face and edge. Here dimension can be built without user-defined plane. @param theFace [in] the face (first shape). @param theEdge [in] the edge (second shape).

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :rtype: None

        * Construct length dimension between two faces. @param theFirstFace [in] the first face (first shape). @param theSecondFace [in] the second face (second shape).

        :param theFirstFace:
        :type theFirstFace: TopoDS_Face &
        :param theSecondFace:
        :type theSecondFace: TopoDS_Face &
        :rtype: None

        * Construct length dimension between two points in the specified plane. @param theFirstPoint [in] the first point. @param theSecondPoint [in] the second point. @param thePlane [in] the plane to orient dimension.

        :param theFirstPoint:
        :type theFirstPoint: gp_Pnt
        :param theSecondPoint:
        :type theSecondPoint: gp_Pnt
        :param thePlane:
        :type thePlane: gp_Pln
        :rtype: None

        * Construct length dimension between two arbitrary shapes in the specified plane. @param theFirstShape [in] the first shape. @param theSecondShape [in] the second shape. @param thePlane [in] the plane to orient dimension.

        :param theFirstShape:
        :type theFirstShape: TopoDS_Shape &
        :param theSecondShape:
        :type theSecondShape: TopoDS_Shape &
        :param thePlane:
        :type thePlane: gp_Pln
        :rtype: None

        * Construct length dimension of linear edge. @param theEdge [in] the edge to measure. @param thePlane [in] the plane to orient dimension.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param thePlane:
        :type thePlane: gp_Pln
        :rtype: None

        """
        _AIS.AIS_LengthDimension_swiginit(self, _AIS.new_AIS_LengthDimension(*args))

    def FirstPoint(self, *args) -> "gp_Pnt const":
        """
        * returns first attachement point.

        :rtype: gp_Pnt

        """
        return _AIS.AIS_LengthDimension_FirstPoint(self, *args)


    def SecondPoint(self, *args) -> "gp_Pnt const":
        """
        * returns second attachement point.

        :rtype: gp_Pnt

        """
        return _AIS.AIS_LengthDimension_SecondPoint(self, *args)


    def FirstShape(self, *args) -> "TopoDS_Shape const":
        """
        * returns first attachement shape.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_LengthDimension_FirstShape(self, *args)


    def SecondShape(self, *args) -> "TopoDS_Shape const":
        """
        * returns second attachement shape.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_LengthDimension_SecondShape(self, *args)


    def SetMeasuredGeometry(self, *args) -> "void":
        """
        * Measure distance between two points. The dimension will become invalid if the new distance between attachement points is less than Precision::Confusion(). @param theFirstPoint [in] the first point. @param theSecondPoint [in] the second point. @param thePlane [in] the user-defined plane

        :param theFirstPoint:
        :type theFirstPoint: gp_Pnt
        :param theSecondPoint:
        :type theSecondPoint: gp_Pnt
        :param thePlane:
        :type thePlane: gp_Pln
        :rtype: None

        * Measure length of edge. The dimension will become invalid if the new length of edge is less than Precision::Confusion(). @param theEdge [in] the edge to measure. @param thePlane [in] the user-defined plane

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param thePlane:
        :type thePlane: gp_Pln
        :rtype: None

        * Measure distance between two faces. The dimension will become invalid if the distance can not be measured or it is less than Precision::Confusion(). @param theFirstFace [in] the first face (first shape). @param theSecondFace [in] the second face (second shape).

        :param theFirstFace:
        :type theFirstFace: TopoDS_Face &
        :param theSecondFace:
        :type theSecondFace: TopoDS_Face &
        :rtype: None

        * Measure distance between face and edge. The dimension will become invalid if the distance can not be measured or it is less than Precision::Confusion(). @param theFace [in] the face (first shape). @param theEdge [in] the edge (second shape).

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :rtype: None

        """
        return _AIS.AIS_LengthDimension_SetMeasuredGeometry(self, *args)


    def SetMeasuredShapes(self, *args) -> "void":
        """
        * Measure distance between generic pair of shapes (edges, vertices, length), where measuring is applicable. @param theFirstShape [in] the first shape. @param theSecondShape [in] the second shape.

        :param theFirstShape:
        :type theFirstShape: TopoDS_Shape &
        :param theSecondShape:
        :type theSecondShape: TopoDS_Shape &
        :rtype: None

        """
        return _AIS.AIS_LengthDimension_SetMeasuredShapes(self, *args)


    def SetTextPosition(self, *args) -> "void":
        """
        :param theTextPos:
        :type theTextPos: gp_Pnt
        :rtype: void

        """
        return _AIS.AIS_LengthDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args) -> "gp_Pnt const":
        """
        :rtype: gp_Pnt

        """
        return _AIS.AIS_LengthDimension_GetTextPosition(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_LengthDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_LengthDimension
AIS_LengthDimension.FirstPoint = new_instancemethod(_AIS.AIS_LengthDimension_FirstPoint, None, AIS_LengthDimension)
AIS_LengthDimension.SecondPoint = new_instancemethod(_AIS.AIS_LengthDimension_SecondPoint, None, AIS_LengthDimension)
AIS_LengthDimension.FirstShape = new_instancemethod(_AIS.AIS_LengthDimension_FirstShape, None, AIS_LengthDimension)
AIS_LengthDimension.SecondShape = new_instancemethod(_AIS.AIS_LengthDimension_SecondShape, None, AIS_LengthDimension)
AIS_LengthDimension.SetMeasuredGeometry = new_instancemethod(_AIS.AIS_LengthDimension_SetMeasuredGeometry, None, AIS_LengthDimension)
AIS_LengthDimension.SetMeasuredShapes = new_instancemethod(_AIS.AIS_LengthDimension_SetMeasuredShapes, None, AIS_LengthDimension)
AIS_LengthDimension.SetTextPosition = new_instancemethod(_AIS.AIS_LengthDimension_SetTextPosition, None, AIS_LengthDimension)
AIS_LengthDimension.GetTextPosition = new_instancemethod(_AIS.AIS_LengthDimension_GetTextPosition, None, AIS_LengthDimension)
AIS_LengthDimension_swigregister = _AIS.AIS_LengthDimension_swigregister
AIS_LengthDimension_swigregister(AIS_LengthDimension)

class Handle_AIS_LengthDimension(Handle_AIS_Dimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_LengthDimension_swiginit(self, _AIS.new_Handle_AIS_LengthDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_LengthDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_LengthDimension
Handle_AIS_LengthDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_LengthDimension_Nullify, None, Handle_AIS_LengthDimension)
Handle_AIS_LengthDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_LengthDimension_IsNull, None, Handle_AIS_LengthDimension)
Handle_AIS_LengthDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_LengthDimension__get_reference, None, Handle_AIS_LengthDimension)
Handle_AIS_LengthDimension_swigregister = _AIS.Handle_AIS_LengthDimension_swigregister
Handle_AIS_LengthDimension_swigregister(Handle_AIS_LengthDimension)

def Handle_AIS_LengthDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_LengthDimension const":
    return _AIS.Handle_AIS_LengthDimension_DownCast(AnObject)
Handle_AIS_LengthDimension_DownCast = _AIS.Handle_AIS_LengthDimension_DownCast

class AIS_MidPointRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param aSymmTool:
        :type aSymmTool: TopoDS_Shape &
        :param FirstShape:
        :type FirstShape: TopoDS_Shape &
        :param SecondShape:
        :type SecondShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        """
        _AIS.AIS_MidPointRelation_swiginit(self, _AIS.new_AIS_MidPointRelation(*args))

    def SetTool(self, *args) -> "void":
        """
        :param aMidPointTool:
        :type aMidPointTool: TopoDS_Shape &
        :rtype: None

        """
        return _AIS.AIS_MidPointRelation_SetTool(self, *args)


    def GetTool(self, *args) -> "TopoDS_Shape const":
        """
        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_MidPointRelation_GetTool(self, *args)


    def Compute(self, *args) -> "void":
        """
        * Computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_MidPointRelation_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_MidPointRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_MidPointRelation
AIS_MidPointRelation.SetTool = new_instancemethod(_AIS.AIS_MidPointRelation_SetTool, None, AIS_MidPointRelation)
AIS_MidPointRelation.GetTool = new_instancemethod(_AIS.AIS_MidPointRelation_GetTool, None, AIS_MidPointRelation)
AIS_MidPointRelation.Compute = new_instancemethod(_AIS.AIS_MidPointRelation_Compute, None, AIS_MidPointRelation)
AIS_MidPointRelation_swigregister = _AIS.AIS_MidPointRelation_swigregister
AIS_MidPointRelation_swigregister(AIS_MidPointRelation)

class Handle_AIS_MidPointRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_MidPointRelation_swiginit(self, _AIS.new_Handle_AIS_MidPointRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_MidPointRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_MidPointRelation
Handle_AIS_MidPointRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_MidPointRelation_Nullify, None, Handle_AIS_MidPointRelation)
Handle_AIS_MidPointRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_MidPointRelation_IsNull, None, Handle_AIS_MidPointRelation)
Handle_AIS_MidPointRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_MidPointRelation__get_reference, None, Handle_AIS_MidPointRelation)
Handle_AIS_MidPointRelation_swigregister = _AIS.Handle_AIS_MidPointRelation_swigregister
Handle_AIS_MidPointRelation_swigregister(Handle_AIS_MidPointRelation)

def Handle_AIS_MidPointRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_MidPointRelation const":
    return _AIS.Handle_AIS_MidPointRelation_DownCast(AnObject)
Handle_AIS_MidPointRelation_DownCast = _AIS.Handle_AIS_MidPointRelation_DownCast

class AIS_OffsetDimension(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs the offset display object defined by the first shape aFShape, the second shape aSShape, the dimension aVal, and the text aText.

        :param FistShape:
        :type FistShape: TopoDS_Shape &
        :param SecondShape:
        :type SecondShape: TopoDS_Shape &
        :param aVal:
        :type aVal: float
        :param aText:
        :type aText: TCollection_ExtendedString &
        :rtype: None

        """
        _AIS.AIS_OffsetDimension_swiginit(self, _AIS.new_AIS_OffsetDimension(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_OffsetDimension_Compute(self, *args)


    def SetRelativePos(self, *args) -> "void":
        """
        * Sets a transformation aTrsf for presentation and selection to a relative position.

        :param aTrsf:
        :type aTrsf: gp_Trsf
        :rtype: None

        """
        return _AIS.AIS_OffsetDimension_SetRelativePos(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_OffsetDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_OffsetDimension
AIS_OffsetDimension.Compute = new_instancemethod(_AIS.AIS_OffsetDimension_Compute, None, AIS_OffsetDimension)
AIS_OffsetDimension.SetRelativePos = new_instancemethod(_AIS.AIS_OffsetDimension_SetRelativePos, None, AIS_OffsetDimension)
AIS_OffsetDimension_swigregister = _AIS.AIS_OffsetDimension_swigregister
AIS_OffsetDimension_swigregister(AIS_OffsetDimension)

class Handle_AIS_OffsetDimension(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_OffsetDimension_swiginit(self, _AIS.new_Handle_AIS_OffsetDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_OffsetDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_OffsetDimension
Handle_AIS_OffsetDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_OffsetDimension_Nullify, None, Handle_AIS_OffsetDimension)
Handle_AIS_OffsetDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_OffsetDimension_IsNull, None, Handle_AIS_OffsetDimension)
Handle_AIS_OffsetDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_OffsetDimension__get_reference, None, Handle_AIS_OffsetDimension)
Handle_AIS_OffsetDimension_swigregister = _AIS.Handle_AIS_OffsetDimension_swigregister
Handle_AIS_OffsetDimension_swigregister(Handle_AIS_OffsetDimension)

def Handle_AIS_OffsetDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_OffsetDimension const":
    return _AIS.Handle_AIS_OffsetDimension_DownCast(AnObject)
Handle_AIS_OffsetDimension_DownCast = _AIS.Handle_AIS_OffsetDimension_DownCast

class AIS_ParallelRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an object to display parallel constraints. This object is defined by the first shape aFShape and the second shape aSShape and the plane aPlane.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aSShape:
        :type aSShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        * Constructs an object to display parallel constraints. This object is defined by the first shape aFShape and the second shape aSShape the plane aPlane, the position aPosition, the type of arrow, aSymbolPrs and its size anArrowSize.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aSShape:
        :type aSShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :param aPosition:
        :type aPosition: gp_Pnt
        :param aSymbolPrs:
        :type aSymbolPrs: DsgPrs_ArrowSide
        :param anArrowSize: default value is 0.01
        :type anArrowSize: float
        :rtype: None

        """
        _AIS.AIS_ParallelRelation_swiginit(self, _AIS.new_AIS_ParallelRelation(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_ParallelRelation_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_ParallelRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_ParallelRelation
AIS_ParallelRelation.Compute = new_instancemethod(_AIS.AIS_ParallelRelation_Compute, None, AIS_ParallelRelation)
AIS_ParallelRelation_swigregister = _AIS.AIS_ParallelRelation_swigregister
AIS_ParallelRelation_swigregister(AIS_ParallelRelation)

class Handle_AIS_ParallelRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_ParallelRelation_swiginit(self, _AIS.new_Handle_AIS_ParallelRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_ParallelRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_ParallelRelation
Handle_AIS_ParallelRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_ParallelRelation_Nullify, None, Handle_AIS_ParallelRelation)
Handle_AIS_ParallelRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_ParallelRelation_IsNull, None, Handle_AIS_ParallelRelation)
Handle_AIS_ParallelRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_ParallelRelation__get_reference, None, Handle_AIS_ParallelRelation)
Handle_AIS_ParallelRelation_swigregister = _AIS.Handle_AIS_ParallelRelation_swigregister
Handle_AIS_ParallelRelation_swigregister(Handle_AIS_ParallelRelation)

def Handle_AIS_ParallelRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_ParallelRelation const":
    return _AIS.Handle_AIS_ParallelRelation_DownCast(AnObject)
Handle_AIS_ParallelRelation_DownCast = _AIS.Handle_AIS_ParallelRelation_DownCast

class AIS_PerpendicularRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an object to display constraints of perpendicularity on shapes. This object is defined by a first shape aFShape, a second shape aSShape, and a plane aPlane. aPlane is the plane of reference to show and test the perpendicular relation between two shapes, at least one of which has a revolved surface.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aSShape:
        :type aSShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        * Constructs an object to display constraints of perpendicularity on shapes. This object is defined by a first shape aFShape and a second shape aSShape.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aSShape:
        :type aSShape: TopoDS_Shape &
        :rtype: None

        """
        _AIS.AIS_PerpendicularRelation_swiginit(self, _AIS.new_AIS_PerpendicularRelation(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_PerpendicularRelation_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_PerpendicularRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_PerpendicularRelation
AIS_PerpendicularRelation.Compute = new_instancemethod(_AIS.AIS_PerpendicularRelation_Compute, None, AIS_PerpendicularRelation)
AIS_PerpendicularRelation_swigregister = _AIS.AIS_PerpendicularRelation_swigregister
AIS_PerpendicularRelation_swigregister(AIS_PerpendicularRelation)

class Handle_AIS_PerpendicularRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_PerpendicularRelation_swiginit(self, _AIS.new_Handle_AIS_PerpendicularRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_PerpendicularRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_PerpendicularRelation
Handle_AIS_PerpendicularRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_PerpendicularRelation_Nullify, None, Handle_AIS_PerpendicularRelation)
Handle_AIS_PerpendicularRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_PerpendicularRelation_IsNull, None, Handle_AIS_PerpendicularRelation)
Handle_AIS_PerpendicularRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_PerpendicularRelation__get_reference, None, Handle_AIS_PerpendicularRelation)
Handle_AIS_PerpendicularRelation_swigregister = _AIS.Handle_AIS_PerpendicularRelation_swigregister
Handle_AIS_PerpendicularRelation_swigregister(Handle_AIS_PerpendicularRelation)

def Handle_AIS_PerpendicularRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_PerpendicularRelation const":
    return _AIS.Handle_AIS_PerpendicularRelation_DownCast(AnObject)
Handle_AIS_PerpendicularRelation_DownCast = _AIS.Handle_AIS_PerpendicularRelation_DownCast

class AIS_RadiusDimension(AIS_Dimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Create radius dimension for the circle geometry. @param theCircle [in] the circle to measure.

        :param theCircle:
        :type theCircle: gp_Circ
        :rtype: None

        * Create radius dimension for the circle geometry and define its orientation by location of the first point on that circle. @param theCircle [in] the circle to measure. @param theAnchorPoint [in] the point to define the position of the dimension attachment on the circle.

        :param theCircle:
        :type theCircle: gp_Circ
        :param theAnchorPoint:
        :type theAnchorPoint: gp_Pnt
        :rtype: None

        * Create radius dimension for the arbitrary shape (if possible). @param theShape [in] the shape to measure.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        """
        _AIS.AIS_RadiusDimension_swiginit(self, _AIS.new_AIS_RadiusDimension(*args))

    def Circle(self, *args) -> "gp_Circ const":
        """
        * returns measured geometry circle.

        :rtype: gp_Circ

        """
        return _AIS.AIS_RadiusDimension_Circle(self, *args)


    def AnchorPoint(self, *args) -> "gp_Pnt const":
        """
        * returns anchor point on circle for radius dimension.

        :rtype: gp_Pnt

        """
        return _AIS.AIS_RadiusDimension_AnchorPoint(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape const":
        """
        * returns the measured shape.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_RadiusDimension_Shape(self, *args)


    def SetMeasuredGeometry(self, *args) -> "void":
        """
        * Measure radius of the circle. The dimension will become invalid if the radius of the circle is less than Precision::Confusion(). @param theCircle [in] the circle to measure.

        :param theCircle:
        :type theCircle: gp_Circ
        :rtype: None

        * Measure radius of the circle and orient the dimension so the dimension lines attaches to anchor point on the circle. The dimension will become invalid if the radius of the circle is less than Precision::Confusion(). @param theCircle [in] the circle to measure. @param theAnchorPoint [in] the point to attach the dimension lines.

        :param theCircle:
        :type theCircle: gp_Circ
        :param theAnchorPoint:
        :type theAnchorPoint: gp_Pnt
        :rtype: None

        * Measure radius on the passed shape, if applicable. The dimension will become invalid if the passed shape is not measurable or if measured diameter value is less than Precision::Confusion(). @param theShape [in] the shape to measure.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        """
        return _AIS.AIS_RadiusDimension_SetMeasuredGeometry(self, *args)


    def SetTextPosition(self, *args) -> "void":
        """
        :param theTextPos:
        :type theTextPos: gp_Pnt
        :rtype: void

        """
        return _AIS.AIS_RadiusDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args) -> "gp_Pnt const":
        """
        :rtype: gp_Pnt

        """
        return _AIS.AIS_RadiusDimension_GetTextPosition(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_RadiusDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_RadiusDimension
AIS_RadiusDimension.Circle = new_instancemethod(_AIS.AIS_RadiusDimension_Circle, None, AIS_RadiusDimension)
AIS_RadiusDimension.AnchorPoint = new_instancemethod(_AIS.AIS_RadiusDimension_AnchorPoint, None, AIS_RadiusDimension)
AIS_RadiusDimension.Shape = new_instancemethod(_AIS.AIS_RadiusDimension_Shape, None, AIS_RadiusDimension)
AIS_RadiusDimension.SetMeasuredGeometry = new_instancemethod(_AIS.AIS_RadiusDimension_SetMeasuredGeometry, None, AIS_RadiusDimension)
AIS_RadiusDimension.SetTextPosition = new_instancemethod(_AIS.AIS_RadiusDimension_SetTextPosition, None, AIS_RadiusDimension)
AIS_RadiusDimension.GetTextPosition = new_instancemethod(_AIS.AIS_RadiusDimension_GetTextPosition, None, AIS_RadiusDimension)
AIS_RadiusDimension_swigregister = _AIS.AIS_RadiusDimension_swigregister
AIS_RadiusDimension_swigregister(AIS_RadiusDimension)

class Handle_AIS_RadiusDimension(Handle_AIS_Dimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_RadiusDimension_swiginit(self, _AIS.new_Handle_AIS_RadiusDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_RadiusDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_RadiusDimension
Handle_AIS_RadiusDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_RadiusDimension_Nullify, None, Handle_AIS_RadiusDimension)
Handle_AIS_RadiusDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_RadiusDimension_IsNull, None, Handle_AIS_RadiusDimension)
Handle_AIS_RadiusDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_RadiusDimension__get_reference, None, Handle_AIS_RadiusDimension)
Handle_AIS_RadiusDimension_swigregister = _AIS.Handle_AIS_RadiusDimension_swigregister
Handle_AIS_RadiusDimension_swigregister(Handle_AIS_RadiusDimension)

def Handle_AIS_RadiusDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_RadiusDimension const":
    return _AIS.Handle_AIS_RadiusDimension_DownCast(AnObject)
Handle_AIS_RadiusDimension_DownCast = _AIS.Handle_AIS_RadiusDimension_DownCast

class AIS_SymmetricRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an object to display constraints of symmetricity. This object is defined by a tool aSymmTool, a first shape FirstShape, a second shape SecondShape, and a plane aPlane. aPlane serves as the axis of symmetry. aSymmTool is the shape composed of FirstShape SecondShape and aPlane. It may be queried and edited using the functions GetTool and SetTool. The two shapes are typically two edges, two vertices or two points.

        :param aSymmTool:
        :type aSymmTool: TopoDS_Shape &
        :param FirstShape:
        :type FirstShape: TopoDS_Shape &
        :param SecondShape:
        :type SecondShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :rtype: None

        """
        _AIS.AIS_SymmetricRelation_swiginit(self, _AIS.new_AIS_SymmetricRelation(*args))

    def SetTool(self, *args) -> "void":
        """
        * Sets the tool aSymmetricTool composed of a first shape, a second shape, and a plane. This tool is initially created at construction time.

        :param aSymmetricTool:
        :type aSymmetricTool: TopoDS_Shape &
        :rtype: None

        """
        return _AIS.AIS_SymmetricRelation_SetTool(self, *args)


    def GetTool(self, *args) -> "TopoDS_Shape const":
        """
        * Returns the tool composed of a first shape, a second shape, and a plane. This tool is created at construction time.

        :rtype: TopoDS_Shape

        """
        return _AIS.AIS_SymmetricRelation_GetTool(self, *args)


    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_SymmetricRelation_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_SymmetricRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_SymmetricRelation
AIS_SymmetricRelation.SetTool = new_instancemethod(_AIS.AIS_SymmetricRelation_SetTool, None, AIS_SymmetricRelation)
AIS_SymmetricRelation.GetTool = new_instancemethod(_AIS.AIS_SymmetricRelation_GetTool, None, AIS_SymmetricRelation)
AIS_SymmetricRelation.Compute = new_instancemethod(_AIS.AIS_SymmetricRelation_Compute, None, AIS_SymmetricRelation)
AIS_SymmetricRelation_swigregister = _AIS.AIS_SymmetricRelation_swigregister
AIS_SymmetricRelation_swigregister(AIS_SymmetricRelation)

class Handle_AIS_SymmetricRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_SymmetricRelation_swiginit(self, _AIS.new_Handle_AIS_SymmetricRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_SymmetricRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_SymmetricRelation
Handle_AIS_SymmetricRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_SymmetricRelation_Nullify, None, Handle_AIS_SymmetricRelation)
Handle_AIS_SymmetricRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_SymmetricRelation_IsNull, None, Handle_AIS_SymmetricRelation)
Handle_AIS_SymmetricRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_SymmetricRelation__get_reference, None, Handle_AIS_SymmetricRelation)
Handle_AIS_SymmetricRelation_swigregister = _AIS.Handle_AIS_SymmetricRelation_swigregister
Handle_AIS_SymmetricRelation_swigregister(Handle_AIS_SymmetricRelation)

def Handle_AIS_SymmetricRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_SymmetricRelation const":
    return _AIS.Handle_AIS_SymmetricRelation_DownCast(AnObject)
Handle_AIS_SymmetricRelation_DownCast = _AIS.Handle_AIS_SymmetricRelation_DownCast

class AIS_TangentRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * TwoFacesTangent or TwoEdgesTangent relation Constructs an object to display tangency constraints. This object is defined by the first shape aFShape, the second shape aSShape, the plane aPlane and the index anExternRef. aPlane serves as an optional axis. anExternRef set to 0 indicates that there is no relation.

        :param aFShape:
        :type aFShape: TopoDS_Shape &
        :param aSShape:
        :type aSShape: TopoDS_Shape &
        :param aPlane:
        :type aPlane: Handle_Geom_Plane &
        :param anExternRef: default value is 0
        :type anExternRef: int
        :rtype: None

        """
        _AIS.AIS_TangentRelation_swiginit(self, _AIS.new_AIS_TangentRelation(*args))

    def ExternRef(self, *args) -> "Standard_Integer":
        """
        * Returns the external reference for tangency. The values are as follows: - 0 - there is no connection; - 1 - there is a connection to the first shape; - 2 - there is a connection to the second shape. This reference is defined at construction time.

        :rtype: int

        """
        return _AIS.AIS_TangentRelation_ExternRef(self, *args)


    def SetExternRef(self, *args) -> "void":
        """
        * Sets the external reference for tangency, aRef. The values are as follows: - 0 - there is no connection; - 1 - there is a connection to the first shape; - 2 - there is a connection to the second shape. This reference is initially defined at construction time.

        :param aRef:
        :type aRef: int
        :rtype: None

        """
        return _AIS.AIS_TangentRelation_SetExternRef(self, *args)


    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_TangentRelation_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_TangentRelation(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_TangentRelation
AIS_TangentRelation.ExternRef = new_instancemethod(_AIS.AIS_TangentRelation_ExternRef, None, AIS_TangentRelation)
AIS_TangentRelation.SetExternRef = new_instancemethod(_AIS.AIS_TangentRelation_SetExternRef, None, AIS_TangentRelation)
AIS_TangentRelation.Compute = new_instancemethod(_AIS.AIS_TangentRelation_Compute, None, AIS_TangentRelation)
AIS_TangentRelation_swigregister = _AIS.AIS_TangentRelation_swigregister
AIS_TangentRelation_swigregister(AIS_TangentRelation)

class Handle_AIS_TangentRelation(Handle_AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_TangentRelation_swiginit(self, _AIS.new_Handle_AIS_TangentRelation(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_TangentRelation_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_TangentRelation
Handle_AIS_TangentRelation.Nullify = new_instancemethod(_AIS.Handle_AIS_TangentRelation_Nullify, None, Handle_AIS_TangentRelation)
Handle_AIS_TangentRelation.IsNull = new_instancemethod(_AIS.Handle_AIS_TangentRelation_IsNull, None, Handle_AIS_TangentRelation)
Handle_AIS_TangentRelation._get_reference = new_instancemethod(_AIS.Handle_AIS_TangentRelation__get_reference, None, Handle_AIS_TangentRelation)
Handle_AIS_TangentRelation_swigregister = _AIS.Handle_AIS_TangentRelation_swigregister
Handle_AIS_TangentRelation_swigregister(Handle_AIS_TangentRelation)

def Handle_AIS_TangentRelation_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_TangentRelation const":
    return _AIS.Handle_AIS_TangentRelation_DownCast(AnObject)
Handle_AIS_TangentRelation_DownCast = _AIS.Handle_AIS_TangentRelation_DownCast

class AIS_TexturedShape(AIS_Shape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * @name main methods Initializes the textured shape.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        """
        _AIS.AIS_TexturedShape_swiginit(self, _AIS.new_AIS_TexturedShape(*args))

    def SetTextureFileName(self, *args) -> "void":
        """
        * Sets the texture source. <theTextureFileName> can specify path to texture image or one of the standard predefined textures. The accepted file types are those used in Image_AlienPixMap with extensions such as rgb, png, jpg and more. To specify the standard predefined texture, the <theTextureFileName> should contain integer - the Graphic3d_NameOfTexture2D enumeration index. Setting texture source using this method resets the source pixmap (if was set previously).

        :param theTextureFileName:
        :type theTextureFileName: TCollection_AsciiString &
        :rtype: void

        """
        return _AIS.AIS_TexturedShape_SetTextureFileName(self, *args)


    def SetTexturePixMap(self, *args) -> "void":
        """
        * Sets the texture source. <theTexturePixMap> specifies image data. Please note that the data should be in Bottom-Up order, the flag of Image_PixMap::IsTopDown() will be ignored by graphic driver. Setting texture source using this method resets the source by filename (if was set previously).

        :param theTexturePixMap:
        :type theTexturePixMap: Image_PixMap_Handle &
        :rtype: void

        """
        return _AIS.AIS_TexturedShape_SetTexturePixMap(self, *args)


    def TextureMapState(self, *args) -> "Standard_Boolean":
        """
        * returns flag to control texture mapping (for presentation mode 3)

        :rtype: bool

        """
        return _AIS.AIS_TexturedShape_TextureMapState(self, *args)


    def SetTextureMapOn(self, *args) -> "void":
        """
        * Enables texture mapping

        :rtype: None

        """
        return _AIS.AIS_TexturedShape_SetTextureMapOn(self, *args)


    def SetTextureMapOff(self, *args) -> "void":
        """
        * Disables texture mapping

        :rtype: None

        """
        return _AIS.AIS_TexturedShape_SetTextureMapOff(self, *args)


    def TextureFile(self, *args) -> "char const *":
        """
        * returns path to the texture file

        :rtype: char *

        """
        return _AIS.AIS_TexturedShape_TextureFile(self, *args)


    def TexturePixMap(self, *args) -> "Handle_Image_PixMap":
        """
        * returns the source pixmap for texture map

        :rtype: Handle_Image_PixMap

        """
        return _AIS.AIS_TexturedShape_TexturePixMap(self, *args)


    def UpdateAttributes(self, *args) -> "void":
        """
        * @name methods to alter texture mapping properties Use this method to display the textured shape without recomputing the whole presentation. Use this method when ONLY the texture content has been changed. If other parameters (ie: scale factors, texture origin, texture repeat...) have changed, the whole presentation has to be recomputed: @code if (myShape->DisplayMode() == 3) { myAISContext->RecomputePrsOnly (myShape); } else { myAISContext->SetDisplayMode (myShape, 3, Standard_False); myAISContext->Display (myShape, Standard_True); } @endcode

        :rtype: None

        """
        return _AIS.AIS_TexturedShape_UpdateAttributes(self, *args)


    def EnableTextureModulate(self, *args) -> "void":
        """
        * Enables texture modulation

        :rtype: None

        """
        return _AIS.AIS_TexturedShape_EnableTextureModulate(self, *args)


    def DisableTextureModulate(self, *args) -> "void":
        """
        * Disables texture modulation

        :rtype: None

        """
        return _AIS.AIS_TexturedShape_DisableTextureModulate(self, *args)


    def TextureRepeat(self, *args) -> "Standard_Boolean":
        """
        * returns texture repeat flag

        :rtype: bool

        """
        return _AIS.AIS_TexturedShape_TextureRepeat(self, *args)


    def URepeat(self, *args) -> "Standard_Real":
        """
        * returns texture repeat U value

        :rtype: float

        """
        return _AIS.AIS_TexturedShape_URepeat(self, *args)


    def VRepeat(self, *args) -> "Standard_Real":
        """
        * returns texture repeat V value

        :rtype: float

        """
        return _AIS.AIS_TexturedShape_VRepeat(self, *args)


    def SetTextureRepeat(self, *args) -> "void":
        """
        * Sets the number of occurrences of the texture on each face. The texture itself is parameterized in (0,1) by (0,1). Each face of the shape to be textured is parameterized in UV space (Umin,Umax) by (Vmin,Vmax). If RepeatYN is set to false, texture coordinates are clamped in the range (0,1)x(0,1) of the face.

        :param theToRepeat:
        :type theToRepeat: bool
        :param theURepeat: default value is 1.0
        :type theURepeat: float
        :param theVRepeat: default value is 1.0
        :type theVRepeat: float
        :rtype: None

        """
        return _AIS.AIS_TexturedShape_SetTextureRepeat(self, *args)


    def TextureOrigin(self, *args) -> "Standard_Boolean":
        """
        * returns true if texture UV origin has been modified

        :rtype: bool

        """
        return _AIS.AIS_TexturedShape_TextureOrigin(self, *args)


    def TextureUOrigin(self, *args) -> "Standard_Real":
        """
        * returns texture origin U position (0.0 by default)

        :rtype: float

        """
        return _AIS.AIS_TexturedShape_TextureUOrigin(self, *args)


    def TextureVOrigin(self, *args) -> "Standard_Real":
        """
        * returns texture origin V position (0.0 by default)

        :rtype: float

        """
        return _AIS.AIS_TexturedShape_TextureVOrigin(self, *args)


    def SetTextureOrigin(self, *args) -> "void":
        """
        * Use this method to change the origin of the texture. The texel (0,0) will be mapped to the surface (UOrigin,VOrigin)

        :param theToSetTextureOrigin:
        :type theToSetTextureOrigin: bool
        :param theUOrigin: default value is 0.0
        :type theUOrigin: float
        :param theVOrigin: default value is 0.0
        :type theVOrigin: float
        :rtype: None

        """
        return _AIS.AIS_TexturedShape_SetTextureOrigin(self, *args)


    def TextureScale(self, *args) -> "Standard_Boolean":
        """
        * returns true if scale factor should be applied to texture mapping

        :rtype: bool

        """
        return _AIS.AIS_TexturedShape_TextureScale(self, *args)


    def TextureScaleU(self, *args) -> "Standard_Real":
        """
        * returns scale factor for U coordinate (1.0 by default)

        :rtype: float

        """
        return _AIS.AIS_TexturedShape_TextureScaleU(self, *args)


    def TextureScaleV(self, *args) -> "Standard_Real":
        """
        * returns scale factor for V coordinate (1.0 by default)

        :rtype: float

        """
        return _AIS.AIS_TexturedShape_TextureScaleV(self, *args)


    def SetTextureScale(self, *args) -> "void":
        """
        * Use this method to scale the texture (percent of the face). You can specify a scale factor for both U and V. Example: if you set ScaleU and ScaleV to 0.5 and you enable texture repeat, the texture will appear twice on the face in each direction.

        :param theToSetTextureScale:
        :type theToSetTextureScale: bool
        :param theScaleU: default value is 1.0
        :type theScaleU: float
        :param theScaleV: default value is 1.0
        :type theScaleV: float
        :rtype: None

        """
        return _AIS.AIS_TexturedShape_SetTextureScale(self, *args)


    def TextureModulate(self, *args) -> "Standard_Boolean":
        """
        * returns true if texture color modulation is turned on

        :rtype: bool

        """
        return _AIS.AIS_TexturedShape_TextureModulate(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_TexturedShape(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_TexturedShape
AIS_TexturedShape.SetTextureFileName = new_instancemethod(_AIS.AIS_TexturedShape_SetTextureFileName, None, AIS_TexturedShape)
AIS_TexturedShape.SetTexturePixMap = new_instancemethod(_AIS.AIS_TexturedShape_SetTexturePixMap, None, AIS_TexturedShape)
AIS_TexturedShape.TextureMapState = new_instancemethod(_AIS.AIS_TexturedShape_TextureMapState, None, AIS_TexturedShape)
AIS_TexturedShape.SetTextureMapOn = new_instancemethod(_AIS.AIS_TexturedShape_SetTextureMapOn, None, AIS_TexturedShape)
AIS_TexturedShape.SetTextureMapOff = new_instancemethod(_AIS.AIS_TexturedShape_SetTextureMapOff, None, AIS_TexturedShape)
AIS_TexturedShape.TextureFile = new_instancemethod(_AIS.AIS_TexturedShape_TextureFile, None, AIS_TexturedShape)
AIS_TexturedShape.TexturePixMap = new_instancemethod(_AIS.AIS_TexturedShape_TexturePixMap, None, AIS_TexturedShape)
AIS_TexturedShape.UpdateAttributes = new_instancemethod(_AIS.AIS_TexturedShape_UpdateAttributes, None, AIS_TexturedShape)
AIS_TexturedShape.EnableTextureModulate = new_instancemethod(_AIS.AIS_TexturedShape_EnableTextureModulate, None, AIS_TexturedShape)
AIS_TexturedShape.DisableTextureModulate = new_instancemethod(_AIS.AIS_TexturedShape_DisableTextureModulate, None, AIS_TexturedShape)
AIS_TexturedShape.TextureRepeat = new_instancemethod(_AIS.AIS_TexturedShape_TextureRepeat, None, AIS_TexturedShape)
AIS_TexturedShape.URepeat = new_instancemethod(_AIS.AIS_TexturedShape_URepeat, None, AIS_TexturedShape)
AIS_TexturedShape.VRepeat = new_instancemethod(_AIS.AIS_TexturedShape_VRepeat, None, AIS_TexturedShape)
AIS_TexturedShape.SetTextureRepeat = new_instancemethod(_AIS.AIS_TexturedShape_SetTextureRepeat, None, AIS_TexturedShape)
AIS_TexturedShape.TextureOrigin = new_instancemethod(_AIS.AIS_TexturedShape_TextureOrigin, None, AIS_TexturedShape)
AIS_TexturedShape.TextureUOrigin = new_instancemethod(_AIS.AIS_TexturedShape_TextureUOrigin, None, AIS_TexturedShape)
AIS_TexturedShape.TextureVOrigin = new_instancemethod(_AIS.AIS_TexturedShape_TextureVOrigin, None, AIS_TexturedShape)
AIS_TexturedShape.SetTextureOrigin = new_instancemethod(_AIS.AIS_TexturedShape_SetTextureOrigin, None, AIS_TexturedShape)
AIS_TexturedShape.TextureScale = new_instancemethod(_AIS.AIS_TexturedShape_TextureScale, None, AIS_TexturedShape)
AIS_TexturedShape.TextureScaleU = new_instancemethod(_AIS.AIS_TexturedShape_TextureScaleU, None, AIS_TexturedShape)
AIS_TexturedShape.TextureScaleV = new_instancemethod(_AIS.AIS_TexturedShape_TextureScaleV, None, AIS_TexturedShape)
AIS_TexturedShape.SetTextureScale = new_instancemethod(_AIS.AIS_TexturedShape_SetTextureScale, None, AIS_TexturedShape)
AIS_TexturedShape.TextureModulate = new_instancemethod(_AIS.AIS_TexturedShape_TextureModulate, None, AIS_TexturedShape)
AIS_TexturedShape_swigregister = _AIS.AIS_TexturedShape_swigregister
AIS_TexturedShape_swigregister(AIS_TexturedShape)

class Handle_AIS_TexturedShape(Handle_AIS_Shape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_TexturedShape_swiginit(self, _AIS.new_Handle_AIS_TexturedShape(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_TexturedShape_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_TexturedShape
Handle_AIS_TexturedShape.Nullify = new_instancemethod(_AIS.Handle_AIS_TexturedShape_Nullify, None, Handle_AIS_TexturedShape)
Handle_AIS_TexturedShape.IsNull = new_instancemethod(_AIS.Handle_AIS_TexturedShape_IsNull, None, Handle_AIS_TexturedShape)
Handle_AIS_TexturedShape._get_reference = new_instancemethod(_AIS.Handle_AIS_TexturedShape__get_reference, None, Handle_AIS_TexturedShape)
Handle_AIS_TexturedShape_swigregister = _AIS.Handle_AIS_TexturedShape_swigregister
Handle_AIS_TexturedShape_swigregister(Handle_AIS_TexturedShape)

def Handle_AIS_TexturedShape_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_TexturedShape const":
    return _AIS.Handle_AIS_TexturedShape_DownCast(AnObject)
Handle_AIS_TexturedShape_DownCast = _AIS.Handle_AIS_TexturedShape_DownCast

class AIS_MaxRadiusDimension(AIS_EllipseRadiusDimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Max Ellipse radius dimension Shape can be edge , planar face or cylindrical face

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aVal:
        :type aVal: float
        :param aText:
        :type aText: TCollection_ExtendedString &
        :rtype: None

        * Max Ellipse radius dimension with position Shape can be edge , planar face or cylindrical face

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aVal:
        :type aVal: float
        :param aText:
        :type aText: TCollection_ExtendedString &
        :param aPosition:
        :type aPosition: gp_Pnt
        :param aSymbolPrs:
        :type aSymbolPrs: DsgPrs_ArrowSide
        :param anArrowSize: default value is 0.0
        :type anArrowSize: float
        :rtype: None

        """
        _AIS.AIS_MaxRadiusDimension_swiginit(self, _AIS.new_AIS_MaxRadiusDimension(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_MaxRadiusDimension_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_MaxRadiusDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_MaxRadiusDimension
AIS_MaxRadiusDimension.Compute = new_instancemethod(_AIS.AIS_MaxRadiusDimension_Compute, None, AIS_MaxRadiusDimension)
AIS_MaxRadiusDimension_swigregister = _AIS.AIS_MaxRadiusDimension_swigregister
AIS_MaxRadiusDimension_swigregister(AIS_MaxRadiusDimension)

class Handle_AIS_MaxRadiusDimension(Handle_AIS_EllipseRadiusDimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_MaxRadiusDimension_swiginit(self, _AIS.new_Handle_AIS_MaxRadiusDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_MaxRadiusDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_MaxRadiusDimension
Handle_AIS_MaxRadiusDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_MaxRadiusDimension_Nullify, None, Handle_AIS_MaxRadiusDimension)
Handle_AIS_MaxRadiusDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_MaxRadiusDimension_IsNull, None, Handle_AIS_MaxRadiusDimension)
Handle_AIS_MaxRadiusDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_MaxRadiusDimension__get_reference, None, Handle_AIS_MaxRadiusDimension)
Handle_AIS_MaxRadiusDimension_swigregister = _AIS.Handle_AIS_MaxRadiusDimension_swigregister
Handle_AIS_MaxRadiusDimension_swigregister(Handle_AIS_MaxRadiusDimension)

def Handle_AIS_MaxRadiusDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_MaxRadiusDimension const":
    return _AIS.Handle_AIS_MaxRadiusDimension_DownCast(AnObject)
Handle_AIS_MaxRadiusDimension_DownCast = _AIS.Handle_AIS_MaxRadiusDimension_DownCast

class AIS_MinRadiusDimension(AIS_EllipseRadiusDimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Max Ellipse radius dimension Shape can be edge , planar face or cylindrical face

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aVal:
        :type aVal: float
        :param aText:
        :type aText: TCollection_ExtendedString &
        :rtype: None

        * Max Ellipse radius dimension with position Shape can be edge , planar face or cylindrical face

        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aVal:
        :type aVal: float
        :param aText:
        :type aText: TCollection_ExtendedString &
        :param aPosition:
        :type aPosition: gp_Pnt
        :param aSymbolPrs:
        :type aSymbolPrs: DsgPrs_ArrowSide
        :param anArrowSize: default value is 0.0
        :type anArrowSize: float
        :rtype: None

        """
        _AIS.AIS_MinRadiusDimension_swiginit(self, _AIS.new_AIS_MinRadiusDimension(*args))

    def Compute(self, *args) -> "void":
        """
        * computes the presentation according to a point of view given by <aProjector>. To be Used when the associated degenerated Presentations have been transformed by <aTrsf> which is not a Pure Translation. The HLR Prs can't be deducted automatically WARNING :<aTrsf> must be applied to the object to display before computation !!!

        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :param aTrsf:
        :type aTrsf: Handle_Geom_Transformation &
        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :rtype: void

        """
        return _AIS.AIS_MinRadiusDimension_Compute(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_AIS_MinRadiusDimension(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _AIS.delete_AIS_MinRadiusDimension
AIS_MinRadiusDimension.Compute = new_instancemethod(_AIS.AIS_MinRadiusDimension_Compute, None, AIS_MinRadiusDimension)
AIS_MinRadiusDimension_swigregister = _AIS.AIS_MinRadiusDimension_swigregister
AIS_MinRadiusDimension_swigregister(AIS_MinRadiusDimension)

class Handle_AIS_MinRadiusDimension(Handle_AIS_EllipseRadiusDimension):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AIS.Handle_AIS_MinRadiusDimension_swiginit(self, _AIS.new_Handle_AIS_MinRadiusDimension(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_AIS.Handle_AIS_MinRadiusDimension_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _AIS.delete_Handle_AIS_MinRadiusDimension
Handle_AIS_MinRadiusDimension.Nullify = new_instancemethod(_AIS.Handle_AIS_MinRadiusDimension_Nullify, None, Handle_AIS_MinRadiusDimension)
Handle_AIS_MinRadiusDimension.IsNull = new_instancemethod(_AIS.Handle_AIS_MinRadiusDimension_IsNull, None, Handle_AIS_MinRadiusDimension)
Handle_AIS_MinRadiusDimension._get_reference = new_instancemethod(_AIS.Handle_AIS_MinRadiusDimension__get_reference, None, Handle_AIS_MinRadiusDimension)
Handle_AIS_MinRadiusDimension_swigregister = _AIS.Handle_AIS_MinRadiusDimension_swigregister
Handle_AIS_MinRadiusDimension_swigregister(Handle_AIS_MinRadiusDimension)

def Handle_AIS_MinRadiusDimension_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_AIS_MinRadiusDimension const":
    return _AIS.Handle_AIS_MinRadiusDimension_DownCast(AnObject)
Handle_AIS_MinRadiusDimension_DownCast = _AIS.Handle_AIS_MinRadiusDimension_DownCast



