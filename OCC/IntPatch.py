# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _IntPatch.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntPatch')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntPatch')
    _IntPatch = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntPatch', [dirname(__file__)])
        except ImportError:
            import _IntPatch
            return _IntPatch
        try:
            _mod = imp.load_module('_IntPatch', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntPatch = swig_import_helper()
    del swig_import_helper
else:
    import _IntPatch
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntPatch.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_IntPatch.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_IntPatch.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_IntPatch.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_IntPatch.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_IntPatch.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_IntPatch.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_IntPatch.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_IntPatch.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_IntPatch.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_IntPatch.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_IntPatch.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_IntPatch.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_IntPatch.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_IntPatch.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_IntPatch.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_IntPatch.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _IntPatch.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.IntSurf
import OCC.gp
import OCC.Standard
import OCC.MMgt
import OCC.TCollection
import OCC.GeomAbs
import OCC.math
import OCC.TColStd
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.TColgp
import OCC.Adaptor3d
import OCC.Geom
import OCC.TopAbs
import OCC.Intf
import OCC.Bnd
import OCC.IntAna

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

IntPatch_Lin = _IntPatch.IntPatch_Lin
IntPatch_Circle = _IntPatch.IntPatch_Circle
IntPatch_Ellipse = _IntPatch.IntPatch_Ellipse
IntPatch_Parabola = _IntPatch.IntPatch_Parabola
IntPatch_Hyperbola = _IntPatch.IntPatch_Hyperbola
IntPatch_Analytic = _IntPatch.IntPatch_Analytic
IntPatch_Walking = _IntPatch.IntPatch_Walking
IntPatch_Restriction = _IntPatch.IntPatch_Restriction
class IntPatch_ALineToWLine(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Quad1:
        :type Quad1: IntSurf_Quadric &
        :param Quad2:
        :type Quad2: IntSurf_Quadric &
        :rtype: None

        :param Quad1:
        :type Quad1: IntSurf_Quadric &
        :param Quad2:
        :type Quad2: IntSurf_Quadric &
        :param Deflection:
        :type Deflection: float
        :param PasMaxUV:
        :type PasMaxUV: float
        :param NbMaxPoints:
        :type NbMaxPoints: int
        :rtype: None

        """
        _IntPatch.IntPatch_ALineToWLine_swiginit(self, _IntPatch.new_IntPatch_ALineToWLine(*args))

    def SetTolParam(self, *args) -> "void":
        """
        :param aT:
        :type aT: float
        :rtype: None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTolParam(self, *args)


    def TolParam(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_ALineToWLine_TolParam(self, *args)


    def SetTolOpenDomain(self, *args) -> "void":
        """
        :param aT:
        :type aT: float
        :rtype: None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTolOpenDomain(self, *args)


    def TolOpenDomain(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_ALineToWLine_TolOpenDomain(self, *args)


    def SetTolTransition(self, *args) -> "void":
        """
        :param aT:
        :type aT: float
        :rtype: None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTolTransition(self, *args)


    def TolTransition(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_ALineToWLine_TolTransition(self, *args)


    def SetTol3D(self, *args) -> "void":
        """
        :param aT:
        :type aT: float
        :rtype: None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTol3D(self, *args)


    def Tol3D(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_ALineToWLine_Tol3D(self, *args)


    def SetConstantParameter(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetConstantParameter(self, *args)


    def SetUniformAbscissa(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetUniformAbscissa(self, *args)


    def SetUniformDeflection(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetUniformDeflection(self, *args)


    def MakeWLine(self, *args) -> "Handle_IntPatch_WLine":
        """
        :param aline:
        :type aline: Handle_IntPatch_ALine &
        :rtype: Handle_IntPatch_WLine

        :param aline:
        :type aline: Handle_IntPatch_ALine &
        :param paraminf:
        :type paraminf: float
        :param paramsup:
        :type paramsup: float
        :rtype: Handle_IntPatch_WLine

        """
        return _IntPatch.IntPatch_ALineToWLine_MakeWLine(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ALineToWLine
IntPatch_ALineToWLine.SetTolParam = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetTolParam, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.TolParam = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_TolParam, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.SetTolOpenDomain = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetTolOpenDomain, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.TolOpenDomain = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_TolOpenDomain, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.SetTolTransition = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetTolTransition, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.TolTransition = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_TolTransition, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.SetTol3D = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetTol3D, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.Tol3D = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_Tol3D, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.SetConstantParameter = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetConstantParameter, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.SetUniformAbscissa = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetUniformAbscissa, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.SetUniformDeflection = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetUniformDeflection, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.MakeWLine = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_MakeWLine, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine_swigregister = _IntPatch.IntPatch_ALineToWLine_swigregister
IntPatch_ALineToWLine_swigregister(IntPatch_ALineToWLine)

class IntPatch_ArcFunction(OCC.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _IntPatch.IntPatch_ArcFunction_swiginit(self, _IntPatch.new_IntPatch_ArcFunction(*args))

    def SetQuadric(self, *args) -> "void":
        """
        :param Q:
        :type Q: IntSurf_Quadric &
        :rtype: None

        """
        return _IntPatch.IntPatch_ArcFunction_SetQuadric(self, *args)


    def Set(self, *args) -> "void":
        """
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :rtype: None

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        return _IntPatch.IntPatch_ArcFunction_Set(self, *args)


    def NbSamples(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_ArcFunction_NbSamples(self, *args)


    def Valpoint(self, *args) -> "gp_Pnt const":
        """
        :param Index:
        :type Index: int
        :rtype: gp_Pnt

        """
        return _IntPatch.IntPatch_ArcFunction_Valpoint(self, *args)


    def Quadric(self, *args) -> "IntSurf_Quadric const &":
        """
        :rtype: IntSurf_Quadric

        """
        return _IntPatch.IntPatch_ArcFunction_Quadric(self, *args)


    def Arc(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_ArcFunction_Arc(self, *args)


    def Surface(self, *args) -> "Handle_Adaptor3d_HSurface":
        """
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _IntPatch.IntPatch_ArcFunction_Surface(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ArcFunction
IntPatch_ArcFunction.SetQuadric = new_instancemethod(_IntPatch.IntPatch_ArcFunction_SetQuadric, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.Set = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Set, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.NbSamples = new_instancemethod(_IntPatch.IntPatch_ArcFunction_NbSamples, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.Valpoint = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Valpoint, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.Quadric = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Quadric, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.Arc = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Arc, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.Surface = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Surface, None, IntPatch_ArcFunction)
IntPatch_ArcFunction_swigregister = _IntPatch.IntPatch_ArcFunction_swigregister
IntPatch_ArcFunction_swigregister(IntPatch_ArcFunction)

class IntPatch_CSFunction(OCC.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * S1 is the surface on which the intersection is searched. C is a curve on the surface S2.

        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        _IntPatch.IntPatch_CSFunction_swiginit(self, _IntPatch.new_IntPatch_CSFunction(*args))

    def Point(self, *args) -> "gp_Pnt const":
        """
        :rtype: gp_Pnt

        """
        return _IntPatch.IntPatch_CSFunction_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_CSFunction_Root(self, *args)


    def AuxillarSurface(self, *args) -> "Handle_Adaptor3d_HSurface":
        """
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _IntPatch.IntPatch_CSFunction_AuxillarSurface(self, *args)


    def AuxillarCurve(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_CSFunction_AuxillarCurve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_CSFunction
IntPatch_CSFunction.Point = new_instancemethod(_IntPatch.IntPatch_CSFunction_Point, None, IntPatch_CSFunction)
IntPatch_CSFunction.Root = new_instancemethod(_IntPatch.IntPatch_CSFunction_Root, None, IntPatch_CSFunction)
IntPatch_CSFunction.AuxillarSurface = new_instancemethod(_IntPatch.IntPatch_CSFunction_AuxillarSurface, None, IntPatch_CSFunction)
IntPatch_CSFunction.AuxillarCurve = new_instancemethod(_IntPatch.IntPatch_CSFunction_AuxillarCurve, None, IntPatch_CSFunction)
IntPatch_CSFunction_swigregister = _IntPatch.IntPatch_CSFunction_swigregister
IntPatch_CSFunction_swigregister(IntPatch_CSFunction)

class IntPatch_CurvIntSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :param F:
        :type F: IntPatch_CSFunction &
        :param TolTangency:
        :type TolTangency: float
        :param MarginCoef: default value is 0.0
        :type MarginCoef: float
        :rtype: None

        :param F:
        :type F: IntPatch_CSFunction &
        :param TolTangency:
        :type TolTangency: float
        :rtype: None

        """
        _IntPatch.IntPatch_CurvIntSurf_swiginit(self, _IntPatch.new_IntPatch_CurvIntSurf(*args))

    def Perform(self, *args) -> "void":
        """
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :param Rsnld:
        :type Rsnld: math_FunctionSetRoot &
        :param u0:
        :type u0: float
        :param v0:
        :type v0: float
        :param u1:
        :type u1: float
        :param v1:
        :type v1: float
        :param w0:
        :type w0: float
        :param w1:
        :type w1: float
        :rtype: None

        """
        return _IntPatch.IntPatch_CurvIntSurf_Perform(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_CurvIntSurf_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_CurvIntSurf_IsEmpty(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        :rtype: gp_Pnt

        """
        return _IntPatch.IntPatch_CurvIntSurf_Point(self, *args)


    def ParameterOnCurve(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_CurvIntSurf_ParameterOnCurve(self, *args)


    def ParameterOnSurface(self, *args) -> "void":
        """
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: None

        """
        return _IntPatch.IntPatch_CurvIntSurf_ParameterOnSurface(self, *args)


    def Function(self, *args) -> "IntPatch_CSFunction &":
        """
        :rtype: IntPatch_CSFunction

        """
        return _IntPatch.IntPatch_CurvIntSurf_Function(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_CurvIntSurf
IntPatch_CurvIntSurf.Perform = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_Perform, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.IsDone = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_IsDone, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.IsEmpty = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_IsEmpty, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.Point = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_Point, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.ParameterOnCurve = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_ParameterOnCurve, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.ParameterOnSurface = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_ParameterOnSurface, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.Function = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_Function, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf_swigregister = _IntPatch.IntPatch_CurvIntSurf_swigregister
IntPatch_CurvIntSurf_swigregister(IntPatch_CurvIntSurf)

class IntPatch_HCurve2dTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args) -> "Standard_Real":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: float

        """
        return _IntPatch.IntPatch_HCurve2dTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args) -> "Standard_Real":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: float

        """
        return _IntPatch.IntPatch_HCurve2dTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args) -> "GeomAbs_Shape":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: GeomAbs_Shape

        """
        return _IntPatch.IntPatch_HCurve2dTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param S:
        :type S: GeomAbs_Shape
        :rtype: int

        """
        return _IntPatch.IntPatch_HCurve2dTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param T:
        :type T: TColStd_Array1OfReal &
        :param S:
        :type S: GeomAbs_Shape
        :rtype: void

        """
        return _IntPatch.IntPatch_HCurve2dTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args) -> "Standard_Boolean":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HCurve2dTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args) -> "Standard_Boolean":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HCurve2dTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args) -> "Standard_Real":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: float

        """
        return _IntPatch.IntPatch_HCurve2dTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args) -> "gp_Pnt2d":
        """
        * Computes the point of parameter U on the curve.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param U:
        :type U: float
        :rtype: gp_Pnt2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args) -> "void":
        """
        * Computes the point of parameter U on the curve.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt2d
        :rtype: void

        """
        return _IntPatch.IntPatch_HCurve2dTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args) -> "void":
        """
        * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt2d
        :param V:
        :type V: gp_Vec2d
        :rtype: void

        """
        return _IntPatch.IntPatch_HCurve2dTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt2d
        :param V1:
        :type V1: gp_Vec2d
        :param V2:
        :type V2: gp_Vec2d
        :rtype: void

        """
        return _IntPatch.IntPatch_HCurve2dTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt2d
        :param V1:
        :type V1: gp_Vec2d
        :param V2:
        :type V2: gp_Vec2d
        :param V3:
        :type V3: gp_Vec2d
        :rtype: void

        """
        return _IntPatch.IntPatch_HCurve2dTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args) -> "gp_Vec2d":
        """
        * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param U:
        :type U: float
        :param N:
        :type N: int
        :rtype: gp_Vec2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args) -> "Standard_Real":
        """
        * Returns the parametric resolution corresponding to the real space resolution <R3d>.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param R3d:
        :type R3d: float
        :rtype: float

        """
        return _IntPatch.IntPatch_HCurve2dTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args) -> "GeomAbs_CurveType":
        """
        * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: GeomAbs_CurveType

        """
        return _IntPatch.IntPatch_HCurve2dTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args) -> "gp_Lin2d":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: gp_Lin2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args) -> "gp_Circ2d":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: gp_Circ2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args) -> "gp_Elips2d":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: gp_Elips2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args) -> "gp_Hypr2d":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: gp_Hypr2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args) -> "gp_Parab2d":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: gp_Parab2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Bezier(*args) -> "Handle_Geom2d_BezierCurve":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: Handle_Geom2d_BezierCurve

        """
        return _IntPatch.IntPatch_HCurve2dTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args) -> "Handle_Geom2d_BSplineCurve":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _IntPatch.IntPatch_HCurve2dTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def NbSamples(*args) -> "Standard_Integer":
        """
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param U0:
        :type U0: float
        :param U1:
        :type U1: float
        :rtype: int

        """
        return _IntPatch.IntPatch_HCurve2dTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    __repr__ = _dumps_object


    def __init__(self):
        _IntPatch.IntPatch_HCurve2dTool_swiginit(self, _IntPatch.new_IntPatch_HCurve2dTool())
    __swig_destroy__ = _IntPatch.delete_IntPatch_HCurve2dTool
IntPatch_HCurve2dTool_swigregister = _IntPatch.IntPatch_HCurve2dTool_swigregister
IntPatch_HCurve2dTool_swigregister(IntPatch_HCurve2dTool)

def IntPatch_HCurve2dTool_FirstParameter(*args) -> "Standard_Real":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: float

    """
    return _IntPatch.IntPatch_HCurve2dTool_FirstParameter(*args)

def IntPatch_HCurve2dTool_LastParameter(*args) -> "Standard_Real":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: float

    """
    return _IntPatch.IntPatch_HCurve2dTool_LastParameter(*args)

def IntPatch_HCurve2dTool_Continuity(*args) -> "GeomAbs_Shape":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: GeomAbs_Shape

    """
    return _IntPatch.IntPatch_HCurve2dTool_Continuity(*args)

def IntPatch_HCurve2dTool_NbIntervals(*args) -> "Standard_Integer":
    """
    * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param S:
    :type S: GeomAbs_Shape
    :rtype: int

    """
    return _IntPatch.IntPatch_HCurve2dTool_NbIntervals(*args)

def IntPatch_HCurve2dTool_Intervals(*args) -> "void":
    """
    * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param T:
    :type T: TColStd_Array1OfReal &
    :param S:
    :type S: GeomAbs_Shape
    :rtype: void

    """
    return _IntPatch.IntPatch_HCurve2dTool_Intervals(*args)

def IntPatch_HCurve2dTool_IsClosed(*args) -> "Standard_Boolean":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HCurve2dTool_IsClosed(*args)

def IntPatch_HCurve2dTool_IsPeriodic(*args) -> "Standard_Boolean":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HCurve2dTool_IsPeriodic(*args)

def IntPatch_HCurve2dTool_Period(*args) -> "Standard_Real":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: float

    """
    return _IntPatch.IntPatch_HCurve2dTool_Period(*args)

def IntPatch_HCurve2dTool_Value(*args) -> "gp_Pnt2d":
    """
    * Computes the point of parameter U on the curve.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param U:
    :type U: float
    :rtype: gp_Pnt2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Value(*args)

def IntPatch_HCurve2dTool_D0(*args) -> "void":
    """
    * Computes the point of parameter U on the curve.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt2d
    :rtype: void

    """
    return _IntPatch.IntPatch_HCurve2dTool_D0(*args)

def IntPatch_HCurve2dTool_D1(*args) -> "void":
    """
    * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt2d
    :param V:
    :type V: gp_Vec2d
    :rtype: void

    """
    return _IntPatch.IntPatch_HCurve2dTool_D1(*args)

def IntPatch_HCurve2dTool_D2(*args) -> "void":
    """
    * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt2d
    :param V1:
    :type V1: gp_Vec2d
    :param V2:
    :type V2: gp_Vec2d
    :rtype: void

    """
    return _IntPatch.IntPatch_HCurve2dTool_D2(*args)

def IntPatch_HCurve2dTool_D3(*args) -> "void":
    """
    * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt2d
    :param V1:
    :type V1: gp_Vec2d
    :param V2:
    :type V2: gp_Vec2d
    :param V3:
    :type V3: gp_Vec2d
    :rtype: void

    """
    return _IntPatch.IntPatch_HCurve2dTool_D3(*args)

def IntPatch_HCurve2dTool_DN(*args) -> "gp_Vec2d":
    """
    * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param U:
    :type U: float
    :param N:
    :type N: int
    :rtype: gp_Vec2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_DN(*args)

def IntPatch_HCurve2dTool_Resolution(*args) -> "Standard_Real":
    """
    * Returns the parametric resolution corresponding to the real space resolution <R3d>.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param R3d:
    :type R3d: float
    :rtype: float

    """
    return _IntPatch.IntPatch_HCurve2dTool_Resolution(*args)

def IntPatch_HCurve2dTool_GetType(*args) -> "GeomAbs_CurveType":
    """
    * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: GeomAbs_CurveType

    """
    return _IntPatch.IntPatch_HCurve2dTool_GetType(*args)

def IntPatch_HCurve2dTool_Line(*args) -> "gp_Lin2d":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: gp_Lin2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Line(*args)

def IntPatch_HCurve2dTool_Circle(*args) -> "gp_Circ2d":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: gp_Circ2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Circle(*args)

def IntPatch_HCurve2dTool_Ellipse(*args) -> "gp_Elips2d":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: gp_Elips2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Ellipse(*args)

def IntPatch_HCurve2dTool_Hyperbola(*args) -> "gp_Hypr2d":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: gp_Hypr2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Hyperbola(*args)

def IntPatch_HCurve2dTool_Parabola(*args) -> "gp_Parab2d":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: gp_Parab2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Parabola(*args)

def IntPatch_HCurve2dTool_Bezier(*args) -> "Handle_Geom2d_BezierCurve":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: Handle_Geom2d_BezierCurve

    """
    return _IntPatch.IntPatch_HCurve2dTool_Bezier(*args)

def IntPatch_HCurve2dTool_BSpline(*args) -> "Handle_Geom2d_BSplineCurve":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: Handle_Geom2d_BSplineCurve

    """
    return _IntPatch.IntPatch_HCurve2dTool_BSpline(*args)

def IntPatch_HCurve2dTool_NbSamples(*args) -> "Standard_Integer":
    """
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param U0:
    :type U0: float
    :param U1:
    :type U1: float
    :rtype: int

    """
    return _IntPatch.IntPatch_HCurve2dTool_NbSamples(*args)

class IntPatch_HInterTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _IntPatch.IntPatch_HInterTool_swiginit(self, _IntPatch.new_IntPatch_HInterTool(*args))

    def SingularOnUMin(*args) -> "Standard_Boolean":
        """
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnUMin(*args)

    SingularOnUMin = staticmethod(SingularOnUMin)

    def SingularOnUMax(*args) -> "Standard_Boolean":
        """
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnUMax(*args)

    SingularOnUMax = staticmethod(SingularOnUMax)

    def SingularOnVMin(*args) -> "Standard_Boolean":
        """
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnVMin(*args)

    SingularOnVMin = staticmethod(SingularOnVMin)

    def SingularOnVMax(*args) -> "Standard_Boolean":
        """
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnVMax(*args)

    SingularOnVMax = staticmethod(SingularOnVMax)

    def NbSamplesU(*args) -> "Standard_Integer":
        """
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param u1:
        :type u1: float
        :param u2:
        :type u2: float
        :rtype: int

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args) -> "Standard_Integer":
        """
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param v1:
        :type v1: float
        :param v2:
        :type v2: float
        :rtype: int

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def NbSamplePoints(self, *args) -> "Standard_Integer":
        """
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: int

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplePoints(self, *args)


    def SamplePoint(self, *args) -> "void":
        """
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Index:
        :type Index: int
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: None

        """
        return _IntPatch.IntPatch_HInterTool_SamplePoint(self, *args)


    def HasBeenSeen(*args) -> "Standard_Boolean":
        """
        * Returns True if all the intersection point and edges are known on the Arc. The intersection point are given as vertices. The intersection edges are given as intervals between two vertices.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_HasBeenSeen(*args)

    HasBeenSeen = staticmethod(HasBeenSeen)

    def NbSamplesOnArc(*args) -> "Standard_Integer":
        """
        * returns the number of points which is used to make a sample on the arc. this number is a function of the Surface and the CurveOnSurface complexity.

        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :rtype: int

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesOnArc(*args)

    NbSamplesOnArc = staticmethod(NbSamplesOnArc)

    def Bounds(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Returns the parametric limits on the arc C. These limits must be finite : they are either the real limits of the arc, for a finite arc, or a bounding box for an infinite arc.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param Ufirst:
        :type Ufirst: float &
        :param Ulast:
        :type Ulast: float &
        :rtype: void

        """
        return _IntPatch.IntPatch_HInterTool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def Project(*args) -> "Standard_Real &":
        """
        * Projects the point P on the arc C. If the methods returns Standard_True, the projection is successful, and Paramproj is the parameter on the arc of the projected point, Ptproj is the projected Point. If the method returns Standard_False, Param proj and Ptproj are not significant.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param P:
        :type P: gp_Pnt2d
        :param Paramproj:
        :type Paramproj: float &
        :param Ptproj:
        :type Ptproj: gp_Pnt2d
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_Project(*args)

    Project = staticmethod(Project)

    def Tolerance(*args) -> "Standard_Real":
        """
        * Returns the parametric tolerance used to consider that the vertex and another point meet, i-e if Abs(parameter(Vertex) - parameter(OtherPnt))<= Tolerance, the points are 'merged'.

        :param V:
        :type V: Handle_Adaptor3d_HVertex &
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: float

        """
        return _IntPatch.IntPatch_HInterTool_Tolerance(*args)

    Tolerance = staticmethod(Tolerance)

    def Parameter(*args) -> "Standard_Real":
        """
        * Returns the parameter of the vertex V on the arc A.

        :param V:
        :type V: Handle_Adaptor3d_HVertex &
        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: float

        """
        return _IntPatch.IntPatch_HInterTool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    def NbPoints(*args) -> "Standard_Integer":
        """
        * Returns the number of intersection points on the arc A.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: int

        """
        return _IntPatch.IntPatch_HInterTool_NbPoints(*args)

    NbPoints = staticmethod(NbPoints)

    def Value(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Returns the value (Pt), the tolerance (Tol), and the parameter (U) on the arc A , of the intersection point of range Index.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param Index:
        :type Index: int
        :param Pt:
        :type Pt: gp_Pnt
        :param Tol:
        :type Tol: float &
        :param U:
        :type U: float &
        :rtype: void

        """
        return _IntPatch.IntPatch_HInterTool_Value(*args)

    Value = staticmethod(Value)

    def IsVertex(*args) -> "Standard_Boolean":
        """
        * Returns True if the intersection point of range Index corresponds with a vertex on the arc A.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param Index:
        :type Index: int
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_IsVertex(*args)

    IsVertex = staticmethod(IsVertex)

    def Vertex(*args) -> "void":
        """
        * When IsVertex returns True, this method returns the vertex on the arc A.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param Index:
        :type Index: int
        :param V:
        :type V: Handle_Adaptor3d_HVertex &
        :rtype: void

        """
        return _IntPatch.IntPatch_HInterTool_Vertex(*args)

    Vertex = staticmethod(Vertex)

    def NbSegments(*args) -> "Standard_Integer":
        """
        * returns the number of part of A solution of the of intersection problem.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: int

        """
        return _IntPatch.IntPatch_HInterTool_NbSegments(*args)

    NbSegments = staticmethod(NbSegments)

    def HasFirstPoint(*args) -> "Standard_Integer &":
        """
        * Returns True when the segment of range Index is not open at the left side. In that case, IndFirst is the range in the list intersection points (see NbPoints) of the one which defines the left bound of the segment. Otherwise, the method has to return False, and IndFirst has no meaning.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param Index:
        :type Index: int
        :param IndFirst:
        :type IndFirst: int &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_HasFirstPoint(*args)

    HasFirstPoint = staticmethod(HasFirstPoint)

    def HasLastPoint(*args) -> "Standard_Integer &":
        """
        * Returns True when the segment of range Index is not open at the right side. In that case, IndLast is the range in the list intersection points (see NbPoints) of the one which defines the right bound of the segment. Otherwise, the method has to return False, and IndLast has no meaning.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :param Index:
        :type Index: int
        :param IndLast:
        :type IndLast: int &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_HasLastPoint(*args)

    HasLastPoint = staticmethod(HasLastPoint)

    def IsAllSolution(*args) -> "Standard_Boolean":
        """
        * Returns True when the whole restriction is solution of the intersection problem.

        :param C:
        :type C: Handle_Adaptor2d_HCurve2d &
        :rtype: bool

        """
        return _IntPatch.IntPatch_HInterTool_IsAllSolution(*args)

    IsAllSolution = staticmethod(IsAllSolution)

    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_HInterTool
IntPatch_HInterTool.NbSamplePoints = new_instancemethod(_IntPatch.IntPatch_HInterTool_NbSamplePoints, None, IntPatch_HInterTool)
IntPatch_HInterTool.SamplePoint = new_instancemethod(_IntPatch.IntPatch_HInterTool_SamplePoint, None, IntPatch_HInterTool)
IntPatch_HInterTool_swigregister = _IntPatch.IntPatch_HInterTool_swigregister
IntPatch_HInterTool_swigregister(IntPatch_HInterTool)

def IntPatch_HInterTool_SingularOnUMin(*args) -> "Standard_Boolean":
    """
    :param S:
    :type S: Handle_Adaptor3d_HSurface &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnUMin(*args)

def IntPatch_HInterTool_SingularOnUMax(*args) -> "Standard_Boolean":
    """
    :param S:
    :type S: Handle_Adaptor3d_HSurface &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnUMax(*args)

def IntPatch_HInterTool_SingularOnVMin(*args) -> "Standard_Boolean":
    """
    :param S:
    :type S: Handle_Adaptor3d_HSurface &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnVMin(*args)

def IntPatch_HInterTool_SingularOnVMax(*args) -> "Standard_Boolean":
    """
    :param S:
    :type S: Handle_Adaptor3d_HSurface &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnVMax(*args)

def IntPatch_HInterTool_NbSamplesU(*args) -> "Standard_Integer":
    """
    :param S:
    :type S: Handle_Adaptor3d_HSurface &
    :param u1:
    :type u1: float
    :param u2:
    :type u2: float
    :rtype: int

    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesU(*args)

def IntPatch_HInterTool_NbSamplesV(*args) -> "Standard_Integer":
    """
    :param S:
    :type S: Handle_Adaptor3d_HSurface &
    :param v1:
    :type v1: float
    :param v2:
    :type v2: float
    :rtype: int

    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesV(*args)

def IntPatch_HInterTool_HasBeenSeen(*args) -> "Standard_Boolean":
    """
    * Returns True if all the intersection point and edges are known on the Arc. The intersection point are given as vertices. The intersection edges are given as intervals between two vertices.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_HasBeenSeen(*args)

def IntPatch_HInterTool_NbSamplesOnArc(*args) -> "Standard_Integer":
    """
    * returns the number of points which is used to make a sample on the arc. this number is a function of the Surface and the CurveOnSurface complexity.

    :param A:
    :type A: Handle_Adaptor2d_HCurve2d &
    :rtype: int

    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesOnArc(*args)

def IntPatch_HInterTool_Bounds(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Returns the parametric limits on the arc C. These limits must be finite : they are either the real limits of the arc, for a finite arc, or a bounding box for an infinite arc.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param Ufirst:
    :type Ufirst: float &
    :param Ulast:
    :type Ulast: float &
    :rtype: void

    """
    return _IntPatch.IntPatch_HInterTool_Bounds(*args)

def IntPatch_HInterTool_Project(*args) -> "Standard_Real &":
    """
    * Projects the point P on the arc C. If the methods returns Standard_True, the projection is successful, and Paramproj is the parameter on the arc of the projected point, Ptproj is the projected Point. If the method returns Standard_False, Param proj and Ptproj are not significant.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param P:
    :type P: gp_Pnt2d
    :param Paramproj:
    :type Paramproj: float &
    :param Ptproj:
    :type Ptproj: gp_Pnt2d
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_Project(*args)

def IntPatch_HInterTool_Tolerance(*args) -> "Standard_Real":
    """
    * Returns the parametric tolerance used to consider that the vertex and another point meet, i-e if Abs(parameter(Vertex) - parameter(OtherPnt))<= Tolerance, the points are 'merged'.

    :param V:
    :type V: Handle_Adaptor3d_HVertex &
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: float

    """
    return _IntPatch.IntPatch_HInterTool_Tolerance(*args)

def IntPatch_HInterTool_Parameter(*args) -> "Standard_Real":
    """
    * Returns the parameter of the vertex V on the arc A.

    :param V:
    :type V: Handle_Adaptor3d_HVertex &
    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: float

    """
    return _IntPatch.IntPatch_HInterTool_Parameter(*args)

def IntPatch_HInterTool_NbPoints(*args) -> "Standard_Integer":
    """
    * Returns the number of intersection points on the arc A.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: int

    """
    return _IntPatch.IntPatch_HInterTool_NbPoints(*args)

def IntPatch_HInterTool_Value(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Returns the value (Pt), the tolerance (Tol), and the parameter (U) on the arc A , of the intersection point of range Index.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param Index:
    :type Index: int
    :param Pt:
    :type Pt: gp_Pnt
    :param Tol:
    :type Tol: float &
    :param U:
    :type U: float &
    :rtype: void

    """
    return _IntPatch.IntPatch_HInterTool_Value(*args)

def IntPatch_HInterTool_IsVertex(*args) -> "Standard_Boolean":
    """
    * Returns True if the intersection point of range Index corresponds with a vertex on the arc A.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param Index:
    :type Index: int
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_IsVertex(*args)

def IntPatch_HInterTool_Vertex(*args) -> "void":
    """
    * When IsVertex returns True, this method returns the vertex on the arc A.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param Index:
    :type Index: int
    :param V:
    :type V: Handle_Adaptor3d_HVertex &
    :rtype: void

    """
    return _IntPatch.IntPatch_HInterTool_Vertex(*args)

def IntPatch_HInterTool_NbSegments(*args) -> "Standard_Integer":
    """
    * returns the number of part of A solution of the of intersection problem.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: int

    """
    return _IntPatch.IntPatch_HInterTool_NbSegments(*args)

def IntPatch_HInterTool_HasFirstPoint(*args) -> "Standard_Integer &":
    """
    * Returns True when the segment of range Index is not open at the left side. In that case, IndFirst is the range in the list intersection points (see NbPoints) of the one which defines the left bound of the segment. Otherwise, the method has to return False, and IndFirst has no meaning.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param Index:
    :type Index: int
    :param IndFirst:
    :type IndFirst: int &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_HasFirstPoint(*args)

def IntPatch_HInterTool_HasLastPoint(*args) -> "Standard_Integer &":
    """
    * Returns True when the segment of range Index is not open at the right side. In that case, IndLast is the range in the list intersection points (see NbPoints) of the one which defines the right bound of the segment. Otherwise, the method has to return False, and IndLast has no meaning.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :param Index:
    :type Index: int
    :param IndLast:
    :type IndLast: int &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_HasLastPoint(*args)

def IntPatch_HInterTool_IsAllSolution(*args) -> "Standard_Boolean":
    """
    * Returns True when the whole restriction is solution of the intersection problem.

    :param C:
    :type C: Handle_Adaptor2d_HCurve2d &
    :rtype: bool

    """
    return _IntPatch.IntPatch_HInterTool_IsAllSolution(*args)

class IntPatch_ImpImpIntersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :rtype: None

        """
        _IntPatch.IntPatch_ImpImpIntersection_swiginit(self, _IntPatch.new_IntPatch_ImpImpIntersection(*args))

    def Perform(self, *args) -> "void":
        """
        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :param isTheTrimmed: default value is Standard_False
        :type isTheTrimmed: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_ImpImpIntersection_Perform(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the calculus was succesfull.

        :rtype: bool

        """
        return _IntPatch.IntPatch_ImpImpIntersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the is no intersection.

        :rtype: bool

        """
        return _IntPatch.IntPatch_ImpImpIntersection_IsEmpty(self, *args)


    def TangentFaces(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the two patches are considered as entierly tangent, i-e every restriction arc of one patch is inside the geometric base of the otehr patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_ImpImpIntersection_TangentFaces(self, *args)


    def OppositeFaces(self, *args) -> "Standard_Boolean":
        """
        * Returns True when the TangentFaces returns True and the normal vectors evaluated at a point on the first and the second surface are opposite. The exception DomainError is raised if TangentFaces returns False.

        :rtype: bool

        """
        return _IntPatch.IntPatch_ImpImpIntersection_OppositeFaces(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 'single' points.

        :rtype: int

        """
        return _IntPatch.IntPatch_ImpImpIntersection_NbPnts(self, *args)


    def Point(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the point of range Index. An exception is raised if Index<=0 or Index>NbPnt.

        :param Index:
        :type Index: int
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_ImpImpIntersection_Point(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection lines.

        :rtype: int

        """
        return _IntPatch.IntPatch_ImpImpIntersection_NbLines(self, *args)


    def Line(self, *args) -> "Handle_IntPatch_Line":
        """
        * Returns the line of range Index. An exception is raised if Index<=0 or Index>NbLine.

        :param Index:
        :type Index: int
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_ImpImpIntersection_Line(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ImpImpIntersection
IntPatch_ImpImpIntersection.Perform = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_Perform, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.IsDone = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_IsDone, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.IsEmpty = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_IsEmpty, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.TangentFaces = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_TangentFaces, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.OppositeFaces = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_OppositeFaces, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.NbPnts = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_NbPnts, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.Point = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_Point, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.NbLines = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_NbLines, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.Line = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_Line, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection_swigregister = _IntPatch.IntPatch_ImpImpIntersection_swigregister
IntPatch_ImpImpIntersection_swigregister(IntPatch_ImpImpIntersection)

class IntPatch_ImpPrmIntersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Surf1:
        :type Surf1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param Surf2:
        :type Surf2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :param Fleche:
        :type Fleche: float
        :param Pas:
        :type Pas: float
        :rtype: None

        """
        _IntPatch.IntPatch_ImpPrmIntersection_swiginit(self, _IntPatch.new_IntPatch_ImpPrmIntersection(*args))

    def SetStartPoint(self, *args) -> "void":
        """
        * to search for solution from the given point

        :param U:
        :type U: float
        :param V:
        :type V: float
        :rtype: None

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_SetStartPoint(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param Surf1:
        :type Surf1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param Surf2:
        :type Surf2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :param Fleche:
        :type Fleche: float
        :param Pas:
        :type Pas: float
        :rtype: None

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Perform(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the calculus was succesfull.

        :rtype: bool

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the is no intersection.

        :rtype: bool

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_IsEmpty(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 'single' points.

        :rtype: int

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_NbPnts(self, *args)


    def Point(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the point of range Index. An exception is raised if Index<=0 or Index>NbPnt.

        :param Index:
        :type Index: int
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Point(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection lines.

        :rtype: int

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_NbLines(self, *args)


    def Line(self, *args) -> "Handle_IntPatch_Line":
        """
        * Returns the line of range Index. An exception is raised if Index<=0 or Index>NbLine.

        :param Index:
        :type Index: int
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Line(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ImpPrmIntersection
IntPatch_ImpPrmIntersection.SetStartPoint = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_SetStartPoint, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.Perform = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_Perform, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.IsDone = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_IsDone, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.IsEmpty = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_IsEmpty, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.NbPnts = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_NbPnts, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.Point = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_Point, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.NbLines = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_NbLines, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.Line = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_Line, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection_swigregister = _IntPatch.IntPatch_ImpPrmIntersection_swigregister
IntPatch_ImpPrmIntersection_swigregister(IntPatch_ImpPrmIntersection)

class IntPatch_InterferencePolyhedron(OCC.Intf.Intf_Interference):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an empty interference of Polyhedron.

        :rtype: None

        * Constructs and computes an interference between the two Polyhedra.

        :param Obje1:
        :type Obje1: IntPatch_Polyhedron &
        :param Obje2:
        :type Obje2: IntPatch_Polyhedron &
        :rtype: None

        * Constructs and computes the self interference of a Polyhedron.

        :param Obje:
        :type Obje: IntPatch_Polyhedron &
        :rtype: None

        """
        _IntPatch.IntPatch_InterferencePolyhedron_swiginit(self, _IntPatch.new_IntPatch_InterferencePolyhedron(*args))

    def Perform(self, *args) -> "void":
        """
        * Computes the interference between the two Polyhedra.

        :param Obje1:
        :type Obje1: IntPatch_Polyhedron &
        :param Obje2:
        :type Obje2: IntPatch_Polyhedron &
        :rtype: None

        * Computes the self interference of a Polyhedron.

        :param Obje:
        :type Obje: IntPatch_Polyhedron &
        :rtype: None

        """
        return _IntPatch.IntPatch_InterferencePolyhedron_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_InterferencePolyhedron
IntPatch_InterferencePolyhedron.Perform = new_instancemethod(_IntPatch.IntPatch_InterferencePolyhedron_Perform, None, IntPatch_InterferencePolyhedron)
IntPatch_InterferencePolyhedron_swigregister = _IntPatch.IntPatch_InterferencePolyhedron_swigregister
IntPatch_InterferencePolyhedron_swigregister(IntPatch_InterferencePolyhedron)

class IntPatch_Intersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :rtype: None

        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :rtype: None

        """
        _IntPatch.IntPatch_Intersection_swiginit(self, _IntPatch.new_IntPatch_Intersection(*args))

    def SetTolerances(self, *args) -> "void":
        """
        * Set the tolerances used by the algorithms: --- Implicit - Parametric --- Parametric - Parametric --- Implicit - Implicit //! TolArc is used to compute the intersections between the restrictions of a surface and a walking line. //! TolTang is used to compute the points on a walking line, and in geometric algorithms. //! Fleche is a parameter used in the walking algorithms to provide small curvatures on a line. //! UVMaxStep is a parameter used in the walking algorithms to compute the distance between to points in their respective parametrtic spaces.

        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :param UVMaxStep:
        :type UVMaxStep: float
        :param Fleche:
        :type Fleche: float
        :rtype: None

        """
        return _IntPatch.IntPatch_Intersection_SetTolerances(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :param isGeomInt: default value is Standard_True
        :type isGeomInt: bool
        :rtype: None

        * If isGeomInt == Standard_False, then method Param-Param intersection will be used.

        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :param LOfPnts:
        :type LOfPnts: IntSurf_ListOfPntOn2S &
        :param RestrictLine: default value is Standard_True
        :type RestrictLine: bool
        :param isGeomInt: default value is Standard_True
        :type isGeomInt: bool
        :rtype: None

        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :rtype: None

        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param TolArc:
        :type TolArc: float
        :param TolTang:
        :type TolTang: float
        :rtype: None

        """
        return _IntPatch.IntPatch_Intersection_Perform(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the calculus was succesfull.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Intersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the is no intersection.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Intersection_IsEmpty(self, *args)


    def TangentFaces(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the two patches are considered as entierly tangent, i-e every restriction arc of one patch is inside the geometric base of the other patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Intersection_TangentFaces(self, *args)


    def OppositeFaces(self, *args) -> "Standard_Boolean":
        """
        * Returns True when the TangentFaces returns True and the normal vectors evaluated at a point on the first and the second surface are opposite. The exception DomainError is raised if TangentFaces returns False.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Intersection_OppositeFaces(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 'single' points.

        :rtype: int

        """
        return _IntPatch.IntPatch_Intersection_NbPnts(self, *args)


    def Point(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the point of range Index. An exception is raised if Index<=0 or Index>NbPnt.

        :param Index:
        :type Index: int
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_Intersection_Point(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection lines.

        :rtype: int

        """
        return _IntPatch.IntPatch_Intersection_NbLines(self, *args)


    def Line(self, *args) -> "Handle_IntPatch_Line":
        """
        * Returns the line of range Index. An exception is raised if Index<=0 or Index>NbLine.

        :param Index:
        :type Index: int
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_Intersection_Line(self, *args)


    def SequenceOfLine(self, *args) -> "IntPatch_SequenceOfLine const &":
        """
        :rtype: IntPatch_SequenceOfLine

        """
        return _IntPatch.IntPatch_Intersection_SequenceOfLine(self, *args)


    def Dump(self, *args) -> "void":
        """
        * Dump of each result line. Mode for more accurate dumps.

        :param Mode:
        :type Mode: int
        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :rtype: None

        """
        return _IntPatch.IntPatch_Intersection_Dump(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Intersection
IntPatch_Intersection.SetTolerances = new_instancemethod(_IntPatch.IntPatch_Intersection_SetTolerances, None, IntPatch_Intersection)
IntPatch_Intersection.Perform = new_instancemethod(_IntPatch.IntPatch_Intersection_Perform, None, IntPatch_Intersection)
IntPatch_Intersection.IsDone = new_instancemethod(_IntPatch.IntPatch_Intersection_IsDone, None, IntPatch_Intersection)
IntPatch_Intersection.IsEmpty = new_instancemethod(_IntPatch.IntPatch_Intersection_IsEmpty, None, IntPatch_Intersection)
IntPatch_Intersection.TangentFaces = new_instancemethod(_IntPatch.IntPatch_Intersection_TangentFaces, None, IntPatch_Intersection)
IntPatch_Intersection.OppositeFaces = new_instancemethod(_IntPatch.IntPatch_Intersection_OppositeFaces, None, IntPatch_Intersection)
IntPatch_Intersection.NbPnts = new_instancemethod(_IntPatch.IntPatch_Intersection_NbPnts, None, IntPatch_Intersection)
IntPatch_Intersection.Point = new_instancemethod(_IntPatch.IntPatch_Intersection_Point, None, IntPatch_Intersection)
IntPatch_Intersection.NbLines = new_instancemethod(_IntPatch.IntPatch_Intersection_NbLines, None, IntPatch_Intersection)
IntPatch_Intersection.Line = new_instancemethod(_IntPatch.IntPatch_Intersection_Line, None, IntPatch_Intersection)
IntPatch_Intersection.SequenceOfLine = new_instancemethod(_IntPatch.IntPatch_Intersection_SequenceOfLine, None, IntPatch_Intersection)
IntPatch_Intersection.Dump = new_instancemethod(_IntPatch.IntPatch_Intersection_Dump, None, IntPatch_Intersection)
IntPatch_Intersection_swigregister = _IntPatch.IntPatch_Intersection_swigregister
IntPatch_Intersection_swigregister(IntPatch_Intersection)

class IntPatch_Line(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetValue(self, *args) -> "void":
        """
        * To set the values returned by IsUIsoS1,.... The default values are False.

        :param Uiso1:
        :type Uiso1: bool
        :param Viso1:
        :type Viso1: bool
        :param Uiso2:
        :type Uiso2: bool
        :param Viso2:
        :type Viso2: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_Line_SetValue(self, *args)


    def ArcType(self, *args) -> "IntPatch_IType":
        """
        * Returns the type of geometry 3d (Line, Circle, Parabola, Hyperbola, Ellipse, Analytic, Walking, Restriction)

        :rtype: IntPatch_IType

        """
        return _IntPatch.IntPatch_Line_ArcType(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a line of tangency between the 2 patches.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Line_IsTangent(self, *args)


    def TransitionOnS1(self, *args) -> "IntSurf_TypeTrans":
        """
        * Returns the type of the transition of the line for the first surface. The transition is 'constant' along the line. The transition is IN if the line is oriented in such a way that the system of vector (N1,N2,T) is right-handed, where N1 is the normal to the first surface at a point P, N2 is the normal to the second surface at a point P, T is the tangent to the intersection line at P. If the system of vector is left-handed, the transition is OUT. When N1 and N2 are colinear all along the intersection line, the transition will be - TOUCH, if it is possible to use the 2nd derivatives to determine the position of one surafce compared to the other (see Situation) - UNDECIDED otherwise. //! If one of the transition is TOUCH or UNDECIDED, the other one has got the same value.

        :rtype: IntSurf_TypeTrans

        """
        return _IntPatch.IntPatch_Line_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args) -> "IntSurf_TypeTrans":
        """
        * Returns the type of the transition of the line for the second surface. The transition is 'constant' along the line.

        :rtype: IntSurf_TypeTrans

        """
        return _IntPatch.IntPatch_Line_TransitionOnS2(self, *args)


    def SituationS1(self, *args) -> "IntSurf_Situation":
        """
        * Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of the first patch compared to the second one, when TransitionOnS1 or TransitionOnS2 returns TOUCH. Otherwise, an exception is raised.

        :rtype: IntSurf_Situation

        """
        return _IntPatch.IntPatch_Line_SituationS1(self, *args)


    def SituationS2(self, *args) -> "IntSurf_Situation":
        """
        * Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of the second patch compared to the first one, when TransitionOnS1 or TransitionOnS2 returns TOUCH. Otherwise, an exception is raised.

        :rtype: IntSurf_Situation

        """
        return _IntPatch.IntPatch_Line_SituationS2(self, *args)


    def IsUIsoOnS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a U isoparametric curve on the first patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Line_IsUIsoOnS1(self, *args)


    def IsVIsoOnS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a V isoparametric curve on the first patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Line_IsVIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a U isoparametric curve on the second patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Line_IsUIsoOnS2(self, *args)


    def IsVIsoOnS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a V isoparametric curve on the second patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Line_IsVIsoOnS2(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_Line(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Line
IntPatch_Line.SetValue = new_instancemethod(_IntPatch.IntPatch_Line_SetValue, None, IntPatch_Line)
IntPatch_Line.ArcType = new_instancemethod(_IntPatch.IntPatch_Line_ArcType, None, IntPatch_Line)
IntPatch_Line.IsTangent = new_instancemethod(_IntPatch.IntPatch_Line_IsTangent, None, IntPatch_Line)
IntPatch_Line.TransitionOnS1 = new_instancemethod(_IntPatch.IntPatch_Line_TransitionOnS1, None, IntPatch_Line)
IntPatch_Line.TransitionOnS2 = new_instancemethod(_IntPatch.IntPatch_Line_TransitionOnS2, None, IntPatch_Line)
IntPatch_Line.SituationS1 = new_instancemethod(_IntPatch.IntPatch_Line_SituationS1, None, IntPatch_Line)
IntPatch_Line.SituationS2 = new_instancemethod(_IntPatch.IntPatch_Line_SituationS2, None, IntPatch_Line)
IntPatch_Line.IsUIsoOnS1 = new_instancemethod(_IntPatch.IntPatch_Line_IsUIsoOnS1, None, IntPatch_Line)
IntPatch_Line.IsVIsoOnS1 = new_instancemethod(_IntPatch.IntPatch_Line_IsVIsoOnS1, None, IntPatch_Line)
IntPatch_Line.IsUIsoOnS2 = new_instancemethod(_IntPatch.IntPatch_Line_IsUIsoOnS2, None, IntPatch_Line)
IntPatch_Line.IsVIsoOnS2 = new_instancemethod(_IntPatch.IntPatch_Line_IsVIsoOnS2, None, IntPatch_Line)
IntPatch_Line_swigregister = _IntPatch.IntPatch_Line_swigregister
IntPatch_Line_swigregister(IntPatch_Line)

class Handle_IntPatch_Line(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_Line_swiginit(self, _IntPatch.new_Handle_IntPatch_Line(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_Line_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_Line
Handle_IntPatch_Line.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_Line_Nullify, None, Handle_IntPatch_Line)
Handle_IntPatch_Line.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_Line_IsNull, None, Handle_IntPatch_Line)
Handle_IntPatch_Line._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_Line__get_reference, None, Handle_IntPatch_Line)
Handle_IntPatch_Line_swigregister = _IntPatch.Handle_IntPatch_Line_swigregister
Handle_IntPatch_Line_swigregister(Handle_IntPatch_Line)

def Handle_IntPatch_Line_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_Line const":
    return _IntPatch.Handle_IntPatch_Line_DownCast(AnObject)
Handle_IntPatch_Line_DownCast = _IntPatch.Handle_IntPatch_Line_DownCast

class IntPatch_LineConstructor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param mode:
        :type mode: int
        :rtype: None

        """
        _IntPatch.IntPatch_LineConstructor_swiginit(self, _IntPatch.new_IntPatch_LineConstructor(*args))

    def Perform(self, *args) -> "void":
        """
        :param SL:
        :type SL: IntPatch_SequenceOfLine &
        :param L:
        :type L: Handle_IntPatch_Line &
        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param D1:
        :type D1: Handle_Adaptor3d_TopolTool &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param D2:
        :type D2: Handle_Adaptor3d_TopolTool &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _IntPatch.IntPatch_LineConstructor_Perform(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_LineConstructor_NbLines(self, *args)


    def Line(self, *args) -> "Handle_IntPatch_Line":
        """
        :param index:
        :type index: int
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_LineConstructor_Line(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_LineConstructor
IntPatch_LineConstructor.Perform = new_instancemethod(_IntPatch.IntPatch_LineConstructor_Perform, None, IntPatch_LineConstructor)
IntPatch_LineConstructor.NbLines = new_instancemethod(_IntPatch.IntPatch_LineConstructor_NbLines, None, IntPatch_LineConstructor)
IntPatch_LineConstructor.Line = new_instancemethod(_IntPatch.IntPatch_LineConstructor_Line, None, IntPatch_LineConstructor)
IntPatch_LineConstructor_swigregister = _IntPatch.IntPatch_LineConstructor_swigregister
IntPatch_LineConstructor_swigregister(IntPatch_LineConstructor)

class IntPatch_Point(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty constructor.

        :rtype: None

        """
        _IntPatch.IntPatch_Point_swiginit(self, _IntPatch.new_IntPatch_Point(*args))

    def SetValue(self, *args) -> "void":
        """
        * Sets the values of a point which is on no domain, when both surfaces are implicit ones. If Tangent is True, the point is a point of tangency between the surfaces.

        :param Pt:
        :type Pt: gp_Pnt
        :param Tol:
        :type Tol: float
        :param Tangent:
        :type Tangent: bool
        :rtype: None

        :param Pt:
        :type Pt: gp_Pnt
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_SetValue(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_SetTolerance(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        * Sets the values of the parameters of the point on each surface.

        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_SetParameters(self, *args)


    def SetParameter(self, *args) -> "void":
        """
        * Set the value of the parameter on the intersection line.

        :param Para:
        :type Para: float
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_SetParameter(self, *args)


    def SetVertex(self, *args) -> "void":
        """
        * Sets the values of a point which is a vertex on the initial facet of restriction of one of the surface. If OnFirst is True, the point is on the domain of the first patch, otherwise the point is on the domain of the second surface.

        :param OnFirst:
        :type OnFirst: bool
        :param V:
        :type V: Handle_Adaptor3d_HVertex &
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_SetVertex(self, *args)


    def SetArc(self, *args) -> "void":
        """
        * Sets the values of a point which is on one of the domain, when both surfaces are implicit ones. If OnFirst is True, the point is on the domain of the first patch, otherwise the point is on the domain of the second surface.

        :param OnFirst:
        :type OnFirst: bool
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :param Param:
        :type Param: float
        :param TLine:
        :type TLine: IntSurf_Transition &
        :param TArc:
        :type TArc: IntSurf_Transition &
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_SetArc(self, *args)


    def SetMultiple(self, *args) -> "void":
        """
        * Sets (or unsets) the point as a point on several intersection line.

        :param IsMult:
        :type IsMult: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_SetMultiple(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        * Returns the intersection point (geometric information).

        :rtype: gp_Pnt

        """
        return _IntPatch.IntPatch_Point_Value(self, *args)


    def ParameterOnLine(self, *args) -> "Standard_Real":
        """
        * This method returns the parameter of the point on the intersection line. If the points does not belong to an intersection line, the value returned does not have any sens.

        :rtype: float

        """
        return _IntPatch.IntPatch_Point_ParameterOnLine(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * This method returns the fuzziness on the point.

        :rtype: float

        """
        return _IntPatch.IntPatch_Point_Tolerance(self, *args)


    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the Point is a tangency point between the surfaces. If the Point is on one of the domain (IsOnDomS1 returns True or IsOnDomS2 returns True), an exception is raised.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Point_IsTangencyPoint(self, *args)


    def ParametersOnS1(self, *args) -> "void":
        """
        * Returns the parameters on the first surface of the point.

        :param U1:
        :type U1: float &
        :param V1:
        :type V1: float &
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args) -> "void":
        """
        * Returns the parameters on the second surface of the point.

        :param U2:
        :type U2: float &
        :param V2:
        :type V2: float &
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_ParametersOnS2(self, *args)


    def IsMultiple(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point belongs to several intersection lines.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Point_IsMultiple(self, *args)


    def IsOnDomS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point is on a boundary of the domain of the first patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Point_IsOnDomS1(self, *args)


    def IsVertexOnS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point is a vertex on the initial restriction facet of the first surface.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Point_IsVertexOnS1(self, *args)


    def VertexOnS1(self, *args) -> "Handle_Adaptor3d_HVertex":
        """
        * Returns the information about the point when it is on the domain of the first patch, i-e when the function IsVertexOnS1 returns True. Otherwise, an exception is raised.

        :rtype: Handle_Adaptor3d_HVertex

        """
        return _IntPatch.IntPatch_Point_VertexOnS1(self, *args)


    def ArcOnS1(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        * Returns the arc of restriction containing the vertex. The exception DomainError is raised if IsOnDomS1 returns False.

        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_Point_ArcOnS1(self, *args)


    def TransitionLineArc1(self, *args) -> "IntSurf_Transition const &":
        """
        * Returns the transition of the point on the intersection line with the arc on S1. The exception DomainError is raised if IsOnDomS1 returns False.

        :rtype: IntSurf_Transition

        """
        return _IntPatch.IntPatch_Point_TransitionLineArc1(self, *args)


    def TransitionOnS1(self, *args) -> "IntSurf_Transition const &":
        """
        * Returns the transition between the intersection line returned by the method Line and the arc on S1 returned by ArcOnS1(). The exception DomainError is raised if IsOnDomS1 returns False.

        :rtype: IntSurf_Transition

        """
        return _IntPatch.IntPatch_Point_TransitionOnS1(self, *args)


    def ParameterOnArc1(self, *args) -> "Standard_Real":
        """
        * Returns the parameter of the point on the arc returned by the method ArcOnS2. The exception DomainError is raised if IsOnDomS1 returns False.

        :rtype: float

        """
        return _IntPatch.IntPatch_Point_ParameterOnArc1(self, *args)


    def IsOnDomS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point is on a boundary of the domain of the second patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Point_IsOnDomS2(self, *args)


    def IsVertexOnS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point is a vertex on the initial restriction facet of the first surface.

        :rtype: bool

        """
        return _IntPatch.IntPatch_Point_IsVertexOnS2(self, *args)


    def VertexOnS2(self, *args) -> "Handle_Adaptor3d_HVertex":
        """
        * Returns the information about the point when it is on the domain of the second patch, i-e when the function IsVertexOnS2 returns True. Otherwise, an exception is raised.

        :rtype: Handle_Adaptor3d_HVertex

        """
        return _IntPatch.IntPatch_Point_VertexOnS2(self, *args)


    def ArcOnS2(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        * Returns the arc of restriction containing the vertex. The exception DomainError is raised if IsOnDomS2 returns False.

        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_Point_ArcOnS2(self, *args)


    def TransitionLineArc2(self, *args) -> "IntSurf_Transition const &":
        """
        * Returns the transition of the point on the intersection line with the arc on S2. The exception DomainError is raised if IsOnDomS2 returns False.

        :rtype: IntSurf_Transition

        """
        return _IntPatch.IntPatch_Point_TransitionLineArc2(self, *args)


    def TransitionOnS2(self, *args) -> "IntSurf_Transition const &":
        """
        * Returns the transition between the intersection line returned by the method Line and the arc on S2 returned by ArcOnS2. The exception DomainError is raised if IsOnDomS2 returns False.

        :rtype: IntSurf_Transition

        """
        return _IntPatch.IntPatch_Point_TransitionOnS2(self, *args)


    def ParameterOnArc2(self, *args) -> "Standard_Real":
        """
        * Returns the parameter of the point on the arc returned by the method ArcOnS2. The exception DomainError is raised if IsOnDomS2 returns False.

        :rtype: float

        """
        return _IntPatch.IntPatch_Point_ParameterOnArc2(self, *args)


    def PntOn2S(self, *args) -> "IntSurf_PntOn2S const &":
        """
        * Returns the PntOn2S (geometric Point and the parameters)

        :rtype: IntSurf_PntOn2S

        """
        return _IntPatch.IntPatch_Point_PntOn2S(self, *args)


    def Parameters(self, *args) -> "void":
        """
        * Returns the parameters on the first and on the second surface of the point.

        :param U1:
        :type U1: float &
        :param V1:
        :type V1: float &
        :param U2:
        :type U2: float &
        :param V2:
        :type V2: float &
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_Parameters(self, *args)


    def ReverseTransition(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_ReverseTransition(self, *args)


    def Dump(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_Point_Dump(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Point
IntPatch_Point.SetValue = new_instancemethod(_IntPatch.IntPatch_Point_SetValue, None, IntPatch_Point)
IntPatch_Point.SetTolerance = new_instancemethod(_IntPatch.IntPatch_Point_SetTolerance, None, IntPatch_Point)
IntPatch_Point.SetParameters = new_instancemethod(_IntPatch.IntPatch_Point_SetParameters, None, IntPatch_Point)
IntPatch_Point.SetParameter = new_instancemethod(_IntPatch.IntPatch_Point_SetParameter, None, IntPatch_Point)
IntPatch_Point.SetVertex = new_instancemethod(_IntPatch.IntPatch_Point_SetVertex, None, IntPatch_Point)
IntPatch_Point.SetArc = new_instancemethod(_IntPatch.IntPatch_Point_SetArc, None, IntPatch_Point)
IntPatch_Point.SetMultiple = new_instancemethod(_IntPatch.IntPatch_Point_SetMultiple, None, IntPatch_Point)
IntPatch_Point.Value = new_instancemethod(_IntPatch.IntPatch_Point_Value, None, IntPatch_Point)
IntPatch_Point.ParameterOnLine = new_instancemethod(_IntPatch.IntPatch_Point_ParameterOnLine, None, IntPatch_Point)
IntPatch_Point.Tolerance = new_instancemethod(_IntPatch.IntPatch_Point_Tolerance, None, IntPatch_Point)
IntPatch_Point.IsTangencyPoint = new_instancemethod(_IntPatch.IntPatch_Point_IsTangencyPoint, None, IntPatch_Point)
IntPatch_Point.ParametersOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_ParametersOnS1, None, IntPatch_Point)
IntPatch_Point.ParametersOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_ParametersOnS2, None, IntPatch_Point)
IntPatch_Point.IsMultiple = new_instancemethod(_IntPatch.IntPatch_Point_IsMultiple, None, IntPatch_Point)
IntPatch_Point.IsOnDomS1 = new_instancemethod(_IntPatch.IntPatch_Point_IsOnDomS1, None, IntPatch_Point)
IntPatch_Point.IsVertexOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_IsVertexOnS1, None, IntPatch_Point)
IntPatch_Point.VertexOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_VertexOnS1, None, IntPatch_Point)
IntPatch_Point.ArcOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_ArcOnS1, None, IntPatch_Point)
IntPatch_Point.TransitionLineArc1 = new_instancemethod(_IntPatch.IntPatch_Point_TransitionLineArc1, None, IntPatch_Point)
IntPatch_Point.TransitionOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_TransitionOnS1, None, IntPatch_Point)
IntPatch_Point.ParameterOnArc1 = new_instancemethod(_IntPatch.IntPatch_Point_ParameterOnArc1, None, IntPatch_Point)
IntPatch_Point.IsOnDomS2 = new_instancemethod(_IntPatch.IntPatch_Point_IsOnDomS2, None, IntPatch_Point)
IntPatch_Point.IsVertexOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_IsVertexOnS2, None, IntPatch_Point)
IntPatch_Point.VertexOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_VertexOnS2, None, IntPatch_Point)
IntPatch_Point.ArcOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_ArcOnS2, None, IntPatch_Point)
IntPatch_Point.TransitionLineArc2 = new_instancemethod(_IntPatch.IntPatch_Point_TransitionLineArc2, None, IntPatch_Point)
IntPatch_Point.TransitionOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_TransitionOnS2, None, IntPatch_Point)
IntPatch_Point.ParameterOnArc2 = new_instancemethod(_IntPatch.IntPatch_Point_ParameterOnArc2, None, IntPatch_Point)
IntPatch_Point.PntOn2S = new_instancemethod(_IntPatch.IntPatch_Point_PntOn2S, None, IntPatch_Point)
IntPatch_Point.Parameters = new_instancemethod(_IntPatch.IntPatch_Point_Parameters, None, IntPatch_Point)
IntPatch_Point.ReverseTransition = new_instancemethod(_IntPatch.IntPatch_Point_ReverseTransition, None, IntPatch_Point)
IntPatch_Point.Dump = new_instancemethod(_IntPatch.IntPatch_Point_Dump, None, IntPatch_Point)
IntPatch_Point_swigregister = _IntPatch.IntPatch_Point_swigregister
IntPatch_Point_swigregister(IntPatch_Point)

class IntPatch_Polygo(OCC.Intf.Intf_Polygon2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Error(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_Polygo_Error(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_Polygo_NbPoints(self, *args)


    def Point(self, *args) -> "gp_Pnt2d":
        """
        :param Index:
        :type Index: int
        :rtype: gp_Pnt2d

        """
        return _IntPatch.IntPatch_Polygo_Point(self, *args)


    def Dump(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_Polygo_Dump(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Polygo
IntPatch_Polygo.Error = new_instancemethod(_IntPatch.IntPatch_Polygo_Error, None, IntPatch_Polygo)
IntPatch_Polygo.NbPoints = new_instancemethod(_IntPatch.IntPatch_Polygo_NbPoints, None, IntPatch_Polygo)
IntPatch_Polygo.Point = new_instancemethod(_IntPatch.IntPatch_Polygo_Point, None, IntPatch_Polygo)
IntPatch_Polygo.Dump = new_instancemethod(_IntPatch.IntPatch_Polygo_Dump, None, IntPatch_Polygo)
IntPatch_Polygo_swigregister = _IntPatch.IntPatch_Polygo_swigregister
IntPatch_Polygo_swigregister(IntPatch_Polygo)

class IntPatch_PrmPrmIntersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty Constructor

        :rtype: None

        """
        _IntPatch.IntPatch_PrmPrmIntersection_swiginit(self, _IntPatch.new_IntPatch_PrmPrmIntersection(*args))

    def Perform(self, *args) -> "void":
        """
        * Performs the intersection between <Caro1> and <Caro2>. Associated Polyhedrons <Polyhedron1> and <Polyhedron2> are given.

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Polyhedron1:
        :type Polyhedron1: IntPatch_Polyhedron &
        :param Domain1:
        :type Domain1: Handle_Adaptor3d_TopolTool &
        :param Caro2:
        :type Caro2: Handle_Adaptor3d_HSurface &
        :param Polyhedron2:
        :type Polyhedron2: IntPatch_Polyhedron &
        :param Domain2:
        :type Domain2: Handle_Adaptor3d_TopolTool &
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :rtype: None

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Polyhedron1:
        :type Polyhedron1: IntPatch_Polyhedron &
        :param Domain1:
        :type Domain1: Handle_Adaptor3d_TopolTool &
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :rtype: None

        * Performs the intersection between <Caro1> and <Caro2>. The method computes the polyhedron on each surface.

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Domain1:
        :type Domain1: Handle_Adaptor3d_TopolTool &
        :param Caro2:
        :type Caro2: Handle_Adaptor3d_HSurface &
        :param Domain2:
        :type Domain2: Handle_Adaptor3d_TopolTool &
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :param ClearFlag: default value is Standard_True
        :type ClearFlag: bool
        :rtype: None

        * Performs the intersection between <Caro1> and <Caro2>. The method computes the polyhedron on each surface.

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Domain1:
        :type Domain1: Handle_Adaptor3d_TopolTool &
        :param Caro2:
        :type Caro2: Handle_Adaptor3d_HSurface &
        :param Domain2:
        :type Domain2: Handle_Adaptor3d_TopolTool &
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :param ListOfPnts:
        :type ListOfPnts: IntSurf_ListOfPntOn2S &
        :param RestrictLine:
        :type RestrictLine: bool
        :rtype: None

        * Performs the intersection between <Caro1> and <Caro2>. The method computes the polyhedron on each surface.

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Domain1:
        :type Domain1: Handle_Adaptor3d_TopolTool &
        :param Caro2:
        :type Caro2: Handle_Adaptor3d_HSurface &
        :param Domain2:
        :type Domain2: Handle_Adaptor3d_TopolTool &
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :rtype: None

        * Performs the intersection between <Caro1> and <Caro2>. The method computes the polyhedron on each surface.

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Domain1:
        :type Domain1: Handle_Adaptor3d_TopolTool &
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :rtype: None

        * Performs the intersection between <Caro1> and <Caro2>. //! The polyhedron which approximates <Caro2>, <Polyhedron2> is given. The other one is computed.

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Domain1:
        :type Domain1: Handle_Adaptor3d_TopolTool &
        :param Caro2:
        :type Caro2: Handle_Adaptor3d_HSurface &
        :param Polyhedron2:
        :type Polyhedron2: IntPatch_Polyhedron &
        :param Domain2:
        :type Domain2: Handle_Adaptor3d_TopolTool &
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :rtype: None

        * Performs the intersection between <Caro1> and <Caro2>. //! The polyhedron which approximates <Caro1>, <Polyhedron1> is given. The other one is computed.

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Polyhedron1:
        :type Polyhedron1: IntPatch_Polyhedron &
        :param Domain1:
        :type Domain1: Handle_Adaptor3d_TopolTool &
        :param Caro2:
        :type Caro2: Handle_Adaptor3d_HSurface &
        :param Domain2:
        :type Domain2: Handle_Adaptor3d_TopolTool &
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Perform(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the calculus was succesfull.

        :rtype: bool

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the is no intersection.

        :rtype: bool

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IsEmpty(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection lines.

        :rtype: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NbLines(self, *args)


    def Line(self, *args) -> "Handle_IntPatch_Line":
        """
        * Returns the line of range Index. An exception is raised if Index<=0 or Index>NbLine.

        :param Index:
        :type Index: int
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Line(self, *args)


    def NewLine(self, *args) -> "Handle_IntPatch_Line":
        """
        * Computes about <NbPoints> Intersection Points on the Line <IndexLine> between the Points of Index <LowPoint> and <HighPoint>. //! All the points of the line of index <IndexLine> with an index between <LowPoint> and <HighPoint> are in the returned line. New Points are inserted between existing points if those points are not too closed. //! An exception is raised if Index<=0 or Index>NbLine. or if IsDone returns False

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Caro2:
        :type Caro2: Handle_Adaptor3d_HSurface &
        :param IndexLine:
        :type IndexLine: int
        :param LowPoint:
        :type LowPoint: int
        :param HighPoint:
        :type HighPoint: int
        :param NbPoints:
        :type NbPoints: int
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NewLine(self, *args)


    def GrilleInteger(self, *args) -> "Standard_Integer":
        """
        :param ix:
        :type ix: int
        :param iy:
        :type iy: int
        :param iz:
        :type iz: int
        :rtype: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_GrilleInteger(self, *args)


    def IntegerGrille(self, *args) -> "void":
        """
        :param t:
        :type t: int
        :param ix:
        :type ix: int &
        :param iy:
        :type iy: int &
        :param iz:
        :type iz: int &
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IntegerGrille(self, *args)


    def DansGrille(self, *args) -> "Standard_Integer":
        """
        :param t:
        :type t: int
        :rtype: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_DansGrille(self, *args)


    def NbPointsGrille(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NbPointsGrille(self, *args)


    def RemplitLin(self, *args) -> "void":
        """
        :param x1:
        :type x1: int
        :param y1:
        :type y1: int
        :param z1:
        :type z1: int
        :param x2:
        :type x2: int
        :param y2:
        :type y2: int
        :param z2:
        :type z2: int
        :param Map:
        :type Map: IntPatch_PrmPrmIntersection_T3Bits &
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_RemplitLin(self, *args)


    def RemplitTri(self, *args) -> "void":
        """
        :param x1:
        :type x1: int
        :param y1:
        :type y1: int
        :param z1:
        :type z1: int
        :param x2:
        :type x2: int
        :param y2:
        :type y2: int
        :param z2:
        :type z2: int
        :param x3:
        :type x3: int
        :param y3:
        :type y3: int
        :param z3:
        :type z3: int
        :param Map:
        :type Map: IntPatch_PrmPrmIntersection_T3Bits &
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_RemplitTri(self, *args)


    def Remplit(self, *args) -> "void":
        """
        :param a:
        :type a: int
        :param b:
        :type b: int
        :param c:
        :type c: int
        :param Map:
        :type Map: IntPatch_PrmPrmIntersection_T3Bits &
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Remplit(self, *args)


    def CodeReject(self, *args) -> "Standard_Integer":
        """
        :param x1:
        :type x1: float
        :param y1:
        :type y1: float
        :param z1:
        :type z1: float
        :param x2:
        :type x2: float
        :param y2:
        :type y2: float
        :param z2:
        :type z2: float
        :param x3:
        :type x3: float
        :param y3:
        :type y3: float
        :param z3:
        :type z3: float
        :rtype: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_CodeReject(self, *args)


    def PointDepart(self, *args) -> "void":
        """
        :param LineOn2S:
        :type LineOn2S: Handle_IntSurf_LineOn2S &
        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param SU1:
        :type SU1: int
        :param SV1:
        :type SV1: int
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param SU2:
        :type SU2: int
        :param SV2:
        :type SV2: int
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_PointDepart(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PrmPrmIntersection
IntPatch_PrmPrmIntersection.Perform = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_Perform, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.IsDone = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_IsDone, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.IsEmpty = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_IsEmpty, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.NbLines = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_NbLines, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.Line = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_Line, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.NewLine = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_NewLine, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.GrilleInteger = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_GrilleInteger, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.IntegerGrille = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_IntegerGrille, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.DansGrille = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_DansGrille, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.NbPointsGrille = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_NbPointsGrille, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.RemplitLin = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_RemplitLin, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.RemplitTri = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_RemplitTri, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.Remplit = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_Remplit, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.CodeReject = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_CodeReject, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.PointDepart = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_PointDepart, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection_swigregister = _IntPatch.IntPatch_PrmPrmIntersection_swigregister
IntPatch_PrmPrmIntersection_swigregister(IntPatch_PrmPrmIntersection)

class IntPatch_PrmPrmIntersection_T3Bits(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param size:
        :type size: int
        :rtype: None

        """
        _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_swiginit(self, _IntPatch.new_IntPatch_PrmPrmIntersection_T3Bits(*args))

    def Destroy(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Destroy(self, *args)


    def Add(self, *args) -> "void":
        """
        :param t:
        :type t: int
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Add(self, *args)


    def Val(self, *args) -> "Standard_Integer":
        """
        :param t:
        :type t: int
        :rtype: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Val(self, *args)


    def Raz(self, *args) -> "void":
        """
        :param t:
        :type t: int
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Raz(self, *args)


    def ResetAnd(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_ResetAnd(self, *args)


    def And(self, *args) -> "Standard_Integer":
        """
        :param Oth:
        :type Oth: IntPatch_PrmPrmIntersection_T3Bits &
        :param indiceprecedent:
        :type indiceprecedent: int &
        :rtype: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_And(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PrmPrmIntersection_T3Bits
IntPatch_PrmPrmIntersection_T3Bits.Destroy = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Destroy, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.Add = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Add, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.Val = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Val, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.Raz = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Raz, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.ResetAnd = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_ResetAnd, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.And = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_And, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits_swigregister = _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_swigregister
IntPatch_PrmPrmIntersection_T3Bits_swigregister(IntPatch_PrmPrmIntersection_T3Bits)

class IntPatch_RstInt(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def PutVertexOnLine(*args) -> "void":
        """
        :param L:
        :type L: Handle_IntPatch_Line &
        :param Surf:
        :type Surf: Handle_Adaptor3d_HSurface &
        :param Domain:
        :type Domain: Handle_Adaptor3d_TopolTool &
        :param OtherSurf:
        :type OtherSurf: Handle_Adaptor3d_HSurface &
        :param OnFirst:
        :type OnFirst: bool
        :param Tol:
        :type Tol: float
        :param hasBeenAdded: default value is Standard_False
        :type hasBeenAdded: bool
        :rtype: void

        """
        return _IntPatch.IntPatch_RstInt_PutVertexOnLine(*args)

    PutVertexOnLine = staticmethod(PutVertexOnLine)

    __repr__ = _dumps_object


    def __init__(self):
        _IntPatch.IntPatch_RstInt_swiginit(self, _IntPatch.new_IntPatch_RstInt())
    __swig_destroy__ = _IntPatch.delete_IntPatch_RstInt
IntPatch_RstInt_swigregister = _IntPatch.IntPatch_RstInt_swigregister
IntPatch_RstInt_swigregister(IntPatch_RstInt)

def IntPatch_RstInt_PutVertexOnLine(*args) -> "void":
    """
    :param L:
    :type L: Handle_IntPatch_Line &
    :param Surf:
    :type Surf: Handle_Adaptor3d_HSurface &
    :param Domain:
    :type Domain: Handle_Adaptor3d_TopolTool &
    :param OtherSurf:
    :type OtherSurf: Handle_Adaptor3d_HSurface &
    :param OnFirst:
    :type OnFirst: bool
    :param Tol:
    :type Tol: float
    :param hasBeenAdded: default value is Standard_False
    :type hasBeenAdded: bool
    :rtype: void

    """
    return _IntPatch.IntPatch_RstInt_PutVertexOnLine(*args)

class IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: Handle_IntPatch_TheIWLineOfTheIWalking &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_swiginit(self, _IntPatch.new_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking(*args))

    def Value(self, *args) -> "Handle_IntPatch_TheIWLineOfTheIWalking":
        """
        :rtype: Handle_IntPatch_TheIWLineOfTheIWalking

        """
        return _IntPatch.IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking
IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking.Value = new_instancemethod(_IntPatch.IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_Value, None, IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking)
IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_swigregister = _IntPatch.IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_swigregister
IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_swigregister(IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking)

class Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_swiginit(self, _IntPatch.new_Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking
Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_Nullify, None, Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking)
Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_IsNull, None, Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking)
Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking__get_reference, None, Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking)
Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_swigregister = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_swigregister
Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_swigregister(Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking)

def Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking const":
    return _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_DownCast(AnObject)
Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_DownCast = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfIWLineOfTheIWalking_DownCast

class IntPatch_SequenceNodeOfSequenceOfLine(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: Handle_IntPatch_Line &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceNodeOfSequenceOfLine_swiginit(self, _IntPatch.new_IntPatch_SequenceNodeOfSequenceOfLine(*args))

    def Value(self, *args) -> "Handle_IntPatch_Line":
        """
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_SequenceNodeOfSequenceOfLine_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_SequenceNodeOfSequenceOfLine(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceNodeOfSequenceOfLine
IntPatch_SequenceNodeOfSequenceOfLine.Value = new_instancemethod(_IntPatch.IntPatch_SequenceNodeOfSequenceOfLine_Value, None, IntPatch_SequenceNodeOfSequenceOfLine)
IntPatch_SequenceNodeOfSequenceOfLine_swigregister = _IntPatch.IntPatch_SequenceNodeOfSequenceOfLine_swigregister
IntPatch_SequenceNodeOfSequenceOfLine_swigregister(IntPatch_SequenceNodeOfSequenceOfLine)

class Handle_IntPatch_SequenceNodeOfSequenceOfLine(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfLine_swiginit(self, _IntPatch.new_Handle_IntPatch_SequenceNodeOfSequenceOfLine(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfLine_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_SequenceNodeOfSequenceOfLine
Handle_IntPatch_SequenceNodeOfSequenceOfLine.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfLine_Nullify, None, Handle_IntPatch_SequenceNodeOfSequenceOfLine)
Handle_IntPatch_SequenceNodeOfSequenceOfLine.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfLine_IsNull, None, Handle_IntPatch_SequenceNodeOfSequenceOfLine)
Handle_IntPatch_SequenceNodeOfSequenceOfLine._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfLine__get_reference, None, Handle_IntPatch_SequenceNodeOfSequenceOfLine)
Handle_IntPatch_SequenceNodeOfSequenceOfLine_swigregister = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfLine_swigregister
Handle_IntPatch_SequenceNodeOfSequenceOfLine_swigregister(Handle_IntPatch_SequenceNodeOfSequenceOfLine)

def Handle_IntPatch_SequenceNodeOfSequenceOfLine_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_SequenceNodeOfSequenceOfLine const":
    return _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfLine_DownCast(AnObject)
Handle_IntPatch_SequenceNodeOfSequenceOfLine_DownCast = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfLine_DownCast

class IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: IntPatch_ThePathPointOfTheSOnBounds &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds(*args))

    def Value(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds &":
        """
        :rtype: IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds
IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds.Value = new_instancemethod(_IntPatch.IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_Value, None, IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_swigregister = _IntPatch.IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_swigregister
IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_swigregister(IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds)

class Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_swiginit(self, _IntPatch.new_Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds
Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_Nullify, None, Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds)
Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_IsNull, None, Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds)
Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds__get_reference, None, Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds)
Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_swigregister = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_swigregister
Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_swigregister(Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds)

def Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds const":
    return _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_DownCast(AnObject)
Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_DownCast = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPathPointOfTheSOnBounds_DownCast

class IntPatch_SequenceNodeOfSequenceOfPoint(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: IntPatch_Point &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceNodeOfSequenceOfPoint_swiginit(self, _IntPatch.new_IntPatch_SequenceNodeOfSequenceOfPoint(*args))

    def Value(self, *args) -> "IntPatch_Point &":
        """
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_SequenceNodeOfSequenceOfPoint_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_SequenceNodeOfSequenceOfPoint(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceNodeOfSequenceOfPoint
IntPatch_SequenceNodeOfSequenceOfPoint.Value = new_instancemethod(_IntPatch.IntPatch_SequenceNodeOfSequenceOfPoint_Value, None, IntPatch_SequenceNodeOfSequenceOfPoint)
IntPatch_SequenceNodeOfSequenceOfPoint_swigregister = _IntPatch.IntPatch_SequenceNodeOfSequenceOfPoint_swigregister
IntPatch_SequenceNodeOfSequenceOfPoint_swigregister(IntPatch_SequenceNodeOfSequenceOfPoint)

class Handle_IntPatch_SequenceNodeOfSequenceOfPoint(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPoint_swiginit(self, _IntPatch.new_Handle_IntPatch_SequenceNodeOfSequenceOfPoint(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPoint_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_SequenceNodeOfSequenceOfPoint
Handle_IntPatch_SequenceNodeOfSequenceOfPoint.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPoint_Nullify, None, Handle_IntPatch_SequenceNodeOfSequenceOfPoint)
Handle_IntPatch_SequenceNodeOfSequenceOfPoint.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPoint_IsNull, None, Handle_IntPatch_SequenceNodeOfSequenceOfPoint)
Handle_IntPatch_SequenceNodeOfSequenceOfPoint._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPoint__get_reference, None, Handle_IntPatch_SequenceNodeOfSequenceOfPoint)
Handle_IntPatch_SequenceNodeOfSequenceOfPoint_swigregister = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPoint_swigregister
Handle_IntPatch_SequenceNodeOfSequenceOfPoint_swigregister(Handle_IntPatch_SequenceNodeOfSequenceOfPoint)

def Handle_IntPatch_SequenceNodeOfSequenceOfPoint_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_SequenceNodeOfSequenceOfPoint const":
    return _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPoint_DownCast(AnObject)
Handle_IntPatch_SequenceNodeOfSequenceOfPoint_DownCast = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfPoint_DownCast

class IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: IntPatch_TheSegmentOfTheSOnBounds &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds(*args))

    def Value(self, *args) -> "IntPatch_TheSegmentOfTheSOnBounds &":
        """
        :rtype: IntPatch_TheSegmentOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds
IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds.Value = new_instancemethod(_IntPatch.IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_Value, None, IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_swigregister = _IntPatch.IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_swigregister
IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_swigregister(IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds)

class Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_swiginit(self, _IntPatch.new_Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds
Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_Nullify, None, Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds)
Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_IsNull, None, Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds)
Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds__get_reference, None, Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds)
Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_swigregister = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_swigregister
Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_swigregister(Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds)

def Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds const":
    return _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_DownCast(AnObject)
Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_DownCast = _IntPatch.Handle_IntPatch_SequenceNodeOfSequenceOfSegmentOfTheSOnBounds_DownCast

class IntPatch_SequenceOfIWLineOfTheIWalking(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Other:
        :type Other: IntPatch_SequenceOfIWLineOfTheIWalking &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_swiginit(self, _IntPatch.new_IntPatch_SequenceOfIWLineOfTheIWalking(*args))

    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Clear(self, *args)


    def Assign(self, *args) -> "IntPatch_SequenceOfIWLineOfTheIWalking const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfIWLineOfTheIWalking &
        :rtype: IntPatch_SequenceOfIWLineOfTheIWalking

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Assign(self, *args)


    def Set(self, *args) -> "IntPatch_SequenceOfIWLineOfTheIWalking const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfIWLineOfTheIWalking &
        :rtype: IntPatch_SequenceOfIWLineOfTheIWalking

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Set(self, *args)


    def Append(self, *args) -> "void":
        """
        :param T:
        :type T: Handle_IntPatch_TheIWLineOfTheIWalking &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfIWLineOfTheIWalking &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Append(self, *args)


    def Prepend(self, *args) -> "void":
        """
        :param T:
        :type T: Handle_IntPatch_TheIWLineOfTheIWalking &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfIWLineOfTheIWalking &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Prepend(self, *args)


    def InsertBefore(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_IntPatch_TheIWLineOfTheIWalking &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfIWLineOfTheIWalking &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_InsertBefore(self, *args)


    def InsertAfter(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_IntPatch_TheIWLineOfTheIWalking &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfIWLineOfTheIWalking &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_InsertAfter(self, *args)


    def First(self, *args) -> "Handle_IntPatch_TheIWLineOfTheIWalking":
        """
        :rtype: Handle_IntPatch_TheIWLineOfTheIWalking

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_First(self, *args)


    def Last(self, *args) -> "Handle_IntPatch_TheIWLineOfTheIWalking":
        """
        :rtype: Handle_IntPatch_TheIWLineOfTheIWalking

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Last(self, *args)


    def Split(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: IntPatch_SequenceOfIWLineOfTheIWalking &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Split(self, *args)


    def Value(self, *args) -> "Handle_IntPatch_TheIWLineOfTheIWalking":
        """
        :param Index:
        :type Index: int
        :rtype: Handle_IntPatch_TheIWLineOfTheIWalking

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Value(self, *args)


    def SetValue(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_IntPatch_TheIWLineOfTheIWalking &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_SetValue(self, *args)


    def ChangeValue(self, *args) -> "Handle_IntPatch_TheIWLineOfTheIWalking":
        """
        :param Index:
        :type Index: int
        :rtype: Handle_IntPatch_TheIWLineOfTheIWalking

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_ChangeValue(self, *args)


    def Remove(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Remove(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfIWLineOfTheIWalking
IntPatch_SequenceOfIWLineOfTheIWalking.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Clear, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Assign, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Set, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Append, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Prepend, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_InsertBefore, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_InsertAfter, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_First, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Last, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Split, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Value, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_SetValue, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_ChangeValue, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Remove, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking_swigregister = _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_swigregister
IntPatch_SequenceOfIWLineOfTheIWalking_swigregister(IntPatch_SequenceOfIWLineOfTheIWalking)

class IntPatch_SequenceOfLine(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Other:
        :type Other: IntPatch_SequenceOfLine &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceOfLine_swiginit(self, _IntPatch.new_IntPatch_SequenceOfLine(*args))

    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfLine_Clear(self, *args)


    def Assign(self, *args) -> "IntPatch_SequenceOfLine const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfLine &
        :rtype: IntPatch_SequenceOfLine

        """
        return _IntPatch.IntPatch_SequenceOfLine_Assign(self, *args)


    def Set(self, *args) -> "IntPatch_SequenceOfLine const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfLine &
        :rtype: IntPatch_SequenceOfLine

        """
        return _IntPatch.IntPatch_SequenceOfLine_Set(self, *args)


    def Append(self, *args) -> "void":
        """
        :param T:
        :type T: Handle_IntPatch_Line &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfLine &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfLine_Append(self, *args)


    def Prepend(self, *args) -> "void":
        """
        :param T:
        :type T: Handle_IntPatch_Line &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfLine &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfLine_Prepend(self, *args)


    def InsertBefore(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_IntPatch_Line &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfLine &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfLine_InsertBefore(self, *args)


    def InsertAfter(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_IntPatch_Line &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfLine &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfLine_InsertAfter(self, *args)


    def First(self, *args) -> "Handle_IntPatch_Line":
        """
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_SequenceOfLine_First(self, *args)


    def Last(self, *args) -> "Handle_IntPatch_Line":
        """
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_SequenceOfLine_Last(self, *args)


    def Split(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: IntPatch_SequenceOfLine &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfLine_Split(self, *args)


    def Value(self, *args) -> "Handle_IntPatch_Line":
        """
        :param Index:
        :type Index: int
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_SequenceOfLine_Value(self, *args)


    def SetValue(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_IntPatch_Line &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfLine_SetValue(self, *args)


    def ChangeValue(self, *args) -> "Handle_IntPatch_Line":
        """
        :param Index:
        :type Index: int
        :rtype: Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_SequenceOfLine_ChangeValue(self, *args)


    def Remove(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfLine_Remove(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfLine
IntPatch_SequenceOfLine.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Clear, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Assign, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Set, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Append, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Prepend, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_InsertBefore, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_InsertAfter, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_First, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Last, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Split, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Value, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_SetValue, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_ChangeValue, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Remove, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine_swigregister = _IntPatch.IntPatch_SequenceOfLine_swigregister
IntPatch_SequenceOfLine_swigregister(IntPatch_SequenceOfLine)

class IntPatch_SequenceOfPathPointOfTheSOnBounds(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Other:
        :type Other: IntPatch_SequenceOfPathPointOfTheSOnBounds &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_SequenceOfPathPointOfTheSOnBounds(*args))

    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Clear(self, *args)


    def Assign(self, *args) -> "IntPatch_SequenceOfPathPointOfTheSOnBounds const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfPathPointOfTheSOnBounds &
        :rtype: IntPatch_SequenceOfPathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Assign(self, *args)


    def Set(self, *args) -> "IntPatch_SequenceOfPathPointOfTheSOnBounds const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfPathPointOfTheSOnBounds &
        :rtype: IntPatch_SequenceOfPathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Set(self, *args)


    def Append(self, *args) -> "void":
        """
        :param T:
        :type T: IntPatch_ThePathPointOfTheSOnBounds &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfPathPointOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Append(self, *args)


    def Prepend(self, *args) -> "void":
        """
        :param T:
        :type T: IntPatch_ThePathPointOfTheSOnBounds &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfPathPointOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Prepend(self, *args)


    def InsertBefore(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: IntPatch_ThePathPointOfTheSOnBounds &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfPathPointOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_InsertBefore(self, *args)


    def InsertAfter(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: IntPatch_ThePathPointOfTheSOnBounds &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfPathPointOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_InsertAfter(self, *args)


    def First(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        :rtype: IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_First(self, *args)


    def Last(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        :rtype: IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Last(self, *args)


    def Split(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: IntPatch_SequenceOfPathPointOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Split(self, *args)


    def Value(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        :param Index:
        :type Index: int
        :rtype: IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Value(self, *args)


    def SetValue(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: IntPatch_ThePathPointOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_SetValue(self, *args)


    def ChangeValue(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds &":
        """
        :param Index:
        :type Index: int
        :rtype: IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_ChangeValue(self, *args)


    def Remove(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Remove(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfPathPointOfTheSOnBounds
IntPatch_SequenceOfPathPointOfTheSOnBounds.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Clear, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Assign, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Set, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Append, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Prepend, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_InsertBefore, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_InsertAfter, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_First, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Last, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Split, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Value, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_SetValue, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_ChangeValue, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Remove, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds_swigregister = _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_swigregister
IntPatch_SequenceOfPathPointOfTheSOnBounds_swigregister(IntPatch_SequenceOfPathPointOfTheSOnBounds)

class IntPatch_SequenceOfPoint(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Other:
        :type Other: IntPatch_SequenceOfPoint &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceOfPoint_swiginit(self, _IntPatch.new_IntPatch_SequenceOfPoint(*args))

    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPoint_Clear(self, *args)


    def Assign(self, *args) -> "IntPatch_SequenceOfPoint const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfPoint &
        :rtype: IntPatch_SequenceOfPoint

        """
        return _IntPatch.IntPatch_SequenceOfPoint_Assign(self, *args)


    def Set(self, *args) -> "IntPatch_SequenceOfPoint const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfPoint &
        :rtype: IntPatch_SequenceOfPoint

        """
        return _IntPatch.IntPatch_SequenceOfPoint_Set(self, *args)


    def Append(self, *args) -> "void":
        """
        :param T:
        :type T: IntPatch_Point &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfPoint &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPoint_Append(self, *args)


    def Prepend(self, *args) -> "void":
        """
        :param T:
        :type T: IntPatch_Point &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfPoint &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPoint_Prepend(self, *args)


    def InsertBefore(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: IntPatch_Point &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfPoint &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPoint_InsertBefore(self, *args)


    def InsertAfter(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: IntPatch_Point &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfPoint &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPoint_InsertAfter(self, *args)


    def First(self, *args) -> "IntPatch_Point const &":
        """
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_SequenceOfPoint_First(self, *args)


    def Last(self, *args) -> "IntPatch_Point const &":
        """
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_SequenceOfPoint_Last(self, *args)


    def Split(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: IntPatch_SequenceOfPoint &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPoint_Split(self, *args)


    def Value(self, *args) -> "IntPatch_Point const &":
        """
        :param Index:
        :type Index: int
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_SequenceOfPoint_Value(self, *args)


    def SetValue(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPoint_SetValue(self, *args)


    def ChangeValue(self, *args) -> "IntPatch_Point &":
        """
        :param Index:
        :type Index: int
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_SequenceOfPoint_ChangeValue(self, *args)


    def Remove(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfPoint_Remove(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfPoint
IntPatch_SequenceOfPoint.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Clear, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Assign, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Set, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Append, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Prepend, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_InsertBefore, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_InsertAfter, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_First, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Last, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Split, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Value, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_SetValue, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_ChangeValue, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Remove, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint_swigregister = _IntPatch.IntPatch_SequenceOfPoint_swigregister
IntPatch_SequenceOfPoint_swigregister(IntPatch_SequenceOfPoint)

class IntPatch_SequenceOfSegmentOfTheSOnBounds(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Other:
        :type Other: IntPatch_SequenceOfSegmentOfTheSOnBounds &
        :rtype: None

        """
        _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_SequenceOfSegmentOfTheSOnBounds(*args))

    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Clear(self, *args)


    def Assign(self, *args) -> "IntPatch_SequenceOfSegmentOfTheSOnBounds const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfSegmentOfTheSOnBounds &
        :rtype: IntPatch_SequenceOfSegmentOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Assign(self, *args)


    def Set(self, *args) -> "IntPatch_SequenceOfSegmentOfTheSOnBounds const &":
        """
        :param Other:
        :type Other: IntPatch_SequenceOfSegmentOfTheSOnBounds &
        :rtype: IntPatch_SequenceOfSegmentOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Set(self, *args)


    def Append(self, *args) -> "void":
        """
        :param T:
        :type T: IntPatch_TheSegmentOfTheSOnBounds &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfSegmentOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Append(self, *args)


    def Prepend(self, *args) -> "void":
        """
        :param T:
        :type T: IntPatch_TheSegmentOfTheSOnBounds &
        :rtype: None

        :param S:
        :type S: IntPatch_SequenceOfSegmentOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Prepend(self, *args)


    def InsertBefore(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: IntPatch_TheSegmentOfTheSOnBounds &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfSegmentOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_InsertBefore(self, *args)


    def InsertAfter(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: IntPatch_TheSegmentOfTheSOnBounds &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: IntPatch_SequenceOfSegmentOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_InsertAfter(self, *args)


    def First(self, *args) -> "IntPatch_TheSegmentOfTheSOnBounds const &":
        """
        :rtype: IntPatch_TheSegmentOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_First(self, *args)


    def Last(self, *args) -> "IntPatch_TheSegmentOfTheSOnBounds const &":
        """
        :rtype: IntPatch_TheSegmentOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Last(self, *args)


    def Split(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: IntPatch_SequenceOfSegmentOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Split(self, *args)


    def Value(self, *args) -> "IntPatch_TheSegmentOfTheSOnBounds const &":
        """
        :param Index:
        :type Index: int
        :rtype: IntPatch_TheSegmentOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Value(self, *args)


    def SetValue(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: IntPatch_TheSegmentOfTheSOnBounds &
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_SetValue(self, *args)


    def ChangeValue(self, *args) -> "IntPatch_TheSegmentOfTheSOnBounds &":
        """
        :param Index:
        :type Index: int
        :rtype: IntPatch_TheSegmentOfTheSOnBounds

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_ChangeValue(self, *args)


    def Remove(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Remove(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfSegmentOfTheSOnBounds
IntPatch_SequenceOfSegmentOfTheSOnBounds.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Clear, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Assign, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Set, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Append, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Prepend, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_InsertBefore, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_InsertAfter, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_First, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Last, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Split, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Value, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_SetValue, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_ChangeValue, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Remove, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds_swigregister = _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_swigregister
IntPatch_SequenceOfSegmentOfTheSOnBounds_swigregister(IntPatch_SequenceOfSegmentOfTheSOnBounds)

class IntPatch_TheIWLineOfTheIWalking(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param theAllocator: default value is 0
        :type theAllocator: IntSurf_Allocator &
        :rtype: None

        """
        _IntPatch.IntPatch_TheIWLineOfTheIWalking_swiginit(self, _IntPatch.new_IntPatch_TheIWLineOfTheIWalking(*args))

    def Reverse(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Reverse(self, *args)


    def Cut(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Cut(self, *args)


    def AddPoint(self, *args) -> "void":
        """
        :param P:
        :type P: IntSurf_PntOn2S &
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddPoint(self, *args)


    def AddStatusFirst(self, *args) -> "void":
        """
        :param Closed:
        :type Closed: bool
        :param HasFirst:
        :type HasFirst: bool
        :rtype: None

        :param Closed:
        :type Closed: bool
        :param HasLast:
        :type HasLast: bool
        :param Index:
        :type Index: int
        :param P:
        :type P: IntSurf_PathPoint &
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirst(self, *args)


    def AddStatusFirstLast(self, *args) -> "void":
        """
        :param Closed:
        :type Closed: bool
        :param HasFirst:
        :type HasFirst: bool
        :param HasLast:
        :type HasLast: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirstLast(self, *args)


    def AddStatusLast(self, *args) -> "void":
        """
        :param HasLast:
        :type HasLast: bool
        :rtype: None

        :param HasLast:
        :type HasLast: bool
        :param Index:
        :type Index: int
        :param P:
        :type P: IntSurf_PathPoint &
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusLast(self, *args)


    def AddIndexPassing(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddIndexPassing(self, *args)


    def SetTangentVector(self, *args) -> "void":
        """
        :param V:
        :type V: gp_Vec
        :param Index:
        :type Index: int
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangentVector(self, *args)


    def SetTangencyAtBegining(self, *args) -> "void":
        """
        :param IsTangent:
        :type IsTangent: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtBegining(self, *args)


    def SetTangencyAtEnd(self, *args) -> "void":
        """
        :param IsTangent:
        :type IsTangent: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtEnd(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPoints(self, *args)


    def Value(self, *args) -> "IntSurf_PntOn2S const &":
        """
        :param Index:
        :type Index: int
        :rtype: IntSurf_PntOn2S

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Value(self, *args)


    def Line(self, *args) -> "Handle_IntSurf_LineOn2S":
        """
        :rtype: Handle_IntSurf_LineOn2S

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Line(self, *args)


    def IsClosed(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsClosed(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_HasLastPoint(self, *args)


    def FirstPoint(self, *args) -> "IntSurf_PathPoint const &":
        """
        :rtype: IntSurf_PathPoint

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPoint(self, *args)


    def FirstPointIndex(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPointIndex(self, *args)


    def LastPoint(self, *args) -> "IntSurf_PathPoint const &":
        """
        :rtype: IntSurf_PathPoint

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPoint(self, *args)


    def LastPointIndex(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPointIndex(self, *args)


    def NbPassingPoint(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPassingPoint(self, *args)


    def PassingPoint(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param IndexLine:
        :type IndexLine: int &
        :param IndexPnts:
        :type IndexPnts: int &
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_PassingPoint(self, *args)


    def TangentVector(self, *args) -> "gp_Vec const":
        """
        :param Index:
        :type Index: int &
        :rtype: gp_Vec

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_TangentVector(self, *args)


    def IsTangentAtBegining(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtBegining(self, *args)


    def IsTangentAtEnd(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtEnd(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_TheIWLineOfTheIWalking(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheIWLineOfTheIWalking
IntPatch_TheIWLineOfTheIWalking.Reverse = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_Reverse, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.Cut = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_Cut, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.AddPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.AddStatusFirst = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirst, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.AddStatusFirstLast = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirstLast, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.AddStatusLast = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusLast, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.AddIndexPassing = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddIndexPassing, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.SetTangentVector = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangentVector, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.SetTangencyAtBegining = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtBegining, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.SetTangencyAtEnd = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtEnd, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.NbPoints = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPoints, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.Value = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_Value, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.Line = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_Line, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.IsClosed = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_IsClosed, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_HasFirstPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_HasLastPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.FirstPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.FirstPointIndex = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPointIndex, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.LastPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.LastPointIndex = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPointIndex, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.NbPassingPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPassingPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.PassingPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_PassingPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.TangentVector = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_TangentVector, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.IsTangentAtBegining = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtBegining, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.IsTangentAtEnd = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtEnd, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking_swigregister = _IntPatch.IntPatch_TheIWLineOfTheIWalking_swigregister
IntPatch_TheIWLineOfTheIWalking_swigregister(IntPatch_TheIWLineOfTheIWalking)

class Handle_IntPatch_TheIWLineOfTheIWalking(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_swiginit(self, _IntPatch.new_Handle_IntPatch_TheIWLineOfTheIWalking(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_TheIWLineOfTheIWalking
Handle_IntPatch_TheIWLineOfTheIWalking.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Nullify, None, Handle_IntPatch_TheIWLineOfTheIWalking)
Handle_IntPatch_TheIWLineOfTheIWalking.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsNull, None, Handle_IntPatch_TheIWLineOfTheIWalking)
Handle_IntPatch_TheIWLineOfTheIWalking._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking__get_reference, None, Handle_IntPatch_TheIWLineOfTheIWalking)
Handle_IntPatch_TheIWLineOfTheIWalking_swigregister = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_swigregister
Handle_IntPatch_TheIWLineOfTheIWalking_swigregister(Handle_IntPatch_TheIWLineOfTheIWalking)

def Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_TheIWLineOfTheIWalking const":
    return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(AnObject)
Handle_IntPatch_TheIWLineOfTheIWalking_DownCast = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast

class IntPatch_TheIWalking(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Step:
        :type Step: float
        :rtype: None

        """
        _IntPatch.IntPatch_TheIWalking_swiginit(self, _IntPatch.new_IntPatch_TheIWalking(*args))

    def SetTolerance(self, *args) -> "void":
        """
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Step:
        :type Step: float
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWalking_SetTolerance(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param Pnts1:
        :type Pnts1: IntSurf_SequenceOfPathPoint &
        :param Pnts2:
        :type Pnts2: IntSurf_SequenceOfInteriorPoint &
        :param Func:
        :type Func: IntPatch_TheSurfFunction &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Reversed: default value is Standard_False
        :type Reversed: bool
        :rtype: None

        :param Pnts1:
        :type Pnts1: IntSurf_SequenceOfPathPoint &
        :param Func:
        :type Func: IntPatch_TheSurfFunction &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Reversed: default value is Standard_False
        :type Reversed: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_TheIWalking_Perform(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheIWalking_IsDone(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_TheIWalking_NbLines(self, *args)


    def Value(self, *args) -> "Handle_IntPatch_TheIWLineOfTheIWalking":
        """
        :param Index:
        :type Index: int
        :rtype: Handle_IntPatch_TheIWLineOfTheIWalking

        """
        return _IntPatch.IntPatch_TheIWalking_Value(self, *args)


    def NbSinglePnts(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_TheIWalking_NbSinglePnts(self, *args)


    def SinglePnt(self, *args) -> "IntSurf_PathPoint const &":
        """
        :param Index:
        :type Index: int
        :rtype: IntSurf_PathPoint

        """
        return _IntPatch.IntPatch_TheIWalking_SinglePnt(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheIWalking
IntPatch_TheIWalking.SetTolerance = new_instancemethod(_IntPatch.IntPatch_TheIWalking_SetTolerance, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.Perform = new_instancemethod(_IntPatch.IntPatch_TheIWalking_Perform, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.IsDone = new_instancemethod(_IntPatch.IntPatch_TheIWalking_IsDone, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.NbLines = new_instancemethod(_IntPatch.IntPatch_TheIWalking_NbLines, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.Value = new_instancemethod(_IntPatch.IntPatch_TheIWalking_Value, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.NbSinglePnts = new_instancemethod(_IntPatch.IntPatch_TheIWalking_NbSinglePnts, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.SinglePnt = new_instancemethod(_IntPatch.IntPatch_TheIWalking_SinglePnt, None, IntPatch_TheIWalking)
IntPatch_TheIWalking_swigregister = _IntPatch.IntPatch_TheIWalking_swigregister
IntPatch_TheIWalking_swigregister(IntPatch_TheIWalking)

class IntPatch_ThePathPointOfTheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param P:
        :type P: gp_Pnt
        :param Tol:
        :type Tol: float
        :param V:
        :type V: Handle_Adaptor3d_HVertex &
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :param Parameter:
        :type Parameter: float
        :rtype: None

        :param P:
        :type P: gp_Pnt
        :param Tol:
        :type Tol: float
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :param Parameter:
        :type Parameter: float
        :rtype: None

        """
        _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_ThePathPointOfTheSOnBounds(*args))

    def SetValue(self, *args) -> "void":
        """
        :param P:
        :type P: gp_Pnt
        :param Tol:
        :type Tol: float
        :param V:
        :type V: Handle_Adaptor3d_HVertex &
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :param Parameter:
        :type Parameter: float
        :rtype: None

        :param P:
        :type P: gp_Pnt
        :param Tol:
        :type Tol: float
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :param Parameter:
        :type Parameter: float
        :rtype: None

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_SetValue(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        :rtype: gp_Pnt

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Value(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Tolerance(self, *args)


    def IsNew(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_IsNew(self, *args)


    def Vertex(self, *args) -> "Handle_Adaptor3d_HVertex":
        """
        :rtype: Handle_Adaptor3d_HVertex

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Vertex(self, *args)


    def Arc(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Arc(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Parameter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ThePathPointOfTheSOnBounds
IntPatch_ThePathPointOfTheSOnBounds.SetValue = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_SetValue, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.Value = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Value, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.Tolerance = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Tolerance, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.IsNew = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_IsNew, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.Vertex = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Vertex, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.Arc = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Arc, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.Parameter = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Parameter, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds_swigregister = _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_swigregister
IntPatch_ThePathPointOfTheSOnBounds_swigregister(IntPatch_ThePathPointOfTheSOnBounds)

class IntPatch_TheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _IntPatch.IntPatch_TheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_TheSOnBounds(*args))

    def Perform(self, *args) -> "void":
        """
        :param F:
        :type F: IntPatch_ArcFunction &
        :param Domain:
        :type Domain: Handle_Adaptor3d_TopolTool &
        :param TolBoundary:
        :type TolBoundary: float
        :param TolTangency:
        :type TolTangency: float
        :param RecheckOnRegularity: default value is Standard_False
        :type RecheckOnRegularity: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_TheSOnBounds_Perform(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheSOnBounds_IsDone(self, *args)


    def AllArcSolution(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheSOnBounds_AllArcSolution(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_TheSOnBounds_NbPoints(self, *args)


    def Point(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        :param Index:
        :type Index: int
        :rtype: IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_TheSOnBounds_Point(self, *args)


    def NbSegments(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_TheSOnBounds_NbSegments(self, *args)


    def Segment(self, *args) -> "IntPatch_TheSegmentOfTheSOnBounds const &":
        """
        :param Index:
        :type Index: int
        :rtype: IntPatch_TheSegmentOfTheSOnBounds

        """
        return _IntPatch.IntPatch_TheSOnBounds_Segment(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSOnBounds
IntPatch_TheSOnBounds.Perform = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_Perform, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.IsDone = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_IsDone, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.AllArcSolution = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_AllArcSolution, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.NbPoints = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_NbPoints, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.Point = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_Point, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.NbSegments = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_NbSegments, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.Segment = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_Segment, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds_swigregister = _IntPatch.IntPatch_TheSOnBounds_swigregister
IntPatch_TheSOnBounds_swigregister(IntPatch_TheSOnBounds)

class IntPatch_TheSearchInside(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param F:
        :type F: IntPatch_TheSurfFunction &
        :param Surf:
        :type Surf: Handle_Adaptor3d_HSurface &
        :param T:
        :type T: Handle_Adaptor3d_TopolTool &
        :param Epsilon:
        :type Epsilon: float
        :rtype: None

        """
        _IntPatch.IntPatch_TheSearchInside_swiginit(self, _IntPatch.new_IntPatch_TheSearchInside(*args))

    def Perform(self, *args) -> "void":
        """
        :param F:
        :type F: IntPatch_TheSurfFunction &
        :param Surf:
        :type Surf: Handle_Adaptor3d_HSurface &
        :param T:
        :type T: Handle_Adaptor3d_TopolTool &
        :param Epsilon:
        :type Epsilon: float
        :rtype: None

        :param F:
        :type F: IntPatch_TheSurfFunction &
        :param Surf:
        :type Surf: Handle_Adaptor3d_HSurface &
        :param UStart:
        :type UStart: float
        :param VStart:
        :type VStart: float
        :rtype: None

        """
        return _IntPatch.IntPatch_TheSearchInside_Perform(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheSearchInside_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_TheSearchInside_NbPoints(self, *args)


    def Value(self, *args) -> "IntSurf_InteriorPoint const &":
        """
        :param Index:
        :type Index: int
        :rtype: IntSurf_InteriorPoint

        """
        return _IntPatch.IntPatch_TheSearchInside_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSearchInside
IntPatch_TheSearchInside.Perform = new_instancemethod(_IntPatch.IntPatch_TheSearchInside_Perform, None, IntPatch_TheSearchInside)
IntPatch_TheSearchInside.IsDone = new_instancemethod(_IntPatch.IntPatch_TheSearchInside_IsDone, None, IntPatch_TheSearchInside)
IntPatch_TheSearchInside.NbPoints = new_instancemethod(_IntPatch.IntPatch_TheSearchInside_NbPoints, None, IntPatch_TheSearchInside)
IntPatch_TheSearchInside.Value = new_instancemethod(_IntPatch.IntPatch_TheSearchInside_Value, None, IntPatch_TheSearchInside)
IntPatch_TheSearchInside_swigregister = _IntPatch.IntPatch_TheSearchInside_swigregister
IntPatch_TheSearchInside_swigregister(IntPatch_TheSearchInside)

class IntPatch_TheSegmentOfTheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_TheSegmentOfTheSOnBounds(*args))

    def SetValue(self, *args) -> "void":
        """
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :rtype: None

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetValue(self, *args)


    def SetLimitPoint(self, *args) -> "void":
        """
        :param V:
        :type V: IntPatch_ThePathPointOfTheSOnBounds &
        :param First:
        :type First: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetLimitPoint(self, *args)


    def Curve(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_Curve(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasFirstPoint(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        :rtype: IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_FirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasLastPoint(self, *args)


    def LastPoint(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        :rtype: IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_LastPoint(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSegmentOfTheSOnBounds
IntPatch_TheSegmentOfTheSOnBounds.SetValue = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetValue, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.SetLimitPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetLimitPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.Curve = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_Curve, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasFirstPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.FirstPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_FirstPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasLastPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.LastPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_LastPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds_swigregister = _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_swigregister
IntPatch_TheSegmentOfTheSOnBounds_swigregister(IntPatch_TheSegmentOfTheSOnBounds)

class IntPatch_TheSurfFunction(OCC.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param PS:
        :type PS: Handle_Adaptor3d_HSurface &
        :param IS:
        :type IS: IntSurf_Quadric &
        :rtype: None

        :param IS:
        :type IS: IntSurf_Quadric &
        :rtype: None

        """
        _IntPatch.IntPatch_TheSurfFunction_swiginit(self, _IntPatch.new_IntPatch_TheSurfFunction(*args))

    def SetImplicitSurface(self, *args) -> "void":
        """
        :param IS:
        :type IS: IntSurf_Quadric &
        :rtype: None

        """
        return _IntPatch.IntPatch_TheSurfFunction_SetImplicitSurface(self, *args)


    def Set(self, *args) -> "void":
        """
        :param PS:
        :type PS: Handle_Adaptor3d_HSurface &
        :rtype: None

        :param Tolerance:
        :type Tolerance: float
        :rtype: None

        """
        return _IntPatch.IntPatch_TheSurfFunction_Set(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_TheSurfFunction_Root(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_TheSurfFunction_Tolerance(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        :rtype: gp_Pnt

        """
        return _IntPatch.IntPatch_TheSurfFunction_Point(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_TheSurfFunction_IsTangent(self, *args)


    def Direction3d(self, *args) -> "gp_Vec const":
        """
        :rtype: gp_Vec

        """
        return _IntPatch.IntPatch_TheSurfFunction_Direction3d(self, *args)


    def Direction2d(self, *args) -> "gp_Dir2d const":
        """
        :rtype: gp_Dir2d

        """
        return _IntPatch.IntPatch_TheSurfFunction_Direction2d(self, *args)


    def PSurface(self, *args) -> "Handle_Adaptor3d_HSurface":
        """
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _IntPatch.IntPatch_TheSurfFunction_PSurface(self, *args)


    def ISurface(self, *args) -> "IntSurf_Quadric const &":
        """
        :rtype: IntSurf_Quadric

        """
        return _IntPatch.IntPatch_TheSurfFunction_ISurface(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSurfFunction
IntPatch_TheSurfFunction.SetImplicitSurface = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_SetImplicitSurface, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Set = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Set, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Root = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Root, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Tolerance = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Tolerance, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Point = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Point, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.IsTangent = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_IsTangent, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Direction3d = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Direction3d, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Direction2d = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Direction2d, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.PSurface = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_PSurface, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.ISurface = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_ISurface, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction_swigregister = _IntPatch.IntPatch_TheSurfFunction_swigregister
IntPatch_TheSurfFunction_swigregister(IntPatch_TheSurfFunction)

class IntPatch_ALine(IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates an analytic intersection line when the transitions are In or Out.

        :param C:
        :type C: IntAna_Curve &
        :param Tang:
        :type Tang: bool
        :param Trans1:
        :type Trans1: IntSurf_TypeTrans
        :param Trans2:
        :type Trans2: IntSurf_TypeTrans
        :rtype: None

        * Creates an analytic intersection line when the transitions are Touch.

        :param C:
        :type C: IntAna_Curve &
        :param Tang:
        :type Tang: bool
        :param Situ1:
        :type Situ1: IntSurf_Situation
        :param Situ2:
        :type Situ2: IntSurf_Situation
        :rtype: None

        * Creates an analytic intersection line when the transitions are Undecided.

        :param C:
        :type C: IntAna_Curve &
        :param Tang:
        :type Tang: bool
        :rtype: None

        """
        _IntPatch.IntPatch_ALine_swiginit(self, _IntPatch.new_IntPatch_ALine(*args))

    def AddVertex(self, *args) -> "void":
        """
        * To add a vertex in the list.

        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_ALine_AddVertex(self, *args)


    def Replace(self, *args) -> "void":
        """
        * Replaces the element of range Index in the list of points.

        :param Index:
        :type Index: int
        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_ALine_Replace(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        :param IndFirst:
        :type IndFirst: int
        :rtype: None

        """
        return _IntPatch.IntPatch_ALine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        :param IndLast:
        :type IndLast: int
        :rtype: None

        """
        return _IntPatch.IntPatch_ALine_SetLastPoint(self, *args)


    def FirstParameter(self, *args) -> "Standard_Real":
        """
        * Returns the first parameter on the intersection line. If IsIncluded returns True, Value and D1 methods can be call with a parameter equal to FirstParamater. Otherwise, the parameter must be greater than FirstParameter.

        :param IsIncluded:
        :type IsIncluded: bool
        :rtype: float

        """
        return _IntPatch.IntPatch_ALine_FirstParameter(self, *args)


    def LastParameter(self, *args) -> "Standard_Real":
        """
        * Returns the last parameter on the intersection line. If IsIncluded returns True, Value and D1 methods can be call with a parameter equal to LastParamater. Otherwise, the parameter must be less than LastParameter.

        :param IsIncluded:
        :type IsIncluded: bool
        :rtype: float

        """
        return _IntPatch.IntPatch_ALine_LastParameter(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        * Returns the point of parameter U on the analytic intersection line.

        :param U:
        :type U: float
        :rtype: gp_Pnt

        """
        return _IntPatch.IntPatch_ALine_Value(self, *args)


    def D1(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True when the derivative at parameter U is defined on the analytic intersection line. In that case, Du is the derivative. Returns Standard_False when it is not possible to evaluate the derivative. In both cases, P is the point at parameter U on the intersection.

        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt
        :param Du:
        :type Du: gp_Vec
        :rtype: bool

        """
        return _IntPatch.IntPatch_ALine_D1(self, *args)


    def FindParameter(self, *args) -> "Standard_Boolean":
        """
        * Tries to find the parameter of the point P on the curve. If the method returns False, the 'projection' is impossible, and the value of Para is not significant. If the method returns True, Para is the parameter of the nearest intersection between the curve and the iso-theta containing P.

        :param P:
        :type P: gp_Pnt
        :param Para:
        :type Para: float &
        :rtype: bool

        """
        return _IntPatch.IntPatch_ALine_FindParameter(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known First point. This point is given by the method FirstPoint().

        :rtype: bool

        """
        return _IntPatch.IntPatch_ALine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known Last point. This point is given by the method LastPoint().

        :rtype: bool

        """
        return _IntPatch.IntPatch_ALine_HasLastPoint(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the FirstPoint. An exception is raised when HasFirstPoint returns False.

        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_FirstPoint(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the LastPoint. An exception is raised when HasLastPoint returns False.

        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_LastPoint(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_ALine_NbVertex(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the vertex of range Index on the line.

        :param Index:
        :type Index: int
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_Vertex(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        * Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.

        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _IntPatch.IntPatch_ALine_ComputeVertexParameters(self, *args)


    def Curve(self, *args) -> "IntAna_Curve const &":
        """
        :rtype: IntAna_Curve

        """
        return _IntPatch.IntPatch_ALine_Curve(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_ALine(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ALine
IntPatch_ALine.AddVertex = new_instancemethod(_IntPatch.IntPatch_ALine_AddVertex, None, IntPatch_ALine)
IntPatch_ALine.Replace = new_instancemethod(_IntPatch.IntPatch_ALine_Replace, None, IntPatch_ALine)
IntPatch_ALine.SetFirstPoint = new_instancemethod(_IntPatch.IntPatch_ALine_SetFirstPoint, None, IntPatch_ALine)
IntPatch_ALine.SetLastPoint = new_instancemethod(_IntPatch.IntPatch_ALine_SetLastPoint, None, IntPatch_ALine)
IntPatch_ALine.FirstParameter = new_instancemethod(_IntPatch.IntPatch_ALine_FirstParameter, None, IntPatch_ALine)
IntPatch_ALine.LastParameter = new_instancemethod(_IntPatch.IntPatch_ALine_LastParameter, None, IntPatch_ALine)
IntPatch_ALine.Value = new_instancemethod(_IntPatch.IntPatch_ALine_Value, None, IntPatch_ALine)
IntPatch_ALine.D1 = new_instancemethod(_IntPatch.IntPatch_ALine_D1, None, IntPatch_ALine)
IntPatch_ALine.FindParameter = new_instancemethod(_IntPatch.IntPatch_ALine_FindParameter, None, IntPatch_ALine)
IntPatch_ALine.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_ALine_HasFirstPoint, None, IntPatch_ALine)
IntPatch_ALine.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_ALine_HasLastPoint, None, IntPatch_ALine)
IntPatch_ALine.FirstPoint = new_instancemethod(_IntPatch.IntPatch_ALine_FirstPoint, None, IntPatch_ALine)
IntPatch_ALine.LastPoint = new_instancemethod(_IntPatch.IntPatch_ALine_LastPoint, None, IntPatch_ALine)
IntPatch_ALine.NbVertex = new_instancemethod(_IntPatch.IntPatch_ALine_NbVertex, None, IntPatch_ALine)
IntPatch_ALine.Vertex = new_instancemethod(_IntPatch.IntPatch_ALine_Vertex, None, IntPatch_ALine)
IntPatch_ALine.ComputeVertexParameters = new_instancemethod(_IntPatch.IntPatch_ALine_ComputeVertexParameters, None, IntPatch_ALine)
IntPatch_ALine.Curve = new_instancemethod(_IntPatch.IntPatch_ALine_Curve, None, IntPatch_ALine)
IntPatch_ALine_swigregister = _IntPatch.IntPatch_ALine_swigregister
IntPatch_ALine_swigregister(IntPatch_ALine)

class Handle_IntPatch_ALine(Handle_IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_ALine_swiginit(self, _IntPatch.new_Handle_IntPatch_ALine(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_ALine_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_ALine
Handle_IntPatch_ALine.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_ALine_Nullify, None, Handle_IntPatch_ALine)
Handle_IntPatch_ALine.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_ALine_IsNull, None, Handle_IntPatch_ALine)
Handle_IntPatch_ALine._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_ALine__get_reference, None, Handle_IntPatch_ALine)
Handle_IntPatch_ALine_swigregister = _IntPatch.Handle_IntPatch_ALine_swigregister
Handle_IntPatch_ALine_swigregister(Handle_IntPatch_ALine)

def Handle_IntPatch_ALine_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_ALine const":
    return _IntPatch.Handle_IntPatch_ALine_DownCast(AnObject)
Handle_IntPatch_ALine_DownCast = _IntPatch.Handle_IntPatch_ALine_DownCast

class IntPatch_GLine(IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a Line as intersection line when the transitions are In or Out.

        :param L:
        :type L: gp_Lin
        :param Tang:
        :type Tang: bool
        :param Trans1:
        :type Trans1: IntSurf_TypeTrans
        :param Trans2:
        :type Trans2: IntSurf_TypeTrans
        :rtype: None

        * Creates a Line as intersection line when the transitions are Touch.

        :param L:
        :type L: gp_Lin
        :param Tang:
        :type Tang: bool
        :param Situ1:
        :type Situ1: IntSurf_Situation
        :param Situ2:
        :type Situ2: IntSurf_Situation
        :rtype: None

        * Creates a Line as intersection line when the transitions are Undecided.

        :param L:
        :type L: gp_Lin
        :param Tang:
        :type Tang: bool
        :rtype: None

        * Creates a circle as intersection line when the transitions are In or Out.

        :param C:
        :type C: gp_Circ
        :param Tang:
        :type Tang: bool
        :param Trans1:
        :type Trans1: IntSurf_TypeTrans
        :param Trans2:
        :type Trans2: IntSurf_TypeTrans
        :rtype: None

        * Creates a circle as intersection line when the transitions are Touch.

        :param C:
        :type C: gp_Circ
        :param Tang:
        :type Tang: bool
        :param Situ1:
        :type Situ1: IntSurf_Situation
        :param Situ2:
        :type Situ2: IntSurf_Situation
        :rtype: None

        * Creates a circle as intersection line when the transitions are Undecided.

        :param C:
        :type C: gp_Circ
        :param Tang:
        :type Tang: bool
        :rtype: None

        * Creates an ellipse as intersection line when the transitions are In or Out.

        :param E:
        :type E: gp_Elips
        :param Tang:
        :type Tang: bool
        :param Trans1:
        :type Trans1: IntSurf_TypeTrans
        :param Trans2:
        :type Trans2: IntSurf_TypeTrans
        :rtype: None

        * Creates an ellispe as intersection line when the transitions are Touch.

        :param E:
        :type E: gp_Elips
        :param Tang:
        :type Tang: bool
        :param Situ1:
        :type Situ1: IntSurf_Situation
        :param Situ2:
        :type Situ2: IntSurf_Situation
        :rtype: None

        * Creates an ellipse as intersection line when the transitions are Undecided.

        :param E:
        :type E: gp_Elips
        :param Tang:
        :type Tang: bool
        :rtype: None

        * Creates a parabola as intersection line when the transitions are In or Out.

        :param P:
        :type P: gp_Parab
        :param Tang:
        :type Tang: bool
        :param Trans1:
        :type Trans1: IntSurf_TypeTrans
        :param Trans2:
        :type Trans2: IntSurf_TypeTrans
        :rtype: None

        * Creates a parabola as intersection line when the transitions are Touch.

        :param P:
        :type P: gp_Parab
        :param Tang:
        :type Tang: bool
        :param Situ1:
        :type Situ1: IntSurf_Situation
        :param Situ2:
        :type Situ2: IntSurf_Situation
        :rtype: None

        * Creates a parabola as intersection line when the transitions are Undecided.

        :param P:
        :type P: gp_Parab
        :param Tang:
        :type Tang: bool
        :rtype: None

        * Creates an hyperbola as intersection line when the transitions are In or Out.

        :param H:
        :type H: gp_Hypr
        :param Tang:
        :type Tang: bool
        :param Trans1:
        :type Trans1: IntSurf_TypeTrans
        :param Trans2:
        :type Trans2: IntSurf_TypeTrans
        :rtype: None

        * Creates an hyperbola as intersection line when the transitions are Touch.

        :param H:
        :type H: gp_Hypr
        :param Tang:
        :type Tang: bool
        :param Situ1:
        :type Situ1: IntSurf_Situation
        :param Situ2:
        :type Situ2: IntSurf_Situation
        :rtype: None

        * Creates an hyperbola as intersection line when the transitions are Undecided.

        :param H:
        :type H: gp_Hypr
        :param Tang:
        :type Tang: bool
        :rtype: None

        """
        _IntPatch.IntPatch_GLine_swiginit(self, _IntPatch.new_IntPatch_GLine(*args))

    def AddVertex(self, *args) -> "void":
        """
        * To add a vertex in the list.

        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_GLine_AddVertex(self, *args)


    def Replace(self, *args) -> "void":
        """
        * To replace the element of range Index in the list of points.

        :param Index:
        :type Index: int
        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_GLine_Replace(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        :param IndFirst:
        :type IndFirst: int
        :rtype: None

        """
        return _IntPatch.IntPatch_GLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        :param IndLast:
        :type IndLast: int
        :rtype: None

        """
        return _IntPatch.IntPatch_GLine_SetLastPoint(self, *args)


    def Line(self, *args) -> "gp_Lin":
        """
        * Returns the Lin from gp corresponding to the intersection when ArcType returns IntPatch_Line.

        :rtype: gp_Lin

        """
        return _IntPatch.IntPatch_GLine_Line(self, *args)


    def Circle(self, *args) -> "gp_Circ":
        """
        * Returns the Circ from gp corrsponding to the intersection when ArcType returns IntPatch_Circle.

        :rtype: gp_Circ

        """
        return _IntPatch.IntPatch_GLine_Circle(self, *args)


    def Ellipse(self, *args) -> "gp_Elips":
        """
        * Returns the Elips from gp corrsponding to the intersection when ArcType returns IntPatch_Ellipse.

        :rtype: gp_Elips

        """
        return _IntPatch.IntPatch_GLine_Ellipse(self, *args)


    def Parabola(self, *args) -> "gp_Parab":
        """
        * Returns the Parab from gp corrsponding to the intersection when ArcType returns IntPatch_Parabola.

        :rtype: gp_Parab

        """
        return _IntPatch.IntPatch_GLine_Parabola(self, *args)


    def Hyperbola(self, *args) -> "gp_Hypr":
        """
        * Returns the Hypr from gp corrsponding to the intersection when ArcType returns IntPatch_Hyperbola.

        :rtype: gp_Hypr

        """
        return _IntPatch.IntPatch_GLine_Hyperbola(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known First point. This point is given by the method FirstPoint().

        :rtype: bool

        """
        return _IntPatch.IntPatch_GLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known Last point. This point is given by the method LastPoint().

        :rtype: bool

        """
        return _IntPatch.IntPatch_GLine_HasLastPoint(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the FirstPoint. An exception is raised when HasFirstPoint returns False.

        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_GLine_FirstPoint(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the LastPoint. An exception is raised when HasLastPoint returns False.

        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_GLine_LastPoint(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_GLine_NbVertex(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the vertex of range Index on the line.

        :param Index:
        :type Index: int
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_GLine_Vertex(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        * Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.

        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _IntPatch.IntPatch_GLine_ComputeVertexParameters(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_GLine(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_GLine
IntPatch_GLine.AddVertex = new_instancemethod(_IntPatch.IntPatch_GLine_AddVertex, None, IntPatch_GLine)
IntPatch_GLine.Replace = new_instancemethod(_IntPatch.IntPatch_GLine_Replace, None, IntPatch_GLine)
IntPatch_GLine.SetFirstPoint = new_instancemethod(_IntPatch.IntPatch_GLine_SetFirstPoint, None, IntPatch_GLine)
IntPatch_GLine.SetLastPoint = new_instancemethod(_IntPatch.IntPatch_GLine_SetLastPoint, None, IntPatch_GLine)
IntPatch_GLine.Line = new_instancemethod(_IntPatch.IntPatch_GLine_Line, None, IntPatch_GLine)
IntPatch_GLine.Circle = new_instancemethod(_IntPatch.IntPatch_GLine_Circle, None, IntPatch_GLine)
IntPatch_GLine.Ellipse = new_instancemethod(_IntPatch.IntPatch_GLine_Ellipse, None, IntPatch_GLine)
IntPatch_GLine.Parabola = new_instancemethod(_IntPatch.IntPatch_GLine_Parabola, None, IntPatch_GLine)
IntPatch_GLine.Hyperbola = new_instancemethod(_IntPatch.IntPatch_GLine_Hyperbola, None, IntPatch_GLine)
IntPatch_GLine.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_GLine_HasFirstPoint, None, IntPatch_GLine)
IntPatch_GLine.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_GLine_HasLastPoint, None, IntPatch_GLine)
IntPatch_GLine.FirstPoint = new_instancemethod(_IntPatch.IntPatch_GLine_FirstPoint, None, IntPatch_GLine)
IntPatch_GLine.LastPoint = new_instancemethod(_IntPatch.IntPatch_GLine_LastPoint, None, IntPatch_GLine)
IntPatch_GLine.NbVertex = new_instancemethod(_IntPatch.IntPatch_GLine_NbVertex, None, IntPatch_GLine)
IntPatch_GLine.Vertex = new_instancemethod(_IntPatch.IntPatch_GLine_Vertex, None, IntPatch_GLine)
IntPatch_GLine.ComputeVertexParameters = new_instancemethod(_IntPatch.IntPatch_GLine_ComputeVertexParameters, None, IntPatch_GLine)
IntPatch_GLine_swigregister = _IntPatch.IntPatch_GLine_swigregister
IntPatch_GLine_swigregister(IntPatch_GLine)

class Handle_IntPatch_GLine(Handle_IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_GLine_swiginit(self, _IntPatch.new_Handle_IntPatch_GLine(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_GLine_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_GLine
Handle_IntPatch_GLine.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_GLine_Nullify, None, Handle_IntPatch_GLine)
Handle_IntPatch_GLine.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_GLine_IsNull, None, Handle_IntPatch_GLine)
Handle_IntPatch_GLine._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_GLine__get_reference, None, Handle_IntPatch_GLine)
Handle_IntPatch_GLine_swigregister = _IntPatch.Handle_IntPatch_GLine_swigregister
Handle_IntPatch_GLine_swigregister(Handle_IntPatch_GLine)

def Handle_IntPatch_GLine_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_GLine const":
    return _IntPatch.Handle_IntPatch_GLine_DownCast(AnObject)
Handle_IntPatch_GLine_DownCast = _IntPatch.Handle_IntPatch_GLine_DownCast

class IntPatch_PolyArc(IntPatch_Polygo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates the polygon of the arc A on the surface S. The arc is limited by the parameters Pfirst and Plast. None of these parameters can be infinite.

        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :param NbSample:
        :type NbSample: int
        :param Pfirst:
        :type Pfirst: float
        :param Plast:
        :type Plast: float
        :param BoxOtherPolygon:
        :type BoxOtherPolygon: Bnd_Box2d &
        :rtype: None

        """
        _IntPatch.IntPatch_PolyArc_swiginit(self, _IntPatch.new_IntPatch_PolyArc(*args))

    def Parameter(self, *args) -> "Standard_Real":
        """
        :param Index:
        :type Index: int
        :rtype: float

        """
        return _IntPatch.IntPatch_PolyArc_Parameter(self, *args)


    def SetOffset(self, *args) -> "void":
        """
        :param OffsetX:
        :type OffsetX: float
        :param OffsetY:
        :type OffsetY: float
        :rtype: None

        """
        return _IntPatch.IntPatch_PolyArc_SetOffset(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyArc
IntPatch_PolyArc.Parameter = new_instancemethod(_IntPatch.IntPatch_PolyArc_Parameter, None, IntPatch_PolyArc)
IntPatch_PolyArc.SetOffset = new_instancemethod(_IntPatch.IntPatch_PolyArc_SetOffset, None, IntPatch_PolyArc)
IntPatch_PolyArc_swigregister = _IntPatch.IntPatch_PolyArc_swigregister
IntPatch_PolyArc_swigregister(IntPatch_PolyArc)

class IntPatch_PolyLine(IntPatch_Polygo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param InitDefle:
        :type InitDefle: float
        :rtype: None

        """
        _IntPatch.IntPatch_PolyLine_swiginit(self, _IntPatch.new_IntPatch_PolyLine(*args))

    def SetWLine(self, *args) -> "void":
        """
        :param OnFirst:
        :type OnFirst: bool
        :param Line:
        :type Line: Handle_IntPatch_WLine &
        :rtype: None

        """
        return _IntPatch.IntPatch_PolyLine_SetWLine(self, *args)


    def SetRLine(self, *args) -> "void":
        """
        :param OnFirst:
        :type OnFirst: bool
        :param Line:
        :type Line: Handle_IntPatch_RLine &
        :rtype: None

        """
        return _IntPatch.IntPatch_PolyLine_SetRLine(self, *args)


    def ResetError(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_PolyLine_ResetError(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyLine
IntPatch_PolyLine.SetWLine = new_instancemethod(_IntPatch.IntPatch_PolyLine_SetWLine, None, IntPatch_PolyLine)
IntPatch_PolyLine.SetRLine = new_instancemethod(_IntPatch.IntPatch_PolyLine_SetRLine, None, IntPatch_PolyLine)
IntPatch_PolyLine.ResetError = new_instancemethod(_IntPatch.IntPatch_PolyLine_ResetError, None, IntPatch_PolyLine)
IntPatch_PolyLine_swigregister = _IntPatch.IntPatch_PolyLine_swigregister
IntPatch_PolyLine_swigregister(IntPatch_PolyLine)

class IntPatch_RLine(IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a restriction as an intersection line when the transitions are In or Out.

        :param Tang:
        :type Tang: bool
        :param Trans1:
        :type Trans1: IntSurf_TypeTrans
        :param Trans2:
        :type Trans2: IntSurf_TypeTrans
        :rtype: None

        * Creates a restriction as an intersection line when the transitions are Touch.

        :param Tang:
        :type Tang: bool
        :param Situ1:
        :type Situ1: IntSurf_Situation
        :param Situ2:
        :type Situ2: IntSurf_Situation
        :rtype: None

        * Creates a restriction as an intersection line when the transitions are Undecided.

        :param Tang:
        :type Tang: bool
        :rtype: None

        """
        _IntPatch.IntPatch_RLine_swiginit(self, _IntPatch.new_IntPatch_RLine(*args))

    def AddVertex(self, *args) -> "void":
        """
        * To add a vertex in the list.

        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_AddVertex(self, *args)


    def Replace(self, *args) -> "void":
        """
        * Replaces the element of range Index in the list of points.

        :param Index:
        :type Index: int
        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_Replace(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        :param IndFirst:
        :type IndFirst: int
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        :param IndLast:
        :type IndLast: int
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_SetLastPoint(self, *args)


    def Add(self, *args) -> "void":
        """
        :param L:
        :type L: Handle_IntSurf_LineOn2S &
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_Add(self, *args)


    def IsArcOnS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is on the domain of the first patch. Returns False if the intersection is on the domain of the second patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_RLine_IsArcOnS1(self, *args)


    def IsArcOnS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is on the domain of the first patch. Returns False if the intersection is on the domain of the second patch.

        :rtype: bool

        """
        return _IntPatch.IntPatch_RLine_IsArcOnS2(self, *args)


    def SetArcOnS1(self, *args) -> "void":
        """
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_SetArcOnS1(self, *args)


    def SetArcOnS2(self, *args) -> "void":
        """
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_SetArcOnS2(self, *args)


    def ArcOnS1(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        * Returns the concerned arc.

        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_RLine_ArcOnS1(self, *args)


    def ArcOnS2(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        * Returns the concerned arc.

        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_RLine_ArcOnS2(self, *args)


    def ParamOnS1(self, *args) -> "void":
        """
        :param p1:
        :type p1: float &
        :param p2:
        :type p2: float &
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_ParamOnS1(self, *args)


    def ParamOnS2(self, *args) -> "void":
        """
        :param p1:
        :type p1: float &
        :param p2:
        :type p2: float &
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_ParamOnS2(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known First point. This point is given by the method FirstPoint().

        :rtype: bool

        """
        return _IntPatch.IntPatch_RLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known Last point. This point is given by the method LastPoint().

        :rtype: bool

        """
        return _IntPatch.IntPatch_RLine_HasLastPoint(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the FirstPoint. An exception is raised when HasFirstPoint returns False.

        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_RLine_FirstPoint(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the LastPoint. An exception is raised when HasLastPoint returns False.

        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_RLine_LastPoint(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_RLine_NbVertex(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the vertex of range Index on the line.

        :param Index:
        :type Index: int
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_RLine_Vertex(self, *args)


    def HasPolygon(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_RLine_HasPolygon(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection points.

        :rtype: int

        """
        return _IntPatch.IntPatch_RLine_NbPnts(self, *args)


    def Point(self, *args) -> "IntSurf_PntOn2S const &":
        """
        * Returns the intersection point of range Index.

        :param Index:
        :type Index: int
        :rtype: IntSurf_PntOn2S

        """
        return _IntPatch.IntPatch_RLine_Point(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        * Set the Point of index <Index> in the LineOn2S

        :param Index:
        :type Index: int
        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_SetPoint(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        * Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.

        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _IntPatch.IntPatch_RLine_ComputeVertexParameters(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_RLine(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_RLine
IntPatch_RLine.AddVertex = new_instancemethod(_IntPatch.IntPatch_RLine_AddVertex, None, IntPatch_RLine)
IntPatch_RLine.Replace = new_instancemethod(_IntPatch.IntPatch_RLine_Replace, None, IntPatch_RLine)
IntPatch_RLine.SetFirstPoint = new_instancemethod(_IntPatch.IntPatch_RLine_SetFirstPoint, None, IntPatch_RLine)
IntPatch_RLine.SetLastPoint = new_instancemethod(_IntPatch.IntPatch_RLine_SetLastPoint, None, IntPatch_RLine)
IntPatch_RLine.Add = new_instancemethod(_IntPatch.IntPatch_RLine_Add, None, IntPatch_RLine)
IntPatch_RLine.IsArcOnS1 = new_instancemethod(_IntPatch.IntPatch_RLine_IsArcOnS1, None, IntPatch_RLine)
IntPatch_RLine.IsArcOnS2 = new_instancemethod(_IntPatch.IntPatch_RLine_IsArcOnS2, None, IntPatch_RLine)
IntPatch_RLine.SetArcOnS1 = new_instancemethod(_IntPatch.IntPatch_RLine_SetArcOnS1, None, IntPatch_RLine)
IntPatch_RLine.SetArcOnS2 = new_instancemethod(_IntPatch.IntPatch_RLine_SetArcOnS2, None, IntPatch_RLine)
IntPatch_RLine.ArcOnS1 = new_instancemethod(_IntPatch.IntPatch_RLine_ArcOnS1, None, IntPatch_RLine)
IntPatch_RLine.ArcOnS2 = new_instancemethod(_IntPatch.IntPatch_RLine_ArcOnS2, None, IntPatch_RLine)
IntPatch_RLine.ParamOnS1 = new_instancemethod(_IntPatch.IntPatch_RLine_ParamOnS1, None, IntPatch_RLine)
IntPatch_RLine.ParamOnS2 = new_instancemethod(_IntPatch.IntPatch_RLine_ParamOnS2, None, IntPatch_RLine)
IntPatch_RLine.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_RLine_HasFirstPoint, None, IntPatch_RLine)
IntPatch_RLine.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_RLine_HasLastPoint, None, IntPatch_RLine)
IntPatch_RLine.FirstPoint = new_instancemethod(_IntPatch.IntPatch_RLine_FirstPoint, None, IntPatch_RLine)
IntPatch_RLine.LastPoint = new_instancemethod(_IntPatch.IntPatch_RLine_LastPoint, None, IntPatch_RLine)
IntPatch_RLine.NbVertex = new_instancemethod(_IntPatch.IntPatch_RLine_NbVertex, None, IntPatch_RLine)
IntPatch_RLine.Vertex = new_instancemethod(_IntPatch.IntPatch_RLine_Vertex, None, IntPatch_RLine)
IntPatch_RLine.HasPolygon = new_instancemethod(_IntPatch.IntPatch_RLine_HasPolygon, None, IntPatch_RLine)
IntPatch_RLine.NbPnts = new_instancemethod(_IntPatch.IntPatch_RLine_NbPnts, None, IntPatch_RLine)
IntPatch_RLine.Point = new_instancemethod(_IntPatch.IntPatch_RLine_Point, None, IntPatch_RLine)
IntPatch_RLine.SetPoint = new_instancemethod(_IntPatch.IntPatch_RLine_SetPoint, None, IntPatch_RLine)
IntPatch_RLine.ComputeVertexParameters = new_instancemethod(_IntPatch.IntPatch_RLine_ComputeVertexParameters, None, IntPatch_RLine)
IntPatch_RLine_swigregister = _IntPatch.IntPatch_RLine_swigregister
IntPatch_RLine_swigregister(IntPatch_RLine)

class Handle_IntPatch_RLine(Handle_IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_RLine_swiginit(self, _IntPatch.new_Handle_IntPatch_RLine(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_RLine_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_RLine
Handle_IntPatch_RLine.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_RLine_Nullify, None, Handle_IntPatch_RLine)
Handle_IntPatch_RLine.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_RLine_IsNull, None, Handle_IntPatch_RLine)
Handle_IntPatch_RLine._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_RLine__get_reference, None, Handle_IntPatch_RLine)
Handle_IntPatch_RLine_swigregister = _IntPatch.Handle_IntPatch_RLine_swigregister
Handle_IntPatch_RLine_swigregister(Handle_IntPatch_RLine)

def Handle_IntPatch_RLine_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_RLine const":
    return _IntPatch.Handle_IntPatch_RLine_DownCast(AnObject)
Handle_IntPatch_RLine_DownCast = _IntPatch.Handle_IntPatch_RLine_DownCast

class IntPatch_WLine(IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a WLine as an intersection when the transitions are In or Out.

        :param Line:
        :type Line: Handle_IntSurf_LineOn2S &
        :param Tang:
        :type Tang: bool
        :param Trans1:
        :type Trans1: IntSurf_TypeTrans
        :param Trans2:
        :type Trans2: IntSurf_TypeTrans
        :rtype: None

        * Creates a WLine as an intersection when the transitions are Touch.

        :param Line:
        :type Line: Handle_IntSurf_LineOn2S &
        :param Tang:
        :type Tang: bool
        :param Situ1:
        :type Situ1: IntSurf_Situation
        :param Situ2:
        :type Situ2: IntSurf_Situation
        :rtype: None

        * Creates a WLine as an intersection when the transitions are Undecided.

        :param Line:
        :type Line: Handle_IntSurf_LineOn2S &
        :param Tang:
        :type Tang: bool
        :rtype: None

        """
        _IntPatch.IntPatch_WLine_swiginit(self, _IntPatch.new_IntPatch_WLine(*args))

    def AddVertex(self, *args) -> "void":
        """
        * Adds a vertex in the list.

        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_AddVertex(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        * Set the Point of index <Index> in the LineOn2S

        :param Index:
        :type Index: int
        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_SetPoint(self, *args)


    def Replace(self, *args) -> "void":
        """
        * Replaces the element of range Index in the list of points. The exception OutOfRange is raised when Index <= 0 or Index > NbVertex.

        :param Index:
        :type Index: int
        :param Pnt:
        :type Pnt: IntPatch_Point &
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_Replace(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        :param IndFirst:
        :type IndFirst: int
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        :param IndLast:
        :type IndLast: int
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_SetLastPoint(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection points.

        :rtype: int

        """
        return _IntPatch.IntPatch_WLine_NbPnts(self, *args)


    def Point(self, *args) -> "IntSurf_PntOn2S const &":
        """
        * Returns the intersection point of range Index.

        :param Index:
        :type Index: int
        :rtype: IntSurf_PntOn2S

        """
        return _IntPatch.IntPatch_WLine_Point(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known First point. This point is given by the method FirstPoint().

        :rtype: bool

        """
        return _IntPatch.IntPatch_WLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known Last point. This point is given by the method LastPoint().

        :rtype: bool

        """
        return _IntPatch.IntPatch_WLine_HasLastPoint(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the Point corresponding to the FirstPoint.

        :rtype: IntPatch_Point

        * Returns the Point corresponding to the FirstPoint. Indfirst is the index of the first in the list of vertices.

        :param Indfirst:
        :type Indfirst: int &
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_WLine_FirstPoint(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the Point corresponding to the LastPoint.

        :rtype: IntPatch_Point

        * Returns the Point corresponding to the LastPoint. Indlast is the index of the last in the list of vertices.

        :param Indlast:
        :type Indlast: int &
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_WLine_LastPoint(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _IntPatch.IntPatch_WLine_NbVertex(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the vertex of range Index on the line.

        :param Index:
        :type Index: int
        :rtype: IntPatch_Point

        """
        return _IntPatch.IntPatch_WLine_Vertex(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        * Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.

        :param Tol:
        :type Tol: float
        :param hasBeenAdded: default value is Standard_False
        :type hasBeenAdded: bool
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_ComputeVertexParameters(self, *args)


    def Curve(self, *args) -> "Handle_IntSurf_LineOn2S":
        """
        :rtype: Handle_IntSurf_LineOn2S

        """
        return _IntPatch.IntPatch_WLine_Curve(self, *args)


    def IsOutSurf1Box(self, *args) -> "Standard_Boolean":
        """
        :param P1:
        :type P1: gp_Pnt2d
        :rtype: bool

        """
        return _IntPatch.IntPatch_WLine_IsOutSurf1Box(self, *args)


    def IsOutSurf2Box(self, *args) -> "Standard_Boolean":
        """
        :param P1:
        :type P1: gp_Pnt2d
        :rtype: bool

        """
        return _IntPatch.IntPatch_WLine_IsOutSurf2Box(self, *args)


    def IsOutBox(self, *args) -> "Standard_Boolean":
        """
        :param P:
        :type P: gp_Pnt
        :rtype: bool

        """
        return _IntPatch.IntPatch_WLine_IsOutBox(self, *args)


    def SetPeriod(self, *args) -> "void":
        """
        :param pu1:
        :type pu1: float
        :param pv1:
        :type pv1: float
        :param pu2:
        :type pu2: float
        :param pv2:
        :type pv2: float
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_SetPeriod(self, *args)


    def U1Period(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_WLine_U1Period(self, *args)


    def V1Period(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_WLine_V1Period(self, *args)


    def U2Period(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_WLine_U2Period(self, *args)


    def V2Period(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntPatch.IntPatch_WLine_V2Period(self, *args)


    def SetArcOnS1(self, *args) -> "void":
        """
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_SetArcOnS1(self, *args)


    def HasArcOnS1(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_WLine_HasArcOnS1(self, *args)


    def GetArcOnS1(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_WLine_GetArcOnS1(self, *args)


    def SetArcOnS2(self, *args) -> "void":
        """
        :param A:
        :type A: Handle_Adaptor2d_HCurve2d &
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_SetArcOnS2(self, *args)


    def HasArcOnS2(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntPatch.IntPatch_WLine_HasArcOnS2(self, *args)


    def GetArcOnS2(self, *args) -> "Handle_Adaptor2d_HCurve2d":
        """
        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_WLine_GetArcOnS2(self, *args)


    def Dump(self, *args) -> "void":
        """
        :rtype: None

        """
        return _IntPatch.IntPatch_WLine_Dump(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_IntPatch_WLine(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_WLine
IntPatch_WLine.AddVertex = new_instancemethod(_IntPatch.IntPatch_WLine_AddVertex, None, IntPatch_WLine)
IntPatch_WLine.SetPoint = new_instancemethod(_IntPatch.IntPatch_WLine_SetPoint, None, IntPatch_WLine)
IntPatch_WLine.Replace = new_instancemethod(_IntPatch.IntPatch_WLine_Replace, None, IntPatch_WLine)
IntPatch_WLine.SetFirstPoint = new_instancemethod(_IntPatch.IntPatch_WLine_SetFirstPoint, None, IntPatch_WLine)
IntPatch_WLine.SetLastPoint = new_instancemethod(_IntPatch.IntPatch_WLine_SetLastPoint, None, IntPatch_WLine)
IntPatch_WLine.NbPnts = new_instancemethod(_IntPatch.IntPatch_WLine_NbPnts, None, IntPatch_WLine)
IntPatch_WLine.Point = new_instancemethod(_IntPatch.IntPatch_WLine_Point, None, IntPatch_WLine)
IntPatch_WLine.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_WLine_HasFirstPoint, None, IntPatch_WLine)
IntPatch_WLine.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_WLine_HasLastPoint, None, IntPatch_WLine)
IntPatch_WLine.FirstPoint = new_instancemethod(_IntPatch.IntPatch_WLine_FirstPoint, None, IntPatch_WLine)
IntPatch_WLine.LastPoint = new_instancemethod(_IntPatch.IntPatch_WLine_LastPoint, None, IntPatch_WLine)
IntPatch_WLine.NbVertex = new_instancemethod(_IntPatch.IntPatch_WLine_NbVertex, None, IntPatch_WLine)
IntPatch_WLine.Vertex = new_instancemethod(_IntPatch.IntPatch_WLine_Vertex, None, IntPatch_WLine)
IntPatch_WLine.ComputeVertexParameters = new_instancemethod(_IntPatch.IntPatch_WLine_ComputeVertexParameters, None, IntPatch_WLine)
IntPatch_WLine.Curve = new_instancemethod(_IntPatch.IntPatch_WLine_Curve, None, IntPatch_WLine)
IntPatch_WLine.IsOutSurf1Box = new_instancemethod(_IntPatch.IntPatch_WLine_IsOutSurf1Box, None, IntPatch_WLine)
IntPatch_WLine.IsOutSurf2Box = new_instancemethod(_IntPatch.IntPatch_WLine_IsOutSurf2Box, None, IntPatch_WLine)
IntPatch_WLine.IsOutBox = new_instancemethod(_IntPatch.IntPatch_WLine_IsOutBox, None, IntPatch_WLine)
IntPatch_WLine.SetPeriod = new_instancemethod(_IntPatch.IntPatch_WLine_SetPeriod, None, IntPatch_WLine)
IntPatch_WLine.U1Period = new_instancemethod(_IntPatch.IntPatch_WLine_U1Period, None, IntPatch_WLine)
IntPatch_WLine.V1Period = new_instancemethod(_IntPatch.IntPatch_WLine_V1Period, None, IntPatch_WLine)
IntPatch_WLine.U2Period = new_instancemethod(_IntPatch.IntPatch_WLine_U2Period, None, IntPatch_WLine)
IntPatch_WLine.V2Period = new_instancemethod(_IntPatch.IntPatch_WLine_V2Period, None, IntPatch_WLine)
IntPatch_WLine.SetArcOnS1 = new_instancemethod(_IntPatch.IntPatch_WLine_SetArcOnS1, None, IntPatch_WLine)
IntPatch_WLine.HasArcOnS1 = new_instancemethod(_IntPatch.IntPatch_WLine_HasArcOnS1, None, IntPatch_WLine)
IntPatch_WLine.GetArcOnS1 = new_instancemethod(_IntPatch.IntPatch_WLine_GetArcOnS1, None, IntPatch_WLine)
IntPatch_WLine.SetArcOnS2 = new_instancemethod(_IntPatch.IntPatch_WLine_SetArcOnS2, None, IntPatch_WLine)
IntPatch_WLine.HasArcOnS2 = new_instancemethod(_IntPatch.IntPatch_WLine_HasArcOnS2, None, IntPatch_WLine)
IntPatch_WLine.GetArcOnS2 = new_instancemethod(_IntPatch.IntPatch_WLine_GetArcOnS2, None, IntPatch_WLine)
IntPatch_WLine.Dump = new_instancemethod(_IntPatch.IntPatch_WLine_Dump, None, IntPatch_WLine)
IntPatch_WLine_swigregister = _IntPatch.IntPatch_WLine_swigregister
IntPatch_WLine_swigregister(IntPatch_WLine)

class Handle_IntPatch_WLine(Handle_IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.Handle_IntPatch_WLine_swiginit(self, _IntPatch.new_Handle_IntPatch_WLine(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_IntPatch.Handle_IntPatch_WLine_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_WLine
Handle_IntPatch_WLine.Nullify = new_instancemethod(_IntPatch.Handle_IntPatch_WLine_Nullify, None, Handle_IntPatch_WLine)
Handle_IntPatch_WLine.IsNull = new_instancemethod(_IntPatch.Handle_IntPatch_WLine_IsNull, None, Handle_IntPatch_WLine)
Handle_IntPatch_WLine._get_reference = new_instancemethod(_IntPatch.Handle_IntPatch_WLine__get_reference, None, Handle_IntPatch_WLine)
Handle_IntPatch_WLine_swigregister = _IntPatch.Handle_IntPatch_WLine_swigregister
Handle_IntPatch_WLine_swigregister(Handle_IntPatch_WLine)

def Handle_IntPatch_WLine_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_IntPatch_WLine const":
    return _IntPatch.Handle_IntPatch_WLine_DownCast(AnObject)
Handle_IntPatch_WLine_DownCast = _IntPatch.Handle_IntPatch_WLine_DownCast



