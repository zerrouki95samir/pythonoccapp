# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _StdPrs.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StdPrs')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StdPrs')
    _StdPrs = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StdPrs', [dirname(__file__)])
        except ImportError:
            import _StdPrs
            return _StdPrs
        try:
            _mod = imp.load_module('_StdPrs', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StdPrs = swig_import_helper()
    del swig_import_helper
else:
    import _StdPrs
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StdPrs.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_StdPrs.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_StdPrs.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_StdPrs.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_StdPrs.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_StdPrs.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_StdPrs.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_StdPrs.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_StdPrs.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_StdPrs.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_StdPrs.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_StdPrs.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_StdPrs.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_StdPrs.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_StdPrs.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_StdPrs.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_StdPrs.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _StdPrs.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.Prs3d
import OCC.Quantity
import OCC.Standard
import OCC.TCollection
import OCC.MMgt
import OCC.gp
import OCC.TopoDS
import OCC.TopLoc
import OCC.TopAbs
import OCC.Aspect
import OCC.TColStd
import OCC.Graphic3d
import OCC.Image
import OCC.NCollection
import OCC.Bnd
import OCC.OSD
import OCC.Geom
import OCC.GeomAbs
import OCC.TColgp
import OCC.HLRAlgo
import OCC.TopTools
import OCC.Message
import OCC.Poly
import OCC.TShort
import OCC.Adaptor3d
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.math
import OCC.BRepAdaptor
import OCC.GeomAdaptor
import OCC.Geom2dAdaptor

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

class StdPrs_Curve(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Adds to the presentation aPresentation the drawing of the curve aCurve. The aspect is defined by LineAspect in aDrawer. If drawCurve equals Standard_False the curve will not be displayed, it is used if the curve is a part of some shape and PrimitiveArray visualization approach is activated (it is activated by default).

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param drawCurve: default value is Standard_True
        :type drawCurve: bool
        :rtype: void

        * Adds to the presentation aPresentation the drawing of the curve aCurve. The aspect is defined by LineAspect in aDrawer. The drawing will be limited between the points of parameter U1 and U2. If drawCurve equals Standard_False the curve will not be displayed, it is used if the curve is a part of some shape and PrimitiveArray visualization approach is activated (it is activated by default).

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param U1:
        :type U1: float
        :param U2:
        :type U2: float
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param drawCurve: default value is Standard_True
        :type drawCurve: bool
        :rtype: void

        * adds to the presentation aPresentation the drawing of the curve aCurve. The aspect is the current aspect. aDeflection is used in the circle case. Points give a sequence of curve points. If drawCurve equals Standard_False the curve will not be displayed, it is used if the curve is a part of some shape and PrimitiveArray visualization approach is activated (it is activated by default).

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param aDeflection:
        :type aDeflection: Quantity_Length
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param Points:
        :type Points: TColgp_SequenceOfPnt
        :param drawCurve: default value is Standard_True
        :type drawCurve: bool
        :rtype: void

        * adds to the presentation aPresentation the drawing of the curve aCurve. The aspect is the current aspect. The drawing will be limited between the points of parameter U1 and U2. aDeflection is used in the circle case. Points give a sequence of curve points. If drawCurve equals Standard_False the curve will not be displayed, it is used if the curve is a part of some shape and PrimitiveArray visualization approach is activated (it is activated by default).

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param U1:
        :type U1: float
        :param U2:
        :type U2: float
        :param aDeflection:
        :type aDeflection: Quantity_Length
        :param Points:
        :type Points: TColgp_SequenceOfPnt
        :param aNbPoints: default value is 30
        :type aNbPoints: int
        :param drawCurve: default value is Standard_True
        :type drawCurve: bool
        :rtype: void

        """
        return _StdPrs.StdPrs_Curve_Add(*args)

    Add = staticmethod(Add)

    def Match(*args) -> "Standard_Boolean":
        """
        * returns true if the distance between the point (X,Y,Z) and the drawing of the curve is less than aDistance.

        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        * returns true if the distance between the point (X,Y,Z) and the drawing of the curve is less than aDistance.

        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param aDeflection:
        :type aDeflection: Quantity_Length
        :param aLimit:
        :type aLimit: float
        :param aNbPoints:
        :type aNbPoints: int
        :rtype: bool

        * returns true if the distance between the point (X,Y,Z) and the drawing of the curve aCurve is less than aDistance. The drawing is considered between the points of parameter U1 and U2;

        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param U1:
        :type U1: float
        :param U2:
        :type U2: float
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        * returns true if the distance between the point (X,Y,Z) and the drawing of the curve aCurve is less than aDistance. The drawing is considered between the points of parameter U1 and U2;

        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param U1:
        :type U1: float
        :param U2:
        :type U2: float
        :param aDeflection:
        :type aDeflection: Quantity_Length
        :param aNbPoints:
        :type aNbPoints: int
        :rtype: bool

        """
        return _StdPrs.StdPrs_Curve_Match(*args)

    Match = staticmethod(Match)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_Curve_swiginit(self, _StdPrs.new_StdPrs_Curve())
    __swig_destroy__ = _StdPrs.delete_StdPrs_Curve
StdPrs_Curve_swigregister = _StdPrs.StdPrs_Curve_swigregister
StdPrs_Curve_swigregister(StdPrs_Curve)

def StdPrs_Curve_Add(*args) -> "void":
    """
    * Adds to the presentation aPresentation the drawing of the curve aCurve. The aspect is defined by LineAspect in aDrawer. If drawCurve equals Standard_False the curve will not be displayed, it is used if the curve is a part of some shape and PrimitiveArray visualization approach is activated (it is activated by default).

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param drawCurve: default value is Standard_True
    :type drawCurve: bool
    :rtype: void

    * Adds to the presentation aPresentation the drawing of the curve aCurve. The aspect is defined by LineAspect in aDrawer. The drawing will be limited between the points of parameter U1 and U2. If drawCurve equals Standard_False the curve will not be displayed, it is used if the curve is a part of some shape and PrimitiveArray visualization approach is activated (it is activated by default).

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param U1:
    :type U1: float
    :param U2:
    :type U2: float
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param drawCurve: default value is Standard_True
    :type drawCurve: bool
    :rtype: void

    * adds to the presentation aPresentation the drawing of the curve aCurve. The aspect is the current aspect. aDeflection is used in the circle case. Points give a sequence of curve points. If drawCurve equals Standard_False the curve will not be displayed, it is used if the curve is a part of some shape and PrimitiveArray visualization approach is activated (it is activated by default).

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param aDeflection:
    :type aDeflection: Quantity_Length
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param Points:
    :type Points: TColgp_SequenceOfPnt
    :param drawCurve: default value is Standard_True
    :type drawCurve: bool
    :rtype: void

    * adds to the presentation aPresentation the drawing of the curve aCurve. The aspect is the current aspect. The drawing will be limited between the points of parameter U1 and U2. aDeflection is used in the circle case. Points give a sequence of curve points. If drawCurve equals Standard_False the curve will not be displayed, it is used if the curve is a part of some shape and PrimitiveArray visualization approach is activated (it is activated by default).

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param U1:
    :type U1: float
    :param U2:
    :type U2: float
    :param aDeflection:
    :type aDeflection: Quantity_Length
    :param Points:
    :type Points: TColgp_SequenceOfPnt
    :param aNbPoints: default value is 30
    :type aNbPoints: int
    :param drawCurve: default value is Standard_True
    :type drawCurve: bool
    :rtype: void

    """
    return _StdPrs.StdPrs_Curve_Add(*args)

def StdPrs_Curve_Match(*args) -> "Standard_Boolean":
    """
    * returns true if the distance between the point (X,Y,Z) and the drawing of the curve is less than aDistance.

    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    * returns true if the distance between the point (X,Y,Z) and the drawing of the curve is less than aDistance.

    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param aDeflection:
    :type aDeflection: Quantity_Length
    :param aLimit:
    :type aLimit: float
    :param aNbPoints:
    :type aNbPoints: int
    :rtype: bool

    * returns true if the distance between the point (X,Y,Z) and the drawing of the curve aCurve is less than aDistance. The drawing is considered between the points of parameter U1 and U2;

    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param U1:
    :type U1: float
    :param U2:
    :type U2: float
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    * returns true if the distance between the point (X,Y,Z) and the drawing of the curve aCurve is less than aDistance. The drawing is considered between the points of parameter U1 and U2;

    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param U1:
    :type U1: float
    :param U2:
    :type U2: float
    :param aDeflection:
    :type aDeflection: Quantity_Length
    :param aNbPoints:
    :type aNbPoints: int
    :rtype: bool

    """
    return _StdPrs.StdPrs_Curve_Match(*args)

class StdPrs_HLRPolyShape(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Defines the hidden line removal display of the topology aShape in the projection defined by aProjector. The shape and the projection are added to the display aPresentation, and the attributes of the elements present in the aPresentation are defined by the attribute manager aDrawer.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aShape:
        :type aShape: TopoDS_Shape &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param aProjector:
        :type aProjector: Handle_Prs3d_Projector &
        :rtype: void

        """
        return _StdPrs.StdPrs_HLRPolyShape_Add(*args)

    Add = staticmethod(Add)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_HLRPolyShape_swiginit(self, _StdPrs.new_StdPrs_HLRPolyShape())
    __swig_destroy__ = _StdPrs.delete_StdPrs_HLRPolyShape
StdPrs_HLRPolyShape_swigregister = _StdPrs.StdPrs_HLRPolyShape_swigregister
StdPrs_HLRPolyShape_swigregister(StdPrs_HLRPolyShape)

def StdPrs_HLRPolyShape_Add(*args) -> "void":
    """
    * Defines the hidden line removal display of the topology aShape in the projection defined by aProjector. The shape and the projection are added to the display aPresentation, and the attributes of the elements present in the aPresentation are defined by the attribute manager aDrawer.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aShape:
    :type aShape: TopoDS_Shape &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param aProjector:
    :type aProjector: Handle_Prs3d_Projector &
    :rtype: void

    """
    return _StdPrs.StdPrs_HLRPolyShape_Add(*args)

class StdPrs_HLRShape(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        :param thePresentation:
        :type thePresentation: Handle_Prs3d_Presentation &
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :param theProjector:
        :type theProjector: Handle_Prs3d_Projector &
        :rtype: void

        """
        return _StdPrs.StdPrs_HLRShape_Add(*args)

    Add = staticmethod(Add)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_HLRShape_swiginit(self, _StdPrs.new_StdPrs_HLRShape())
    __swig_destroy__ = _StdPrs.delete_StdPrs_HLRShape
StdPrs_HLRShape_swigregister = _StdPrs.StdPrs_HLRShape_swigregister
StdPrs_HLRShape_swigregister(StdPrs_HLRShape)

def StdPrs_HLRShape_Add(*args) -> "void":
    """
    :param thePresentation:
    :type thePresentation: Handle_Prs3d_Presentation &
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :param theProjector:
    :type theProjector: Handle_Prs3d_Projector &
    :rtype: void

    """
    return _StdPrs.StdPrs_HLRShape_Add(*args)

class StdPrs_HLRToolShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param TheShape:
        :type TheShape: TopoDS_Shape &
        :param TheProjector:
        :type TheProjector: HLRAlgo_Projector &
        :rtype: None

        """
        _StdPrs.StdPrs_HLRToolShape_swiginit(self, _StdPrs.new_StdPrs_HLRToolShape(*args))

    def NbEdges(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _StdPrs.StdPrs_HLRToolShape_NbEdges(self, *args)


    def InitVisible(self, *args) -> "void":
        """
        :param EdgeNumber:
        :type EdgeNumber: int
        :rtype: None

        """
        return _StdPrs.StdPrs_HLRToolShape_InitVisible(self, *args)


    def MoreVisible(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _StdPrs.StdPrs_HLRToolShape_MoreVisible(self, *args)


    def NextVisible(self, *args) -> "void":
        """
        :rtype: None

        """
        return _StdPrs.StdPrs_HLRToolShape_NextVisible(self, *args)


    def Visible(self, *args) -> "void":
        """
        :param TheEdge:
        :type TheEdge: BRepAdaptor_Curve &
        :param U1:
        :type U1: float &
        :param U2:
        :type U2: float &
        :rtype: None

        """
        return _StdPrs.StdPrs_HLRToolShape_Visible(self, *args)


    def InitHidden(self, *args) -> "void":
        """
        :param EdgeNumber:
        :type EdgeNumber: int
        :rtype: None

        """
        return _StdPrs.StdPrs_HLRToolShape_InitHidden(self, *args)


    def MoreHidden(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _StdPrs.StdPrs_HLRToolShape_MoreHidden(self, *args)


    def NextHidden(self, *args) -> "void":
        """
        :rtype: None

        """
        return _StdPrs.StdPrs_HLRToolShape_NextHidden(self, *args)


    def Hidden(self, *args) -> "void":
        """
        :param TheEdge:
        :type TheEdge: BRepAdaptor_Curve &
        :param U1:
        :type U1: float &
        :param U2:
        :type U2: float &
        :rtype: None

        """
        return _StdPrs.StdPrs_HLRToolShape_Hidden(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _StdPrs.delete_StdPrs_HLRToolShape
StdPrs_HLRToolShape.NbEdges = new_instancemethod(_StdPrs.StdPrs_HLRToolShape_NbEdges, None, StdPrs_HLRToolShape)
StdPrs_HLRToolShape.InitVisible = new_instancemethod(_StdPrs.StdPrs_HLRToolShape_InitVisible, None, StdPrs_HLRToolShape)
StdPrs_HLRToolShape.MoreVisible = new_instancemethod(_StdPrs.StdPrs_HLRToolShape_MoreVisible, None, StdPrs_HLRToolShape)
StdPrs_HLRToolShape.NextVisible = new_instancemethod(_StdPrs.StdPrs_HLRToolShape_NextVisible, None, StdPrs_HLRToolShape)
StdPrs_HLRToolShape.Visible = new_instancemethod(_StdPrs.StdPrs_HLRToolShape_Visible, None, StdPrs_HLRToolShape)
StdPrs_HLRToolShape.InitHidden = new_instancemethod(_StdPrs.StdPrs_HLRToolShape_InitHidden, None, StdPrs_HLRToolShape)
StdPrs_HLRToolShape.MoreHidden = new_instancemethod(_StdPrs.StdPrs_HLRToolShape_MoreHidden, None, StdPrs_HLRToolShape)
StdPrs_HLRToolShape.NextHidden = new_instancemethod(_StdPrs.StdPrs_HLRToolShape_NextHidden, None, StdPrs_HLRToolShape)
StdPrs_HLRToolShape.Hidden = new_instancemethod(_StdPrs.StdPrs_HLRToolShape_Hidden, None, StdPrs_HLRToolShape)
StdPrs_HLRToolShape_swigregister = _StdPrs.StdPrs_HLRToolShape_swigregister
StdPrs_HLRToolShape_swigregister(StdPrs_HLRToolShape)

class StdPrs_Plane(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Defines display of infinite planes. The infinite plane aPlane is added to the display aPresentation, and the attributes of the display are defined by the attribute manager aDrawer.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aPlane:
        :type aPlane: Adaptor3d_Surface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_Plane_Add(*args)

    Add = staticmethod(Add)

    def Match(*args) -> "Standard_Boolean":
        """
        * returns true if the distance between the point (X,Y,Z) and the plane is less than aDistance.

        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aPlane:
        :type aPlane: Adaptor3d_Surface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        """
        return _StdPrs.StdPrs_Plane_Match(*args)

    Match = staticmethod(Match)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_Plane_swiginit(self, _StdPrs.new_StdPrs_Plane())
    __swig_destroy__ = _StdPrs.delete_StdPrs_Plane
StdPrs_Plane_swigregister = _StdPrs.StdPrs_Plane_swigregister
StdPrs_Plane_swigregister(StdPrs_Plane)

def StdPrs_Plane_Add(*args) -> "void":
    """
    * Defines display of infinite planes. The infinite plane aPlane is added to the display aPresentation, and the attributes of the display are defined by the attribute manager aDrawer.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aPlane:
    :type aPlane: Adaptor3d_Surface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_Plane_Add(*args)

def StdPrs_Plane_Match(*args) -> "Standard_Boolean":
    """
    * returns true if the distance between the point (X,Y,Z) and the plane is less than aDistance.

    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aPlane:
    :type aPlane: Adaptor3d_Surface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    """
    return _StdPrs.StdPrs_Plane_Match(*args)

class StdPrs_PoleCurve(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Defines display of BSpline and Bezier curves. Adds the 3D curve aCurve to the StdPrs_PoleCurve algorithm. This shape is found in the presentation object aPresentation, and its display attributes are set in the attribute manager aDrawer. The curve object from Adaptor3d provides data from a Geom curve. This makes it possible to use the surface in a geometric algorithm.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_PoleCurve_Add(*args)

    Add = staticmethod(Add)

    def Match(*args) -> "Standard_Boolean":
        """
        * returns true if the distance between the point (X,Y,Z) and the broken line made of the poles is less then aDistance.

        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        """
        return _StdPrs.StdPrs_PoleCurve_Match(*args)

    Match = staticmethod(Match)

    def Pick(*args) -> "Standard_Integer":
        """
        * returns the pole the most near of the point (X,Y,Z) and returns its range. The distance between the pole and (X,Y,Z) must be less then aDistance. If no pole corresponds, 0 is returned.

        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aCurve:
        :type aCurve: Adaptor3d_Curve &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: int

        """
        return _StdPrs.StdPrs_PoleCurve_Pick(*args)

    Pick = staticmethod(Pick)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_PoleCurve_swiginit(self, _StdPrs.new_StdPrs_PoleCurve())
    __swig_destroy__ = _StdPrs.delete_StdPrs_PoleCurve
StdPrs_PoleCurve_swigregister = _StdPrs.StdPrs_PoleCurve_swigregister
StdPrs_PoleCurve_swigregister(StdPrs_PoleCurve)

def StdPrs_PoleCurve_Add(*args) -> "void":
    """
    * Defines display of BSpline and Bezier curves. Adds the 3D curve aCurve to the StdPrs_PoleCurve algorithm. This shape is found in the presentation object aPresentation, and its display attributes are set in the attribute manager aDrawer. The curve object from Adaptor3d provides data from a Geom curve. This makes it possible to use the surface in a geometric algorithm.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_PoleCurve_Add(*args)

def StdPrs_PoleCurve_Match(*args) -> "Standard_Boolean":
    """
    * returns true if the distance between the point (X,Y,Z) and the broken line made of the poles is less then aDistance.

    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    """
    return _StdPrs.StdPrs_PoleCurve_Match(*args)

def StdPrs_PoleCurve_Pick(*args) -> "Standard_Integer":
    """
    * returns the pole the most near of the point (X,Y,Z) and returns its range. The distance between the pole and (X,Y,Z) must be less then aDistance. If no pole corresponds, 0 is returned.

    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aCurve:
    :type aCurve: Adaptor3d_Curve &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: int

    """
    return _StdPrs.StdPrs_PoleCurve_Pick(*args)

class StdPrs_ShadedShape(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Shades <theShape>. @param theToExploreSolids when set to true, explodes compound into two groups - with closed Solids and open Shells

        :param thePresentation:
        :type thePresentation: Handle_Prs3d_Presentation &
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :param theToExploreSolids: default value is Standard_True
        :type theToExploreSolids: bool
        :rtype: void

        * Shades <theShape> with texture coordinates. @param theToExploreSolids when set to true, explodes compound into two groups - with closed Solids and open Shells

        :param thePresentation:
        :type thePresentation: Handle_Prs3d_Presentation &
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :param theHasTexels:
        :type theHasTexels: bool
        :param theUVOrigin:
        :type theUVOrigin: gp_Pnt2d
        :param theUVRepeat:
        :type theUVRepeat: gp_Pnt2d
        :param theUVScale:
        :type theUVScale: gp_Pnt2d
        :param theToExploreSolids: default value is Standard_True
        :type theToExploreSolids: bool
        :rtype: void

        """
        return _StdPrs.StdPrs_ShadedShape_Add(*args)

    Add = staticmethod(Add)

    def Tessellate(*args) -> "void":
        """
        * Validates triangulation within the shape and performs tessellation if necessary.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_ShadedShape_Tessellate(*args)

    Tessellate = staticmethod(Tessellate)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_ShadedShape_swiginit(self, _StdPrs.new_StdPrs_ShadedShape())
    __swig_destroy__ = _StdPrs.delete_StdPrs_ShadedShape
StdPrs_ShadedShape_swigregister = _StdPrs.StdPrs_ShadedShape_swigregister
StdPrs_ShadedShape_swigregister(StdPrs_ShadedShape)

def StdPrs_ShadedShape_Add(*args) -> "void":
    """
    * Shades <theShape>. @param theToExploreSolids when set to true, explodes compound into two groups - with closed Solids and open Shells

    :param thePresentation:
    :type thePresentation: Handle_Prs3d_Presentation &
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :param theToExploreSolids: default value is Standard_True
    :type theToExploreSolids: bool
    :rtype: void

    * Shades <theShape> with texture coordinates. @param theToExploreSolids when set to true, explodes compound into two groups - with closed Solids and open Shells

    :param thePresentation:
    :type thePresentation: Handle_Prs3d_Presentation &
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :param theHasTexels:
    :type theHasTexels: bool
    :param theUVOrigin:
    :type theUVOrigin: gp_Pnt2d
    :param theUVRepeat:
    :type theUVRepeat: gp_Pnt2d
    :param theUVScale:
    :type theUVScale: gp_Pnt2d
    :param theToExploreSolids: default value is Standard_True
    :type theToExploreSolids: bool
    :rtype: void

    """
    return _StdPrs.StdPrs_ShadedShape_Add(*args)

def StdPrs_ShadedShape_Tessellate(*args) -> "void":
    """
    * Validates triangulation within the shape and performs tessellation if necessary.

    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_ShadedShape_Tessellate(*args)

class StdPrs_ShadedSurface(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Adds the surface aSurface to the presentation object aPresentation. The surface's display attributes are set in the attribute manager aDrawer. The surface object from Adaptor3d provides data from a Geom surface in order to use the surface in an algorithm.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aSurface:
        :type aSurface: Adaptor3d_Surface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_ShadedSurface_Add(*args)

    Add = staticmethod(Add)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_ShadedSurface_swiginit(self, _StdPrs.new_StdPrs_ShadedSurface())
    __swig_destroy__ = _StdPrs.delete_StdPrs_ShadedSurface
StdPrs_ShadedSurface_swigregister = _StdPrs.StdPrs_ShadedSurface_swigregister
StdPrs_ShadedSurface_swigregister(StdPrs_ShadedSurface)

def StdPrs_ShadedSurface_Add(*args) -> "void":
    """
    * Adds the surface aSurface to the presentation object aPresentation. The surface's display attributes are set in the attribute manager aDrawer. The surface object from Adaptor3d provides data from a Geom surface in order to use the surface in an algorithm.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aSurface:
    :type aSurface: Adaptor3d_Surface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_ShadedSurface_Add(*args)

class StdPrs_ToolPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Coord(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        :param aPoint:
        :type aPoint: Handle_Geom_Point &
        :param X:
        :type X: Quantity_Length &
        :param Y:
        :type Y: Quantity_Length &
        :param Z:
        :type Z: Quantity_Length &
        :rtype: void

        """
        return _StdPrs.StdPrs_ToolPoint_Coord(*args)

    Coord = staticmethod(Coord)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_ToolPoint_swiginit(self, _StdPrs.new_StdPrs_ToolPoint())
    __swig_destroy__ = _StdPrs.delete_StdPrs_ToolPoint
StdPrs_ToolPoint_swigregister = _StdPrs.StdPrs_ToolPoint_swigregister
StdPrs_ToolPoint_swigregister(StdPrs_ToolPoint)

def StdPrs_ToolPoint_Coord(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    :param aPoint:
    :type aPoint: Handle_Geom_Point &
    :param X:
    :type X: Quantity_Length &
    :param Y:
    :type Y: Quantity_Length &
    :param Z:
    :type Z: Quantity_Length &
    :rtype: void

    """
    return _StdPrs.StdPrs_ToolPoint_Coord(*args)

class StdPrs_ToolRFace(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param aSurface:
        :type aSurface: Handle_BRepAdaptor_HSurface &
        :rtype: None

        """
        _StdPrs.StdPrs_ToolRFace_swiginit(self, _StdPrs.new_StdPrs_ToolRFace(*args))

    def IsOriented(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _StdPrs.StdPrs_ToolRFace_IsOriented(self, *args)


    def Init(self, *args) -> "void":
        """
        :rtype: None

        """
        return _StdPrs.StdPrs_ToolRFace_Init(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _StdPrs.StdPrs_ToolRFace_More(self, *args)


    def Next(self, *args) -> "void":
        """
        :rtype: None

        """
        return _StdPrs.StdPrs_ToolRFace_Next(self, *args)


    def Value(self, *args) -> "Adaptor2d_Curve2dPtr":
        """
        :rtype: Adaptor2d_Curve2dPtr

        """
        return _StdPrs.StdPrs_ToolRFace_Value(self, *args)


    def Orientation(self, *args) -> "TopAbs_Orientation":
        """
        :rtype: TopAbs_Orientation

        """
        return _StdPrs.StdPrs_ToolRFace_Orientation(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _StdPrs.delete_StdPrs_ToolRFace
StdPrs_ToolRFace.IsOriented = new_instancemethod(_StdPrs.StdPrs_ToolRFace_IsOriented, None, StdPrs_ToolRFace)
StdPrs_ToolRFace.Init = new_instancemethod(_StdPrs.StdPrs_ToolRFace_Init, None, StdPrs_ToolRFace)
StdPrs_ToolRFace.More = new_instancemethod(_StdPrs.StdPrs_ToolRFace_More, None, StdPrs_ToolRFace)
StdPrs_ToolRFace.Next = new_instancemethod(_StdPrs.StdPrs_ToolRFace_Next, None, StdPrs_ToolRFace)
StdPrs_ToolRFace.Value = new_instancemethod(_StdPrs.StdPrs_ToolRFace_Value, None, StdPrs_ToolRFace)
StdPrs_ToolRFace.Orientation = new_instancemethod(_StdPrs.StdPrs_ToolRFace_Orientation, None, StdPrs_ToolRFace)
StdPrs_ToolRFace_swigregister = _StdPrs.StdPrs_ToolRFace_swigregister
StdPrs_ToolRFace_swigregister(StdPrs_ToolRFace)

class StdPrs_ToolShadedShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsTriangulated(*args) -> "Standard_Boolean":
        """
        * Similar to BRepTools::Triangulation() but without extra checks. returns true if all faces within shape are triangulated.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: bool

        """
        return _StdPrs.StdPrs_ToolShadedShape_IsTriangulated(*args)

    IsTriangulated = staticmethod(IsTriangulated)

    def IsClosed(*args) -> "Standard_Boolean":
        """
        * Checks back faces visibility for specified shape (to activate back-face culling). returns true if shape is closed manifold Solid or compound of such Solids.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: bool

        """
        return _StdPrs.StdPrs_ToolShadedShape_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def Triangulation(*args) -> "Handle_Poly_Triangulation":
        """
        :param aFace:
        :type aFace: TopoDS_Face &
        :param loc:
        :type loc: TopLoc_Location &
        :rtype: Handle_Poly_Triangulation

        """
        return _StdPrs.StdPrs_ToolShadedShape_Triangulation(*args)

    Triangulation = staticmethod(Triangulation)

    def Normal(*args) -> "void":
        """
        :param aFace:
        :type aFace: TopoDS_Face &
        :param PC:
        :type PC: Poly_Connect &
        :param Nor:
        :type Nor: TColgp_Array1OfDir
        :rtype: void

        """
        return _StdPrs.StdPrs_ToolShadedShape_Normal(*args)

    Normal = staticmethod(Normal)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_ToolShadedShape_swiginit(self, _StdPrs.new_StdPrs_ToolShadedShape())
    __swig_destroy__ = _StdPrs.delete_StdPrs_ToolShadedShape
StdPrs_ToolShadedShape_swigregister = _StdPrs.StdPrs_ToolShadedShape_swigregister
StdPrs_ToolShadedShape_swigregister(StdPrs_ToolShadedShape)

def StdPrs_ToolShadedShape_IsTriangulated(*args) -> "Standard_Boolean":
    """
    * Similar to BRepTools::Triangulation() but without extra checks. returns true if all faces within shape are triangulated.

    :param theShape:
    :type theShape: TopoDS_Shape &
    :rtype: bool

    """
    return _StdPrs.StdPrs_ToolShadedShape_IsTriangulated(*args)

def StdPrs_ToolShadedShape_IsClosed(*args) -> "Standard_Boolean":
    """
    * Checks back faces visibility for specified shape (to activate back-face culling). returns true if shape is closed manifold Solid or compound of such Solids.

    :param theShape:
    :type theShape: TopoDS_Shape &
    :rtype: bool

    """
    return _StdPrs.StdPrs_ToolShadedShape_IsClosed(*args)

def StdPrs_ToolShadedShape_Triangulation(*args) -> "Handle_Poly_Triangulation":
    """
    :param aFace:
    :type aFace: TopoDS_Face &
    :param loc:
    :type loc: TopLoc_Location &
    :rtype: Handle_Poly_Triangulation

    """
    return _StdPrs.StdPrs_ToolShadedShape_Triangulation(*args)

def StdPrs_ToolShadedShape_Normal(*args) -> "void":
    """
    :param aFace:
    :type aFace: TopoDS_Face &
    :param PC:
    :type PC: Poly_Connect &
    :param Nor:
    :type Nor: TColgp_Array1OfDir
    :rtype: void

    """
    return _StdPrs.StdPrs_ToolShadedShape_Normal(*args)

class StdPrs_ToolVertex(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Coord(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        :param aPoint:
        :type aPoint: TopoDS_Vertex &
        :param X:
        :type X: Quantity_Length &
        :param Y:
        :type Y: Quantity_Length &
        :param Z:
        :type Z: Quantity_Length &
        :rtype: void

        """
        return _StdPrs.StdPrs_ToolVertex_Coord(*args)

    Coord = staticmethod(Coord)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_ToolVertex_swiginit(self, _StdPrs.new_StdPrs_ToolVertex())
    __swig_destroy__ = _StdPrs.delete_StdPrs_ToolVertex
StdPrs_ToolVertex_swigregister = _StdPrs.StdPrs_ToolVertex_swigregister
StdPrs_ToolVertex_swigregister(StdPrs_ToolVertex)

def StdPrs_ToolVertex_Coord(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    :param aPoint:
    :type aPoint: TopoDS_Vertex &
    :param X:
    :type X: Quantity_Length &
    :param Y:
    :type Y: Quantity_Length &
    :param Z:
    :type Z: Quantity_Length &
    :rtype: void

    """
    return _StdPrs.StdPrs_ToolVertex_Coord(*args)

class StdPrs_WFDeflectionRestrictedFace(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddUIso(*args) -> "void":
        """
        * Defines a display featuring U isoparameters respectively. Add the surface aFace to the StdPrs_WFRestrictedFace algorithm. This face is found in a shape in the presentation object aPresentation, and its display attributes - in particular, the number of U isoparameters - are set in the attribute manager aDrawer. aFace is BRepAdaptor_HSurface surface created from a face in a topological shape. which is passed to the function as an argument through the BRepAdaptor_HSurface surface created from it. This is what allows the topological face to be treated as a geometric surface.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aFace:
        :type aFace: Handle_BRepAdaptor_HSurface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddUIso(*args)

    AddUIso = staticmethod(AddUIso)

    def AddVIso(*args) -> "void":
        """
        * Defines a display featuring V isoparameters respectively. Add the surface aFace to the StdPrs_WFRestrictedFace algorithm. This face is found in a shape in the presentation object aPresentation, and its display attributes - in particular, the number of V isoparameters - are set in the attribute manager aDrawer. aFace is BRepAdaptor_HSurface surface created from a face in a topological shape. which is passed to the function as an argument through the BRepAdaptor_HSurface surface created from it. This is what allows the topological face to be treated as a geometric surface.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aFace:
        :type aFace: Handle_BRepAdaptor_HSurface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddVIso(*args)

    AddVIso = staticmethod(AddVIso)

    def Add(*args) -> "void":
        """
        * Defines a display featuring U and V isoparameters. Adds the surface aFace to the StdPrs_WFRestrictedFace algorithm. This face is found in a shape in the presentation object aPresentation, and its display attributes - in particular, the number of U and V isoparameters - are set in the attribute manager aDrawer. aFace is BRepAdaptor_HSurface surface created from a face in a topological shape. which is passed as an argument through the BRepAdaptor_HSurface surface created from it. This is what allows the topological face to be treated as a geometric surface.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aFace:
        :type aFace: Handle_BRepAdaptor_HSurface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        * Defines a display of a delection-specified face. The display will feature U and V isoparameters. Adds the topology aShape to the StdPrs_WFRestrictedFace algorithm. This shape is found in the presentation object aPresentation, and its display attributes - except the number of U and V isoparameters - are set in the attribute manager aDrawer. The function sets the number of U and V isoparameters, NBUiso and NBViso, in the shape. To do this, the arguments DrawUIso and DrawVIso must be true. aFace is BRepAdaptor_HSurface surface created from a face in a topological shape. which is passed as an argument through the BRepAdaptor_HSurface surface created from it. This is what allows the topological face to be treated as a geometric surface. Curves give a sequence of face curves, it is used if the PrimitiveArray visualization approach is activated (it is activated by default).

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aFace:
        :type aFace: Handle_BRepAdaptor_HSurface &
        :param DrawUIso:
        :type DrawUIso: bool
        :param DrawVIso:
        :type DrawVIso: bool
        :param Deflection:
        :type Deflection: Quantity_Length
        :param NBUiso:
        :type NBUiso: int
        :param NBViso:
        :type NBViso: int
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param Curves:
        :type Curves: Prs3d_NListOfSequenceOfPnt &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_Add(*args)

    Add = staticmethod(Add)

    def AddBox(*args) -> "void":
        """
        * Adds box as polyline to the presentation object

        :param thePrs:
        :type thePrs: Handle_Prs3d_Presentation &
        :param theBndBox:
        :type theBndBox: Bnd_Box &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddBox(*args)

    AddBox = staticmethod(AddBox)

    def MatchUIso(*args) -> "Standard_Boolean":
        """
        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aFace:
        :type aFace: Handle_BRepAdaptor_HSurface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_MatchUIso(*args)

    MatchUIso = staticmethod(MatchUIso)

    def MatchVIso(*args) -> "Standard_Boolean":
        """
        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aFace:
        :type aFace: Handle_BRepAdaptor_HSurface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_MatchVIso(*args)

    MatchVIso = staticmethod(MatchVIso)

    def Match(*args) -> "Standard_Boolean":
        """
        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aFace:
        :type aFace: Handle_BRepAdaptor_HSurface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        :param X:
        :type X: Quantity_Length
        :param Y:
        :type Y: Quantity_Length
        :param Z:
        :type Z: Quantity_Length
        :param aDistance:
        :type aDistance: Quantity_Length
        :param aFace:
        :type aFace: Handle_BRepAdaptor_HSurface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :param DrawUIso:
        :type DrawUIso: bool
        :param DrawVIso:
        :type DrawVIso: bool
        :param aDeflection:
        :type aDeflection: Quantity_Length
        :param NBUiso:
        :type NBUiso: int
        :param NBViso:
        :type NBViso: int
        :rtype: bool

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_Match(*args)

    Match = staticmethod(Match)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_WFDeflectionRestrictedFace_swiginit(self, _StdPrs.new_StdPrs_WFDeflectionRestrictedFace())
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFDeflectionRestrictedFace
StdPrs_WFDeflectionRestrictedFace_swigregister = _StdPrs.StdPrs_WFDeflectionRestrictedFace_swigregister
StdPrs_WFDeflectionRestrictedFace_swigregister(StdPrs_WFDeflectionRestrictedFace)

def StdPrs_WFDeflectionRestrictedFace_AddUIso(*args) -> "void":
    """
    * Defines a display featuring U isoparameters respectively. Add the surface aFace to the StdPrs_WFRestrictedFace algorithm. This face is found in a shape in the presentation object aPresentation, and its display attributes - in particular, the number of U isoparameters - are set in the attribute manager aDrawer. aFace is BRepAdaptor_HSurface surface created from a face in a topological shape. which is passed to the function as an argument through the BRepAdaptor_HSurface surface created from it. This is what allows the topological face to be treated as a geometric surface.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aFace:
    :type aFace: Handle_BRepAdaptor_HSurface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddUIso(*args)

def StdPrs_WFDeflectionRestrictedFace_AddVIso(*args) -> "void":
    """
    * Defines a display featuring V isoparameters respectively. Add the surface aFace to the StdPrs_WFRestrictedFace algorithm. This face is found in a shape in the presentation object aPresentation, and its display attributes - in particular, the number of V isoparameters - are set in the attribute manager aDrawer. aFace is BRepAdaptor_HSurface surface created from a face in a topological shape. which is passed to the function as an argument through the BRepAdaptor_HSurface surface created from it. This is what allows the topological face to be treated as a geometric surface.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aFace:
    :type aFace: Handle_BRepAdaptor_HSurface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddVIso(*args)

def StdPrs_WFDeflectionRestrictedFace_Add(*args) -> "void":
    """
    * Defines a display featuring U and V isoparameters. Adds the surface aFace to the StdPrs_WFRestrictedFace algorithm. This face is found in a shape in the presentation object aPresentation, and its display attributes - in particular, the number of U and V isoparameters - are set in the attribute manager aDrawer. aFace is BRepAdaptor_HSurface surface created from a face in a topological shape. which is passed as an argument through the BRepAdaptor_HSurface surface created from it. This is what allows the topological face to be treated as a geometric surface.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aFace:
    :type aFace: Handle_BRepAdaptor_HSurface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    * Defines a display of a delection-specified face. The display will feature U and V isoparameters. Adds the topology aShape to the StdPrs_WFRestrictedFace algorithm. This shape is found in the presentation object aPresentation, and its display attributes - except the number of U and V isoparameters - are set in the attribute manager aDrawer. The function sets the number of U and V isoparameters, NBUiso and NBViso, in the shape. To do this, the arguments DrawUIso and DrawVIso must be true. aFace is BRepAdaptor_HSurface surface created from a face in a topological shape. which is passed as an argument through the BRepAdaptor_HSurface surface created from it. This is what allows the topological face to be treated as a geometric surface. Curves give a sequence of face curves, it is used if the PrimitiveArray visualization approach is activated (it is activated by default).

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aFace:
    :type aFace: Handle_BRepAdaptor_HSurface &
    :param DrawUIso:
    :type DrawUIso: bool
    :param DrawVIso:
    :type DrawVIso: bool
    :param Deflection:
    :type Deflection: Quantity_Length
    :param NBUiso:
    :type NBUiso: int
    :param NBViso:
    :type NBViso: int
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param Curves:
    :type Curves: Prs3d_NListOfSequenceOfPnt &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_Add(*args)

def StdPrs_WFDeflectionRestrictedFace_AddBox(*args) -> "void":
    """
    * Adds box as polyline to the presentation object

    :param thePrs:
    :type thePrs: Handle_Prs3d_Presentation &
    :param theBndBox:
    :type theBndBox: Bnd_Box &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddBox(*args)

def StdPrs_WFDeflectionRestrictedFace_MatchUIso(*args) -> "Standard_Boolean":
    """
    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aFace:
    :type aFace: Handle_BRepAdaptor_HSurface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_MatchUIso(*args)

def StdPrs_WFDeflectionRestrictedFace_MatchVIso(*args) -> "Standard_Boolean":
    """
    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aFace:
    :type aFace: Handle_BRepAdaptor_HSurface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_MatchVIso(*args)

def StdPrs_WFDeflectionRestrictedFace_Match(*args) -> "Standard_Boolean":
    """
    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aFace:
    :type aFace: Handle_BRepAdaptor_HSurface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    :param X:
    :type X: Quantity_Length
    :param Y:
    :type Y: Quantity_Length
    :param Z:
    :type Z: Quantity_Length
    :param aDistance:
    :type aDistance: Quantity_Length
    :param aFace:
    :type aFace: Handle_BRepAdaptor_HSurface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :param DrawUIso:
    :type DrawUIso: bool
    :param DrawVIso:
    :type DrawVIso: bool
    :param aDeflection:
    :type aDeflection: Quantity_Length
    :param NBUiso:
    :type NBUiso: int
    :param NBViso:
    :type NBViso: int
    :rtype: bool

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_Match(*args)

class StdPrs_WFDeflectionShape(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Add shape to presentation

        :param thePrs:
        :type thePrs: Handle_Prs3d_Presentation &
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: inline void

        """
        return _StdPrs.StdPrs_WFDeflectionShape_Add(*args)

    Add = staticmethod(Add)

    def PickCurve(*args) -> "Handle_TopTools_HSequenceOfShape":
        """
        :param theX:
        :type theX: Quantity_Length
        :param theY:
        :type theY: Quantity_Length
        :param theZ:
        :type theZ: Quantity_Length
        :param theDistance:
        :type theDistance: Quantity_Length
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: inline Handle_TopTools_HSequenceOfShape

        """
        return _StdPrs.StdPrs_WFDeflectionShape_PickCurve(*args)

    PickCurve = staticmethod(PickCurve)

    def PickPatch(*args) -> "Handle_TopTools_HSequenceOfShape":
        """
        :param theX:
        :type theX: Quantity_Length
        :param theY:
        :type theY: Quantity_Length
        :param theZ:
        :type theZ: Quantity_Length
        :param theDistance:
        :type theDistance: Quantity_Length
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: inline Handle_TopTools_HSequenceOfShape

        """
        return _StdPrs.StdPrs_WFDeflectionShape_PickPatch(*args)

    PickPatch = staticmethod(PickPatch)

    __repr__ = _dumps_object

    __swig_destroy__ = _StdPrs.delete_StdPrs_WFDeflectionShape
StdPrs_WFDeflectionShape_swigregister = _StdPrs.StdPrs_WFDeflectionShape_swigregister
StdPrs_WFDeflectionShape_swigregister(StdPrs_WFDeflectionShape)

def StdPrs_WFDeflectionShape_Add(*args) -> "void":
    """
    * Add shape to presentation

    :param thePrs:
    :type thePrs: Handle_Prs3d_Presentation &
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: inline void

    """
    return _StdPrs.StdPrs_WFDeflectionShape_Add(*args)

def StdPrs_WFDeflectionShape_PickCurve(*args) -> "Handle_TopTools_HSequenceOfShape":
    """
    :param theX:
    :type theX: Quantity_Length
    :param theY:
    :type theY: Quantity_Length
    :param theZ:
    :type theZ: Quantity_Length
    :param theDistance:
    :type theDistance: Quantity_Length
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: inline Handle_TopTools_HSequenceOfShape

    """
    return _StdPrs.StdPrs_WFDeflectionShape_PickCurve(*args)

def StdPrs_WFDeflectionShape_PickPatch(*args) -> "Handle_TopTools_HSequenceOfShape":
    """
    :param theX:
    :type theX: Quantity_Length
    :param theY:
    :type theY: Quantity_Length
    :param theZ:
    :type theZ: Quantity_Length
    :param theDistance:
    :type theDistance: Quantity_Length
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: inline Handle_TopTools_HSequenceOfShape

    """
    return _StdPrs.StdPrs_WFDeflectionShape_PickPatch(*args)

class StdPrs_WFDeflectionSurface(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Adds the surface aSurface to the presentation object aPresentation, and defines its boundaries and isoparameters. The shape's display attributes are set in the attribute manager aDrawer. These include whether deflection is absolute or relative to the size of the shape. The surface aSurface is a surface object from Adaptor, and provides data from a Geom surface. This makes it possible to use the surface in a geometric algorithm. Note that this surface object is manipulated by handles.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aSurface:
        :type aSurface: Handle_Adaptor3d_HSurface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFDeflectionSurface_Add(*args)

    Add = staticmethod(Add)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_WFDeflectionSurface_swiginit(self, _StdPrs.new_StdPrs_WFDeflectionSurface())
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFDeflectionSurface
StdPrs_WFDeflectionSurface_swigregister = _StdPrs.StdPrs_WFDeflectionSurface_swigregister
StdPrs_WFDeflectionSurface_swigregister(StdPrs_WFDeflectionSurface)

def StdPrs_WFDeflectionSurface_Add(*args) -> "void":
    """
    * Adds the surface aSurface to the presentation object aPresentation, and defines its boundaries and isoparameters. The shape's display attributes are set in the attribute manager aDrawer. These include whether deflection is absolute or relative to the size of the shape. The surface aSurface is a surface object from Adaptor, and provides data from a Geom surface. This makes it possible to use the surface in a geometric algorithm. Note that this surface object is manipulated by handles.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aSurface:
    :type aSurface: Handle_Adaptor3d_HSurface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFDeflectionSurface_Add(*args)

class StdPrs_WFPoleSurface(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Adds the surface aSurface to the presentation object aPresentation. The shape's display attributes are set in the attribute manager aDrawer. The surface aSurface is a surface object from Adaptor3d, and provides data from a Geom surface. This makes it possible to use the surface in a geometric algorithm.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aSurface:
        :type aSurface: Adaptor3d_Surface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFPoleSurface_Add(*args)

    Add = staticmethod(Add)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_WFPoleSurface_swiginit(self, _StdPrs.new_StdPrs_WFPoleSurface())
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFPoleSurface
StdPrs_WFPoleSurface_swigregister = _StdPrs.StdPrs_WFPoleSurface_swigregister
StdPrs_WFPoleSurface_swigregister(StdPrs_WFPoleSurface)

def StdPrs_WFPoleSurface_Add(*args) -> "void":
    """
    * Adds the surface aSurface to the presentation object aPresentation. The shape's display attributes are set in the attribute manager aDrawer. The surface aSurface is a surface object from Adaptor3d, and provides data from a Geom surface. This makes it possible to use the surface in a geometric algorithm.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aSurface:
    :type aSurface: Adaptor3d_Surface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFPoleSurface_Add(*args)

class StdPrs_WFRestrictedFace(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        :param thePresentation:
        :type thePresentation: Handle_Prs3d_Presentation &
        :param theFace:
        :type theFace: Handle_BRepAdaptor_HSurface &
        :param theDrawUIso:
        :type theDrawUIso: bool
        :param theDrawVIso:
        :type theDrawVIso: bool
        :param theDeflection:
        :type theDeflection: Quantity_Length
        :param theNbUIso:
        :type theNbUIso: int
        :param theNbVIso:
        :type theNbVIso: int
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :param theCurves:
        :type theCurves: Prs3d_NListOfSequenceOfPnt &
        :rtype: void

        :param thePresentation:
        :type thePresentation: Handle_Prs3d_Presentation &
        :param theFace:
        :type theFace: Handle_BRepAdaptor_HSurface &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFRestrictedFace_Add(*args)

    Add = staticmethod(Add)

    def Match(*args) -> "Standard_Boolean":
        """
        :param theX:
        :type theX: Quantity_Length
        :param theY:
        :type theY: Quantity_Length
        :param theZ:
        :type theZ: Quantity_Length
        :param theDistance:
        :type theDistance: Quantity_Length
        :param theFace:
        :type theFace: Handle_BRepAdaptor_HSurface &
        :param theDrawUIso:
        :type theDrawUIso: bool
        :param theDrawVIso:
        :type theDrawVIso: bool
        :param theDeflection:
        :type theDeflection: Quantity_Length
        :param theNbUIso:
        :type theNbUIso: int
        :param theNbVIso:
        :type theNbVIso: int
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        :param theX:
        :type theX: Quantity_Length
        :param theY:
        :type theY: Quantity_Length
        :param theZ:
        :type theZ: Quantity_Length
        :param theDistance:
        :type theDistance: Quantity_Length
        :param theFace:
        :type theFace: Handle_BRepAdaptor_HSurface &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        """
        return _StdPrs.StdPrs_WFRestrictedFace_Match(*args)

    Match = staticmethod(Match)

    def MatchUIso(*args) -> "Standard_Boolean":
        """
        :param theX:
        :type theX: Quantity_Length
        :param theY:
        :type theY: Quantity_Length
        :param theZ:
        :type theZ: Quantity_Length
        :param theDistance:
        :type theDistance: Quantity_Length
        :param theFace:
        :type theFace: Handle_BRepAdaptor_HSurface &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        """
        return _StdPrs.StdPrs_WFRestrictedFace_MatchUIso(*args)

    MatchUIso = staticmethod(MatchUIso)

    def MatchVIso(*args) -> "Standard_Boolean":
        """
        :param theX:
        :type theX: Quantity_Length
        :param theY:
        :type theY: Quantity_Length
        :param theZ:
        :type theZ: Quantity_Length
        :param theDistance:
        :type theDistance: Quantity_Length
        :param theFace:
        :type theFace: Handle_BRepAdaptor_HSurface &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: bool

        """
        return _StdPrs.StdPrs_WFRestrictedFace_MatchVIso(*args)

    MatchVIso = staticmethod(MatchVIso)

    def AddUIso(*args) -> "void":
        """
        :param thePresentation:
        :type thePresentation: Handle_Prs3d_Presentation &
        :param theFace:
        :type theFace: Handle_BRepAdaptor_HSurface &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFRestrictedFace_AddUIso(*args)

    AddUIso = staticmethod(AddUIso)

    def AddVIso(*args) -> "void":
        """
        :param thePresentation:
        :type thePresentation: Handle_Prs3d_Presentation &
        :param theFace:
        :type theFace: Handle_BRepAdaptor_HSurface &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFRestrictedFace_AddVIso(*args)

    AddVIso = staticmethod(AddVIso)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_WFRestrictedFace_swiginit(self, _StdPrs.new_StdPrs_WFRestrictedFace())
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFRestrictedFace
StdPrs_WFRestrictedFace_swigregister = _StdPrs.StdPrs_WFRestrictedFace_swigregister
StdPrs_WFRestrictedFace_swigregister(StdPrs_WFRestrictedFace)

def StdPrs_WFRestrictedFace_Add(*args) -> "void":
    """
    :param thePresentation:
    :type thePresentation: Handle_Prs3d_Presentation &
    :param theFace:
    :type theFace: Handle_BRepAdaptor_HSurface &
    :param theDrawUIso:
    :type theDrawUIso: bool
    :param theDrawVIso:
    :type theDrawVIso: bool
    :param theDeflection:
    :type theDeflection: Quantity_Length
    :param theNbUIso:
    :type theNbUIso: int
    :param theNbVIso:
    :type theNbVIso: int
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :param theCurves:
    :type theCurves: Prs3d_NListOfSequenceOfPnt &
    :rtype: void

    :param thePresentation:
    :type thePresentation: Handle_Prs3d_Presentation &
    :param theFace:
    :type theFace: Handle_BRepAdaptor_HSurface &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFRestrictedFace_Add(*args)

def StdPrs_WFRestrictedFace_Match(*args) -> "Standard_Boolean":
    """
    :param theX:
    :type theX: Quantity_Length
    :param theY:
    :type theY: Quantity_Length
    :param theZ:
    :type theZ: Quantity_Length
    :param theDistance:
    :type theDistance: Quantity_Length
    :param theFace:
    :type theFace: Handle_BRepAdaptor_HSurface &
    :param theDrawUIso:
    :type theDrawUIso: bool
    :param theDrawVIso:
    :type theDrawVIso: bool
    :param theDeflection:
    :type theDeflection: Quantity_Length
    :param theNbUIso:
    :type theNbUIso: int
    :param theNbVIso:
    :type theNbVIso: int
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    :param theX:
    :type theX: Quantity_Length
    :param theY:
    :type theY: Quantity_Length
    :param theZ:
    :type theZ: Quantity_Length
    :param theDistance:
    :type theDistance: Quantity_Length
    :param theFace:
    :type theFace: Handle_BRepAdaptor_HSurface &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    """
    return _StdPrs.StdPrs_WFRestrictedFace_Match(*args)

def StdPrs_WFRestrictedFace_MatchUIso(*args) -> "Standard_Boolean":
    """
    :param theX:
    :type theX: Quantity_Length
    :param theY:
    :type theY: Quantity_Length
    :param theZ:
    :type theZ: Quantity_Length
    :param theDistance:
    :type theDistance: Quantity_Length
    :param theFace:
    :type theFace: Handle_BRepAdaptor_HSurface &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    """
    return _StdPrs.StdPrs_WFRestrictedFace_MatchUIso(*args)

def StdPrs_WFRestrictedFace_MatchVIso(*args) -> "Standard_Boolean":
    """
    :param theX:
    :type theX: Quantity_Length
    :param theY:
    :type theY: Quantity_Length
    :param theZ:
    :type theZ: Quantity_Length
    :param theDistance:
    :type theDistance: Quantity_Length
    :param theFace:
    :type theFace: Handle_BRepAdaptor_HSurface &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: bool

    """
    return _StdPrs.StdPrs_WFRestrictedFace_MatchVIso(*args)

def StdPrs_WFRestrictedFace_AddUIso(*args) -> "void":
    """
    :param thePresentation:
    :type thePresentation: Handle_Prs3d_Presentation &
    :param theFace:
    :type theFace: Handle_BRepAdaptor_HSurface &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFRestrictedFace_AddUIso(*args)

def StdPrs_WFRestrictedFace_AddVIso(*args) -> "void":
    """
    :param thePresentation:
    :type thePresentation: Handle_Prs3d_Presentation &
    :param theFace:
    :type theFace: Handle_BRepAdaptor_HSurface &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFRestrictedFace_AddVIso(*args)

class StdPrs_WFShape(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Add shape to presentation

        :param thePrs:
        :type thePrs: Handle_Prs3d_Presentation &
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: inline void

        """
        return _StdPrs.StdPrs_WFShape_Add(*args)

    Add = staticmethod(Add)

    def PickCurve(*args) -> "Handle_TopTools_HSequenceOfShape":
        """
        :param theX:
        :type theX: Quantity_Length
        :param theY:
        :type theY: Quantity_Length
        :param theZ:
        :type theZ: Quantity_Length
        :param theDistance:
        :type theDistance: Quantity_Length
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: inline Handle_TopTools_HSequenceOfShape

        """
        return _StdPrs.StdPrs_WFShape_PickCurve(*args)

    PickCurve = staticmethod(PickCurve)

    def PickPatch(*args) -> "Handle_TopTools_HSequenceOfShape":
        """
        :param theX:
        :type theX: Quantity_Length
        :param theY:
        :type theY: Quantity_Length
        :param theZ:
        :type theZ: Quantity_Length
        :param theDistance:
        :type theDistance: Quantity_Length
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theDrawer:
        :type theDrawer: Handle_Prs3d_Drawer &
        :rtype: inline Handle_TopTools_HSequenceOfShape

        """
        return _StdPrs.StdPrs_WFShape_PickPatch(*args)

    PickPatch = staticmethod(PickPatch)

    __repr__ = _dumps_object

    __swig_destroy__ = _StdPrs.delete_StdPrs_WFShape
StdPrs_WFShape_swigregister = _StdPrs.StdPrs_WFShape_swigregister
StdPrs_WFShape_swigregister(StdPrs_WFShape)

def StdPrs_WFShape_Add(*args) -> "void":
    """
    * Add shape to presentation

    :param thePrs:
    :type thePrs: Handle_Prs3d_Presentation &
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: inline void

    """
    return _StdPrs.StdPrs_WFShape_Add(*args)

def StdPrs_WFShape_PickCurve(*args) -> "Handle_TopTools_HSequenceOfShape":
    """
    :param theX:
    :type theX: Quantity_Length
    :param theY:
    :type theY: Quantity_Length
    :param theZ:
    :type theZ: Quantity_Length
    :param theDistance:
    :type theDistance: Quantity_Length
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: inline Handle_TopTools_HSequenceOfShape

    """
    return _StdPrs.StdPrs_WFShape_PickCurve(*args)

def StdPrs_WFShape_PickPatch(*args) -> "Handle_TopTools_HSequenceOfShape":
    """
    :param theX:
    :type theX: Quantity_Length
    :param theY:
    :type theY: Quantity_Length
    :param theZ:
    :type theZ: Quantity_Length
    :param theDistance:
    :type theDistance: Quantity_Length
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theDrawer:
    :type theDrawer: Handle_Prs3d_Drawer &
    :rtype: inline Handle_TopTools_HSequenceOfShape

    """
    return _StdPrs.StdPrs_WFShape_PickPatch(*args)

class StdPrs_WFSurface(OCC.Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Draws a surface by drawing the isoparametric curves with respect to a fixed number of points given by the Drawer. The number of isoparametric curves to be drawn and their color are controlled by the furnished Drawer.

        :param aPresentation:
        :type aPresentation: Handle_Prs3d_Presentation &
        :param aSurface:
        :type aSurface: Handle_Adaptor3d_HSurface &
        :param aDrawer:
        :type aDrawer: Handle_Prs3d_Drawer &
        :rtype: void

        """
        return _StdPrs.StdPrs_WFSurface_Add(*args)

    Add = staticmethod(Add)

    __repr__ = _dumps_object


    def __init__(self):
        _StdPrs.StdPrs_WFSurface_swiginit(self, _StdPrs.new_StdPrs_WFSurface())
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFSurface
StdPrs_WFSurface_swigregister = _StdPrs.StdPrs_WFSurface_swigregister
StdPrs_WFSurface_swigregister(StdPrs_WFSurface)

def StdPrs_WFSurface_Add(*args) -> "void":
    """
    * Draws a surface by drawing the isoparametric curves with respect to a fixed number of points given by the Drawer. The number of isoparametric curves to be drawn and their color are controlled by the furnished Drawer.

    :param aPresentation:
    :type aPresentation: Handle_Prs3d_Presentation &
    :param aSurface:
    :type aSurface: Handle_Adaptor3d_HSurface &
    :param aDrawer:
    :type aDrawer: Handle_Prs3d_Drawer &
    :rtype: void

    """
    return _StdPrs.StdPrs_WFSurface_Add(*args)



