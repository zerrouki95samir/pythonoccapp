# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _ShapeConstruct.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ShapeConstruct')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ShapeConstruct')
    _ShapeConstruct = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ShapeConstruct', [dirname(__file__)])
        except ImportError:
            import _ShapeConstruct
            return _ShapeConstruct
        try:
            _mod = imp.load_module('_ShapeConstruct', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ShapeConstruct = swig_import_helper()
    del swig_import_helper
else:
    import _ShapeConstruct
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ShapeConstruct.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_ShapeConstruct.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_ShapeConstruct.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_ShapeConstruct.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_ShapeConstruct.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_ShapeConstruct.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_ShapeConstruct.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_ShapeConstruct.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_ShapeConstruct.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_ShapeConstruct.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _ShapeConstruct.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.Geom
import OCC.MMgt
import OCC.Standard
import OCC.gp
import OCC.TCollection
import OCC.GeomAbs
import OCC.TColgp
import OCC.TColStd
import OCC.Geom2d
import OCC.TopTools
import OCC.TopoDS
import OCC.TopLoc
import OCC.TopAbs
import OCC.Message
import OCC.BRepBuilderAPI
import OCC.BRepTools
import OCC.Bnd
import OCC.BRep
import OCC.Poly
import OCC.NCollection
import OCC.TShort
import OCC.ShapeAnalysis
import OCC.ShapeExtend
import OCC.TColGeom
import OCC.Adaptor3d
import OCC.Adaptor2d
import OCC.math
import OCC.GeomAdaptor
import OCC.IntRes2d

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

class shapeconstruct(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ConvertCurveToBSpline(*args) -> "Handle_Geom2d_BSplineCurve":
        """
        * Tool for wire triangulation

        :param C3D:
        :type C3D: Handle_Geom_Curve &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Tol3d:
        :type Tol3d: float
        :param Continuity:
        :type Continuity: GeomAbs_Shape
        :param MaxSegments:
        :type MaxSegments: int
        :param MaxDegree:
        :type MaxDegree: int
        :rtype: Handle_Geom_BSplineCurve

        :param C2D:
        :type C2D: Handle_Geom2d_Curve &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Tol2d:
        :type Tol2d: float
        :param Continuity:
        :type Continuity: GeomAbs_Shape
        :param MaxSegments:
        :type MaxSegments: int
        :param MaxDegree:
        :type MaxDegree: int
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ShapeConstruct.shapeconstruct_ConvertCurveToBSpline(*args)

    ConvertCurveToBSpline = staticmethod(ConvertCurveToBSpline)

    def ConvertSurfaceToBSpline(*args) -> "Handle_Geom_BSplineSurface":
        """
        :param surf:
        :type surf: Handle_Geom_Surface &
        :param UF:
        :type UF: float
        :param UL:
        :type UL: float
        :param VF:
        :type VF: float
        :param VL:
        :type VL: float
        :param Tol3d:
        :type Tol3d: float
        :param Continuity:
        :type Continuity: GeomAbs_Shape
        :param MaxSegments:
        :type MaxSegments: int
        :param MaxDegree:
        :type MaxDegree: int
        :rtype: Handle_Geom_BSplineSurface

        """
        return _ShapeConstruct.shapeconstruct_ConvertSurfaceToBSpline(*args)

    ConvertSurfaceToBSpline = staticmethod(ConvertSurfaceToBSpline)

    def JoinPCurves(*args) -> "Standard_Boolean":
        """
        * join pcurves of the <theEdge> on the <theFace> try to use pcurves from originas edges <theEdges> Returns false if cannot join pcurves

        :param theEdges:
        :type theEdges: Handle_TopTools_HSequenceOfShape &
        :param theFace:
        :type theFace: TopoDS_Face &
        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :rtype: bool

        """
        return _ShapeConstruct.shapeconstruct_JoinPCurves(*args)

    JoinPCurves = staticmethod(JoinPCurves)

    def JoinCurves(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Boolean &, Standard_Boolean &":
        """
        * Method for joininig curves 3D. Parameters : c3d1,ac3d2 - initial curves Orient1, Orient2 - initial edges orientations. first1,last1,first2,last2 - parameters for trimming curves (re-calculate with account of orientation edges) c3dOut - result curve isRev1,isRev2 - out parameters indicative on possible errors. Return value : True - if curves were joined successfully, else - False.

        :param c3d1:
        :type c3d1: Handle_Geom_Curve &
        :param ac3d2:
        :type ac3d2: Handle_Geom_Curve &
        :param Orient1:
        :type Orient1: TopAbs_Orientation
        :param Orient2:
        :type Orient2: TopAbs_Orientation
        :param first1:
        :type first1: float &
        :param last1:
        :type last1: float &
        :param first2:
        :type first2: float &
        :param last2:
        :type last2: float &
        :param c3dOut:
        :type c3dOut: Handle_Geom_Curve &
        :param isRev1:
        :type isRev1: bool
        :param isRev2:
        :type isRev2: bool
        :rtype: bool

        * Method for joininig curves 3D. Parameters : c3d1,ac3d2 - initial curves Orient1, Orient2 - initial edges orientations. first1,last1,first2,last2 - parameters for trimming curves (re-calculate with account of orientation edges) c3dOut - result curve isRev1,isRev2 - out parameters indicative on possible errors. isError - input parameter indicative possible errors due to that one from edges have one vertex Return value : True - if curves were joined successfully, else - False.

        :param c2d1:
        :type c2d1: Handle_Geom2d_Curve &
        :param ac2d2:
        :type ac2d2: Handle_Geom2d_Curve &
        :param Orient1:
        :type Orient1: TopAbs_Orientation
        :param Orient2:
        :type Orient2: TopAbs_Orientation
        :param first1:
        :type first1: float &
        :param last1:
        :type last1: float &
        :param first2:
        :type first2: float &
        :param last2:
        :type last2: float &
        :param c2dOut:
        :type c2dOut: Handle_Geom2d_Curve &
        :param isRev1:
        :type isRev1: bool
        :param isRev2:
        :type isRev2: bool
        :param isError: default value is Standard_False
        :type isError: bool
        :rtype: bool

        """
        return _ShapeConstruct.shapeconstruct_JoinCurves(*args)

    JoinCurves = staticmethod(JoinCurves)

    __repr__ = _dumps_object


    def __init__(self):
        _ShapeConstruct.shapeconstruct_swiginit(self, _ShapeConstruct.new_shapeconstruct())
    __swig_destroy__ = _ShapeConstruct.delete_shapeconstruct
shapeconstruct_swigregister = _ShapeConstruct.shapeconstruct_swigregister
shapeconstruct_swigregister(shapeconstruct)

def shapeconstruct_ConvertCurveToBSpline(*args) -> "Handle_Geom2d_BSplineCurve":
    """
    * Tool for wire triangulation

    :param C3D:
    :type C3D: Handle_Geom_Curve &
    :param First:
    :type First: float
    :param Last:
    :type Last: float
    :param Tol3d:
    :type Tol3d: float
    :param Continuity:
    :type Continuity: GeomAbs_Shape
    :param MaxSegments:
    :type MaxSegments: int
    :param MaxDegree:
    :type MaxDegree: int
    :rtype: Handle_Geom_BSplineCurve

    :param C2D:
    :type C2D: Handle_Geom2d_Curve &
    :param First:
    :type First: float
    :param Last:
    :type Last: float
    :param Tol2d:
    :type Tol2d: float
    :param Continuity:
    :type Continuity: GeomAbs_Shape
    :param MaxSegments:
    :type MaxSegments: int
    :param MaxDegree:
    :type MaxDegree: int
    :rtype: Handle_Geom2d_BSplineCurve

    """
    return _ShapeConstruct.shapeconstruct_ConvertCurveToBSpline(*args)

def shapeconstruct_ConvertSurfaceToBSpline(*args) -> "Handle_Geom_BSplineSurface":
    """
    :param surf:
    :type surf: Handle_Geom_Surface &
    :param UF:
    :type UF: float
    :param UL:
    :type UL: float
    :param VF:
    :type VF: float
    :param VL:
    :type VL: float
    :param Tol3d:
    :type Tol3d: float
    :param Continuity:
    :type Continuity: GeomAbs_Shape
    :param MaxSegments:
    :type MaxSegments: int
    :param MaxDegree:
    :type MaxDegree: int
    :rtype: Handle_Geom_BSplineSurface

    """
    return _ShapeConstruct.shapeconstruct_ConvertSurfaceToBSpline(*args)

def shapeconstruct_JoinPCurves(*args) -> "Standard_Boolean":
    """
    * join pcurves of the <theEdge> on the <theFace> try to use pcurves from originas edges <theEdges> Returns false if cannot join pcurves

    :param theEdges:
    :type theEdges: Handle_TopTools_HSequenceOfShape &
    :param theFace:
    :type theFace: TopoDS_Face &
    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :rtype: bool

    """
    return _ShapeConstruct.shapeconstruct_JoinPCurves(*args)

def shapeconstruct_JoinCurves(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Boolean &, Standard_Boolean &":
    """
    * Method for joininig curves 3D. Parameters : c3d1,ac3d2 - initial curves Orient1, Orient2 - initial edges orientations. first1,last1,first2,last2 - parameters for trimming curves (re-calculate with account of orientation edges) c3dOut - result curve isRev1,isRev2 - out parameters indicative on possible errors. Return value : True - if curves were joined successfully, else - False.

    :param c3d1:
    :type c3d1: Handle_Geom_Curve &
    :param ac3d2:
    :type ac3d2: Handle_Geom_Curve &
    :param Orient1:
    :type Orient1: TopAbs_Orientation
    :param Orient2:
    :type Orient2: TopAbs_Orientation
    :param first1:
    :type first1: float &
    :param last1:
    :type last1: float &
    :param first2:
    :type first2: float &
    :param last2:
    :type last2: float &
    :param c3dOut:
    :type c3dOut: Handle_Geom_Curve &
    :param isRev1:
    :type isRev1: bool
    :param isRev2:
    :type isRev2: bool
    :rtype: bool

    * Method for joininig curves 3D. Parameters : c3d1,ac3d2 - initial curves Orient1, Orient2 - initial edges orientations. first1,last1,first2,last2 - parameters for trimming curves (re-calculate with account of orientation edges) c3dOut - result curve isRev1,isRev2 - out parameters indicative on possible errors. isError - input parameter indicative possible errors due to that one from edges have one vertex Return value : True - if curves were joined successfully, else - False.

    :param c2d1:
    :type c2d1: Handle_Geom2d_Curve &
    :param ac2d2:
    :type ac2d2: Handle_Geom2d_Curve &
    :param Orient1:
    :type Orient1: TopAbs_Orientation
    :param Orient2:
    :type Orient2: TopAbs_Orientation
    :param first1:
    :type first1: float &
    :param last1:
    :type last1: float &
    :param first2:
    :type first2: float &
    :param last2:
    :type last2: float &
    :param c2dOut:
    :type c2dOut: Handle_Geom2d_Curve &
    :param isRev1:
    :type isRev1: bool
    :param isRev2:
    :type isRev2: bool
    :param isError: default value is Standard_False
    :type isError: bool
    :rtype: bool

    """
    return _ShapeConstruct.shapeconstruct_JoinCurves(*args)

class ShapeConstruct_CompBezierCurves2dToBSplineCurve2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param AngularTolerance: default value is 1.0e-4
        :type AngularTolerance: float
        :rtype: None

        """
        _ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_swiginit(self, _ShapeConstruct.new_ShapeConstruct_CompBezierCurves2dToBSplineCurve2d(*args))

    def AddCurve(self, *args) -> "void":
        """
        :param Poles:
        :type Poles: TColgp_Array1OfPnt2d
        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_AddCurve(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Computes the algorithm.

        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_Perform(self, *args)


    def Degree(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_Degree(self, *args)


    def NbPoles(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_NbPoles(self, *args)


    def Poles(self, *args) -> "void":
        """
        :param Poles:
        :type Poles: TColgp_Array1OfPnt2d
        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_Poles(self, *args)


    def NbKnots(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_NbKnots(self, *args)


    def KnotsAndMults(self, *args) -> "void":
        """
        :param Knots:
        :type Knots: TColStd_Array1OfReal &
        :param Mults:
        :type Mults: TColStd_Array1OfInteger &
        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_KnotsAndMults(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_CompBezierCurves2dToBSplineCurve2d
ShapeConstruct_CompBezierCurves2dToBSplineCurve2d.AddCurve = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_AddCurve, None, ShapeConstruct_CompBezierCurves2dToBSplineCurve2d)
ShapeConstruct_CompBezierCurves2dToBSplineCurve2d.Perform = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_Perform, None, ShapeConstruct_CompBezierCurves2dToBSplineCurve2d)
ShapeConstruct_CompBezierCurves2dToBSplineCurve2d.Degree = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_Degree, None, ShapeConstruct_CompBezierCurves2dToBSplineCurve2d)
ShapeConstruct_CompBezierCurves2dToBSplineCurve2d.NbPoles = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_NbPoles, None, ShapeConstruct_CompBezierCurves2dToBSplineCurve2d)
ShapeConstruct_CompBezierCurves2dToBSplineCurve2d.Poles = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_Poles, None, ShapeConstruct_CompBezierCurves2dToBSplineCurve2d)
ShapeConstruct_CompBezierCurves2dToBSplineCurve2d.NbKnots = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_NbKnots, None, ShapeConstruct_CompBezierCurves2dToBSplineCurve2d)
ShapeConstruct_CompBezierCurves2dToBSplineCurve2d.KnotsAndMults = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_KnotsAndMults, None, ShapeConstruct_CompBezierCurves2dToBSplineCurve2d)
ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_swigregister = _ShapeConstruct.ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_swigregister
ShapeConstruct_CompBezierCurves2dToBSplineCurve2d_swigregister(ShapeConstruct_CompBezierCurves2dToBSplineCurve2d)

class ShapeConstruct_CompBezierCurvesToBSplineCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param AngularTolerance: default value is 1.0e-4
        :type AngularTolerance: float
        :rtype: None

        """
        _ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_swiginit(self, _ShapeConstruct.new_ShapeConstruct_CompBezierCurvesToBSplineCurve(*args))

    def AddCurve(self, *args) -> "void":
        """
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_AddCurve(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Computes the algorithm.

        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_Perform(self, *args)


    def Degree(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_Degree(self, *args)


    def NbPoles(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_NbPoles(self, *args)


    def Poles(self, *args) -> "void":
        """
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_Poles(self, *args)


    def NbKnots(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_NbKnots(self, *args)


    def KnotsAndMults(self, *args) -> "void":
        """
        :param Knots:
        :type Knots: TColStd_Array1OfReal &
        :param Mults:
        :type Mults: TColStd_Array1OfInteger &
        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_KnotsAndMults(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_CompBezierCurvesToBSplineCurve
ShapeConstruct_CompBezierCurvesToBSplineCurve.AddCurve = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_AddCurve, None, ShapeConstruct_CompBezierCurvesToBSplineCurve)
ShapeConstruct_CompBezierCurvesToBSplineCurve.Perform = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_Perform, None, ShapeConstruct_CompBezierCurvesToBSplineCurve)
ShapeConstruct_CompBezierCurvesToBSplineCurve.Degree = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_Degree, None, ShapeConstruct_CompBezierCurvesToBSplineCurve)
ShapeConstruct_CompBezierCurvesToBSplineCurve.NbPoles = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_NbPoles, None, ShapeConstruct_CompBezierCurvesToBSplineCurve)
ShapeConstruct_CompBezierCurvesToBSplineCurve.Poles = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_Poles, None, ShapeConstruct_CompBezierCurvesToBSplineCurve)
ShapeConstruct_CompBezierCurvesToBSplineCurve.NbKnots = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_NbKnots, None, ShapeConstruct_CompBezierCurvesToBSplineCurve)
ShapeConstruct_CompBezierCurvesToBSplineCurve.KnotsAndMults = new_instancemethod(_ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_KnotsAndMults, None, ShapeConstruct_CompBezierCurvesToBSplineCurve)
ShapeConstruct_CompBezierCurvesToBSplineCurve_swigregister = _ShapeConstruct.ShapeConstruct_CompBezierCurvesToBSplineCurve_swigregister
ShapeConstruct_CompBezierCurvesToBSplineCurve_swigregister(ShapeConstruct_CompBezierCurvesToBSplineCurve)

class ShapeConstruct_Curve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AdjustCurve(self, *args) -> "Standard_Boolean":
        """
        * Modifies a curve in order to make its bounds confused with given points. Works only on lines and B-Splines, returns True in this case, else returns False. For line considers both bounding points, for B-Splines only specified. //! Warning : Does not check if curve should be reversed

        :param C3D:
        :type C3D: Handle_Geom_Curve &
        :param P1:
        :type P1: gp_Pnt
        :param P2:
        :type P2: gp_Pnt
        :param take1: default value is Standard_True
        :type take1: bool
        :param take2: default value is Standard_True
        :type take2: bool
        :rtype: bool

        """
        return _ShapeConstruct.ShapeConstruct_Curve_AdjustCurve(self, *args)


    def AdjustCurveSegment(self, *args) -> "Standard_Boolean":
        """
        * Modifies a curve in order to make its bounds confused with given points. Works only on lines and B-Splines. //! For lines works as previous method, B-Splines are segmented at the given values and then are adjusted to the points.

        :param C3D:
        :type C3D: Handle_Geom_Curve &
        :param P1:
        :type P1: gp_Pnt
        :param P2:
        :type P2: gp_Pnt
        :param U1:
        :type U1: float
        :param U2:
        :type U2: float
        :rtype: bool

        """
        return _ShapeConstruct.ShapeConstruct_Curve_AdjustCurveSegment(self, *args)


    def AdjustCurve2d(self, *args) -> "Standard_Boolean":
        """
        * Modifies a curve in order to make its bounds confused with given points. Works only on lines and B-Splines, returns True in this case, else returns False. //! For line considers both bounding points, for B-Splines only specified. //! Warning : Does not check if curve should be reversed

        :param C2D:
        :type C2D: Handle_Geom2d_Curve &
        :param P1:
        :type P1: gp_Pnt2d
        :param P2:
        :type P2: gp_Pnt2d
        :param take1: default value is Standard_True
        :type take1: bool
        :param take2: default value is Standard_True
        :type take2: bool
        :rtype: bool

        """
        return _ShapeConstruct.ShapeConstruct_Curve_AdjustCurve2d(self, *args)


    def ConvertToBSpline(self, *args) -> "Handle_Geom2d_BSplineCurve":
        """
        * Converts a curve of any type (only part from first to last) to bspline. The method of conversion depends on the type of original curve: BSpline -> C.Segment(first,last) Bezier and Line -> GeomConvert::CurveToBSplineCurve(C).Segment(first,last) Conic and Other -> Approx_Curve3d(C[first,last],prec,C1,9,1000)

        :param C:
        :type C: Handle_Geom_Curve &
        :param first:
        :type first: float
        :param last:
        :type last: float
        :param prec:
        :type prec: float
        :rtype: Handle_Geom_BSplineCurve

        * Converts a curve of any type (only part from first to last) to bspline. The method of conversion depends on the type of original curve: BSpline -> C.Segment(first,last) Bezier and Line -> GeomConvert::CurveToBSplineCurve(C).Segment(first,last) Conic and Other -> Approx_Curve2d(C[first,last],prec,C1,9,1000)

        :param C:
        :type C: Handle_Geom2d_Curve &
        :param first:
        :type first: float
        :param last:
        :type last: float
        :param prec:
        :type prec: float
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ShapeConstruct.ShapeConstruct_Curve_ConvertToBSpline(self, *args)


    def FixKnots(*args) -> "Standard_Boolean":
        """
        :param knots:
        :type knots: Handle_TColStd_HArray1OfReal &
        :rtype: bool

        * Fix bspline knots to ensure that there is enough gap between neighbouring values Returns True if something fixed (by shifting knot)

        :param knots:
        :type knots: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _ShapeConstruct.ShapeConstruct_Curve_FixKnots(*args)

    FixKnots = staticmethod(FixKnots)

    __repr__ = _dumps_object


    def __init__(self):
        _ShapeConstruct.ShapeConstruct_Curve_swiginit(self, _ShapeConstruct.new_ShapeConstruct_Curve())
    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_Curve
ShapeConstruct_Curve.AdjustCurve = new_instancemethod(_ShapeConstruct.ShapeConstruct_Curve_AdjustCurve, None, ShapeConstruct_Curve)
ShapeConstruct_Curve.AdjustCurveSegment = new_instancemethod(_ShapeConstruct.ShapeConstruct_Curve_AdjustCurveSegment, None, ShapeConstruct_Curve)
ShapeConstruct_Curve.AdjustCurve2d = new_instancemethod(_ShapeConstruct.ShapeConstruct_Curve_AdjustCurve2d, None, ShapeConstruct_Curve)
ShapeConstruct_Curve.ConvertToBSpline = new_instancemethod(_ShapeConstruct.ShapeConstruct_Curve_ConvertToBSpline, None, ShapeConstruct_Curve)
ShapeConstruct_Curve_swigregister = _ShapeConstruct.ShapeConstruct_Curve_swigregister
ShapeConstruct_Curve_swigregister(ShapeConstruct_Curve)

def ShapeConstruct_Curve_FixKnots(*args) -> "Standard_Boolean":
    """
    :param knots:
    :type knots: Handle_TColStd_HArray1OfReal &
    :rtype: bool

    * Fix bspline knots to ensure that there is enough gap between neighbouring values Returns True if something fixed (by shifting knot)

    :param knots:
    :type knots: TColStd_Array1OfReal &
    :rtype: bool

    """
    return _ShapeConstruct.ShapeConstruct_Curve_FixKnots(*args)

class ShapeConstruct_MakeTriangulation(OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param pnts:
        :type pnts: TColgp_Array1OfPnt
        :param prec: default value is 0.0
        :type prec: float
        :rtype: None

        :param wire:
        :type wire: TopoDS_Wire &
        :param prec: default value is 0.0
        :type prec: float
        :rtype: None

        """
        _ShapeConstruct.ShapeConstruct_MakeTriangulation_swiginit(self, _ShapeConstruct.new_ShapeConstruct_MakeTriangulation(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_MakeTriangulation
ShapeConstruct_MakeTriangulation_swigregister = _ShapeConstruct.ShapeConstruct_MakeTriangulation_swigregister
ShapeConstruct_MakeTriangulation_swigregister(ShapeConstruct_MakeTriangulation)

class ShapeConstruct_ProjectCurveOnSurface(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty constructor.

        :rtype: None

        """
        _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_swiginit(self, _ShapeConstruct.new_ShapeConstruct_ProjectCurveOnSurface(*args))

    def Init(self, *args) -> "void":
        """
        * Initializes the object with all necessary parameters, i.e. surface and precision

        :param surf:
        :type surf: Handle_Geom_Surface &
        :param preci:
        :type preci: float
        :rtype: void

        * Initializes the object with all necessary parameters, i.e. surface and precision

        :param surf:
        :type surf: Handle_ShapeAnalysis_Surface &
        :param preci:
        :type preci: float
        :rtype: void

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Init(self, *args)


    def SetSurface(self, *args) -> "void":
        """
        * Loads a surface (in the form of Geom_Surface) to project on

        :param surf:
        :type surf: Handle_Geom_Surface &
        :rtype: None

        * Loads a surface (in the form of ShapeAnalysis_Surface) to project on

        :param surf:
        :type surf: Handle_ShapeAnalysis_Surface &
        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetSurface(self, *args)


    def SetPrecision(self, *args) -> "void":
        """
        * Sets value for current precision

        :param preci:
        :type preci: float
        :rtype: None

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetPrecision(self, *args)


    def GetBuildCurveMode(self) -> "Standard_Boolean":
        """GetBuildCurveMode(ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Boolean"""
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_GetBuildCurveMode(self)


    def SetBuildCurveMode(self, value: 'Standard_Boolean') -> "void":
        """SetBuildCurveMode(ShapeConstruct_ProjectCurveOnSurface self, Standard_Boolean value)"""
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetBuildCurveMode(self, value)


    def GetAdjustOverDegenMode(self) -> "Standard_Integer":
        """GetAdjustOverDegenMode(ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Integer"""
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_GetAdjustOverDegenMode(self)


    def SetAdjustOverDegenMode(self, value: 'Standard_Integer') -> "void":
        """SetAdjustOverDegenMode(ShapeConstruct_ProjectCurveOnSurface self, Standard_Integer value)"""
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetAdjustOverDegenMode(self, value)


    def Status(self, *args) -> "Standard_Boolean":
        """
        * Returns the status of last Peform

        :param Status:
        :type Status: ShapeExtend_Status
        :rtype: bool

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Status(self, *args)


    def Perform(self, *args) -> "Standard_Boolean":
        """
        * Computes the projection of 3d curve onto a surface using the standard algorithm from ProjLib. Returns False if standard projector fails or raises an exception or cuts the curve by parametrical bounds of the surface. Else, if pcurve computed successfully, returns True. The continuity, maxdeg and nbinterval are parameters of call to Approx_CurveOnSurface. If nbinterval is equal to -1 (default), this value is computed depending on source 3d curve and surface.

        :param c3d:
        :type c3d: Handle_Geom_Curve &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param c2d:
        :type c2d: Handle_Geom2d_Curve &
        :param continuity: default value is GeomAbs_C1
        :type continuity: GeomAbs_Shape
        :param maxdeg: default value is 12
        :type maxdeg: int
        :param nbinterval: default value is -1
        :type nbinterval: int
        :rtype: bool

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Perform(self, *args)


    def PerformByProjLib(self, *args) -> "Standard_Boolean":
        """
        * Computes the projection of 3d curve onto a surface using the standard algorithm from ProjLib. Returns False if standard projector fails or raises an exception or cuts the curve by parametrical bounds of the surface. Else, if pcurve computed successfully, returns True. The continuity, maxdeg and nbinterval are parameters of call to Approx_CurveOnSurface. If nbinterval is equal to -1 (default), this value is computed depending on source 3d curve and surface.

        :param c3d:
        :type c3d: Handle_Geom_Curve &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param c2d:
        :type c2d: Handle_Geom2d_Curve &
        :param continuity: default value is GeomAbs_C1
        :type continuity: GeomAbs_Shape
        :param maxdeg: default value is 12
        :type maxdeg: int
        :param nbinterval: default value is -1
        :type nbinterval: int
        :rtype: bool

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_PerformByProjLib(self, *args)


    def PerformAdvanced(self, *args) -> "Standard_Boolean":
        """
        * Computes the projection of 3d curve onto a surface using either standard projector (method PerformByStandard()) or internal one (method Perform()). The selection is done by analyzing the surface and 3d curve and is aimed to filter the cases potentially dangerous for the standard projector. If the standard projector fails, internal one is used.

        :param c3d:
        :type c3d: Handle_Geom_Curve &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param c2d:
        :type c2d: Handle_Geom2d_Curve &
        :rtype: bool

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_PerformAdvanced(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_ShapeConstruct_ProjectCurveOnSurface(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_ProjectCurveOnSurface
ShapeConstruct_ProjectCurveOnSurface.Init = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Init, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.SetSurface = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetSurface, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.SetPrecision = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetPrecision, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.GetBuildCurveMode = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_GetBuildCurveMode, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.SetBuildCurveMode = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetBuildCurveMode, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.GetAdjustOverDegenMode = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_GetAdjustOverDegenMode, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.SetAdjustOverDegenMode = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetAdjustOverDegenMode, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.Status = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Status, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.Perform = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Perform, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.PerformByProjLib = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_PerformByProjLib, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.PerformAdvanced = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_PerformAdvanced, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface_swigregister = _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_swigregister
ShapeConstruct_ProjectCurveOnSurface_swigregister(ShapeConstruct_ProjectCurveOnSurface)

class Handle_ShapeConstruct_ProjectCurveOnSurface(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_swiginit(self, _ShapeConstruct.new_Handle_ShapeConstruct_ProjectCurveOnSurface(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _ShapeConstruct.delete_Handle_ShapeConstruct_ProjectCurveOnSurface
Handle_ShapeConstruct_ProjectCurveOnSurface.Nullify = new_instancemethod(_ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_Nullify, None, Handle_ShapeConstruct_ProjectCurveOnSurface)
Handle_ShapeConstruct_ProjectCurveOnSurface.IsNull = new_instancemethod(_ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_IsNull, None, Handle_ShapeConstruct_ProjectCurveOnSurface)
Handle_ShapeConstruct_ProjectCurveOnSurface._get_reference = new_instancemethod(_ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface__get_reference, None, Handle_ShapeConstruct_ProjectCurveOnSurface)
Handle_ShapeConstruct_ProjectCurveOnSurface_swigregister = _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_swigregister
Handle_ShapeConstruct_ProjectCurveOnSurface_swigregister(Handle_ShapeConstruct_ProjectCurveOnSurface)

def Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_ShapeConstruct_ProjectCurveOnSurface const":
    return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast(AnObject)
Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast = _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast



