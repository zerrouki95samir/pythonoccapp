# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _IntWalk.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntWalk')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntWalk')
    _IntWalk = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntWalk', [dirname(__file__)])
        except ImportError:
            import _IntWalk
            return _IntWalk
        try:
            _mod = imp.load_module('_IntWalk', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntWalk = swig_import_helper()
    del swig_import_helper
else:
    import _IntWalk
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntWalk.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_IntWalk.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_IntWalk.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_IntWalk.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_IntWalk.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_IntWalk.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_IntWalk.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_IntWalk.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_IntWalk.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_IntWalk.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_IntWalk.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_IntWalk.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_IntWalk.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_IntWalk.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_IntWalk.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_IntWalk.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_IntWalk.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _IntWalk.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.Adaptor3d
import OCC.Standard
import OCC.GeomAbs
import OCC.TColStd
import OCC.TCollection
import OCC.MMgt
import OCC.gp
import OCC.Geom
import OCC.TColgp
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.TopAbs
import OCC.math
import OCC.IntSurf
import OCC.IntImp

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

IntWalk_PasTropGrand = _IntWalk.IntWalk_PasTropGrand
IntWalk_PointConfondu = _IntWalk.IntWalk_PointConfondu
IntWalk_ArretSurPointPrecedent = _IntWalk.IntWalk_ArretSurPointPrecedent
IntWalk_ArretSurPoint = _IntWalk.IntWalk_ArretSurPoint
IntWalk_OK = _IntWalk.IntWalk_OK
class IntWalk_PWalking(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor used to set the data to compute intersection lines between Caro1 and Caro2. Deflection is the maximum deflection admitted between two consecutive points on the resulting polyline. TolTangency is the tolerance to find a tangent point. Func is the criterion which has to be evaluated at each solution point (each point of the line). It is necessary to call the Perform method to compute the intersection lines. The line found starts at a point on or in 2 natural domains of surfaces. It can be closed in the standard case if it is open it stops and begins at the border of one of the domains. If an open line stops at the middle of a domain, one stops at the tangent point. Epsilon is SquareTolerance of points confusion.

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Caro2:
        :type Caro2: Handle_Adaptor3d_HSurface &
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :rtype: None

        * Returns the intersection line containing the exact point Poin. This line is a polygonal line. Deflection is the maximum deflection admitted between two consecutive points on the resulting polyline. TolTangency is the tolerance to find a tangent point. Func is the criterion which has to be evaluated at each solution point (each point of the line). The line found starts at a point on or in 2 natural domains of surfaces. It can be closed in the standard case if it is open it stops and begins at the border of one of the domains. If an open line stops at the middle of a domain, one stops at the tangent point. Epsilon is SquareTolerance of points confusion.

        :param Caro1:
        :type Caro1: Handle_Adaptor3d_HSurface &
        :param Caro2:
        :type Caro2: Handle_Adaptor3d_HSurface &
        :param TolTangency:
        :type TolTangency: float
        :param Epsilon:
        :type Epsilon: float
        :param Deflection:
        :type Deflection: float
        :param Increment:
        :type Increment: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :rtype: None

        """
        _IntWalk.IntWalk_PWalking_swiginit(self, _IntWalk.new_IntWalk_PWalking(*args))

    def Perform(self, *args) -> "void":
        """
        * calculate the line of intersection

        :param ParDep:
        :type ParDep: TColStd_Array1OfReal &
        :rtype: None

        * calculate the line of intersection. The regulation of steps is done using min and max values on u and v. (if this data is not presented as in the previous method, the initial steps are calculated starting from min and max uv of faces).

        :param ParDep:
        :type ParDep: TColStd_Array1OfReal &
        :param u1min:
        :type u1min: float
        :param v1min:
        :type v1min: float
        :param u2min:
        :type u2min: float
        :param v2min:
        :type v2min: float
        :param u1max:
        :type u1max: float
        :param v1max:
        :type v1max: float
        :param u2max:
        :type u2max: float
        :param v2max:
        :type v2max: float
        :rtype: None

        """
        return _IntWalk.IntWalk_PWalking_Perform(self, *args)


    def PerformFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * calculate the first point of a line of intersection

        :param ParDep:
        :type ParDep: TColStd_Array1OfReal &
        :param FirstPoint:
        :type FirstPoint: IntSurf_PntOn2S &
        :rtype: bool

        """
        return _IntWalk.IntWalk_PWalking_PerformFirstPoint(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the calculus was successful.

        :rtype: bool

        """
        return _IntWalk.IntWalk_PWalking_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * Returns the number of points of the resulting polyline. An exception is raised if IsDone returns False.

        :rtype: int

        """
        return _IntWalk.IntWalk_PWalking_NbPoints(self, *args)


    def Value(self, *args) -> "IntSurf_PntOn2S const &":
        """
        * Returns the point of range Index on the polyline. An exception is raised if IsDone returns False. An exception is raised if Index<=0 or Index>NbPoints.

        :param Index:
        :type Index: int
        :rtype: IntSurf_PntOn2S

        """
        return _IntWalk.IntWalk_PWalking_Value(self, *args)


    def Line(self, *args) -> "Handle_IntSurf_LineOn2S":
        """
        :rtype: Handle_IntSurf_LineOn2S

        """
        return _IntWalk.IntWalk_PWalking_Line(self, *args)


    def TangentAtFirst(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the surface are tangent at the first point of the line. An exception is raised if IsDone returns False.

        :rtype: bool

        """
        return _IntWalk.IntWalk_PWalking_TangentAtFirst(self, *args)


    def TangentAtLast(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the surface are tangent at the last point of the line. An exception is raised if IsDone returns False.

        :rtype: bool

        """
        return _IntWalk.IntWalk_PWalking_TangentAtLast(self, *args)


    def IsClosed(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line is closed. An exception is raised if IsDone returns False.

        :rtype: bool

        """
        return _IntWalk.IntWalk_PWalking_IsClosed(self, *args)


    def TangentAtLine(self, *args) -> "gp_Dir const":
        """
        :param Index:
        :type Index: int &
        :rtype: gp_Dir

        """
        return _IntWalk.IntWalk_PWalking_TangentAtLine(self, *args)


    def TestDeflection(self, *args) -> "IntWalk_StatusDeflection":
        """
        :rtype: IntWalk_StatusDeflection

        """
        return _IntWalk.IntWalk_PWalking_TestDeflection(self, *args)


    def TestArret(self, *args) -> "Standard_Boolean":
        """
        :param DejaReparti:
        :type DejaReparti: bool
        :param Param:
        :type Param: TColStd_Array1OfReal &
        :param ChoixIso:
        :type ChoixIso: IntImp_ConstIsoparametric &
        :rtype: bool

        """
        return _IntWalk.IntWalk_PWalking_TestArret(self, *args)


    def RepartirOuDiviser(self, *args) -> "void":
        """
        :param DejaReparti:
        :type DejaReparti: bool
        :param ChoixIso:
        :type ChoixIso: IntImp_ConstIsoparametric &
        :param Arrive:
        :type Arrive: bool
        :rtype: None

        """
        return _IntWalk.IntWalk_PWalking_RepartirOuDiviser(self, *args)


    def AddAPoint(self, *args) -> "void":
        """
        :param line:
        :type line: Handle_IntSurf_LineOn2S &
        :param POn2S:
        :type POn2S: IntSurf_PntOn2S &
        :rtype: None

        """
        return _IntWalk.IntWalk_PWalking_AddAPoint(self, *args)


    def PutToBoundary(self, *args) -> "Standard_Boolean":
        """
        :param theASurf1:
        :type theASurf1: Handle_Adaptor3d_HSurface &
        :param theASurf2:
        :type theASurf2: Handle_Adaptor3d_HSurface &
        :rtype: bool

        """
        return _IntWalk.IntWalk_PWalking_PutToBoundary(self, *args)


    def SeekAdditionalPoints(self, *args) -> "Standard_Boolean":
        """
        :param theASurf1:
        :type theASurf1: Handle_Adaptor3d_HSurface &
        :param theASurf2:
        :type theASurf2: Handle_Adaptor3d_HSurface &
        :param theMinNbPoints:
        :type theMinNbPoints: int
        :rtype: bool

        """
        return _IntWalk.IntWalk_PWalking_SeekAdditionalPoints(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntWalk.delete_IntWalk_PWalking
IntWalk_PWalking.Perform = new_instancemethod(_IntWalk.IntWalk_PWalking_Perform, None, IntWalk_PWalking)
IntWalk_PWalking.PerformFirstPoint = new_instancemethod(_IntWalk.IntWalk_PWalking_PerformFirstPoint, None, IntWalk_PWalking)
IntWalk_PWalking.IsDone = new_instancemethod(_IntWalk.IntWalk_PWalking_IsDone, None, IntWalk_PWalking)
IntWalk_PWalking.NbPoints = new_instancemethod(_IntWalk.IntWalk_PWalking_NbPoints, None, IntWalk_PWalking)
IntWalk_PWalking.Value = new_instancemethod(_IntWalk.IntWalk_PWalking_Value, None, IntWalk_PWalking)
IntWalk_PWalking.Line = new_instancemethod(_IntWalk.IntWalk_PWalking_Line, None, IntWalk_PWalking)
IntWalk_PWalking.TangentAtFirst = new_instancemethod(_IntWalk.IntWalk_PWalking_TangentAtFirst, None, IntWalk_PWalking)
IntWalk_PWalking.TangentAtLast = new_instancemethod(_IntWalk.IntWalk_PWalking_TangentAtLast, None, IntWalk_PWalking)
IntWalk_PWalking.IsClosed = new_instancemethod(_IntWalk.IntWalk_PWalking_IsClosed, None, IntWalk_PWalking)
IntWalk_PWalking.TangentAtLine = new_instancemethod(_IntWalk.IntWalk_PWalking_TangentAtLine, None, IntWalk_PWalking)
IntWalk_PWalking.TestDeflection = new_instancemethod(_IntWalk.IntWalk_PWalking_TestDeflection, None, IntWalk_PWalking)
IntWalk_PWalking.TestArret = new_instancemethod(_IntWalk.IntWalk_PWalking_TestArret, None, IntWalk_PWalking)
IntWalk_PWalking.RepartirOuDiviser = new_instancemethod(_IntWalk.IntWalk_PWalking_RepartirOuDiviser, None, IntWalk_PWalking)
IntWalk_PWalking.AddAPoint = new_instancemethod(_IntWalk.IntWalk_PWalking_AddAPoint, None, IntWalk_PWalking)
IntWalk_PWalking.PutToBoundary = new_instancemethod(_IntWalk.IntWalk_PWalking_PutToBoundary, None, IntWalk_PWalking)
IntWalk_PWalking.SeekAdditionalPoints = new_instancemethod(_IntWalk.IntWalk_PWalking_SeekAdditionalPoints, None, IntWalk_PWalking)
IntWalk_PWalking_swigregister = _IntWalk.IntWalk_PWalking_swigregister
IntWalk_PWalking_swigregister(IntWalk_PWalking)

class IntWalk_TheFunctionOfTheInt2S(OCC.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        _IntWalk.IntWalk_TheFunctionOfTheInt2S_swiginit(self, _IntWalk.new_IntWalk_TheFunctionOfTheInt2S(*args))

    def ComputeParameters(self, *args) -> "void":
        """
        :param ChoixIso:
        :type ChoixIso: IntImp_ConstIsoparametric
        :param Param:
        :type Param: TColStd_Array1OfReal &
        :param UVap:
        :type UVap: math_Vector &
        :param BornInf:
        :type BornInf: math_Vector &
        :param BornSup:
        :type BornSup: math_Vector &
        :param Tolerance:
        :type Tolerance: math_Vector &
        :rtype: None

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_ComputeParameters(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        :rtype: float

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_Root(self, *args)


    def Point(self, *args) -> "gp_Pnt":
        """
        :rtype: gp_Pnt

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_Point(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        :param UVap:
        :type UVap: math_Vector &
        :param Param:
        :type Param: TColStd_Array1OfReal &
        :param BestChoix:
        :type BestChoix: IntImp_ConstIsoparametric &
        :rtype: bool

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_IsTangent(self, *args)


    def Direction(self, *args) -> "gp_Dir":
        """
        :rtype: gp_Dir

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_Direction(self, *args)


    def DirectionOnS1(self, *args) -> "gp_Dir2d":
        """
        :rtype: gp_Dir2d

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_DirectionOnS1(self, *args)


    def DirectionOnS2(self, *args) -> "gp_Dir2d":
        """
        :rtype: gp_Dir2d

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_DirectionOnS2(self, *args)


    def AuxillarSurface1(self, *args) -> "Handle_Adaptor3d_HSurface":
        """
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_AuxillarSurface1(self, *args)


    def AuxillarSurface2(self, *args) -> "Handle_Adaptor3d_HSurface":
        """
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_AuxillarSurface2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntWalk.delete_IntWalk_TheFunctionOfTheInt2S
IntWalk_TheFunctionOfTheInt2S.ComputeParameters = new_instancemethod(_IntWalk.IntWalk_TheFunctionOfTheInt2S_ComputeParameters, None, IntWalk_TheFunctionOfTheInt2S)
IntWalk_TheFunctionOfTheInt2S.Root = new_instancemethod(_IntWalk.IntWalk_TheFunctionOfTheInt2S_Root, None, IntWalk_TheFunctionOfTheInt2S)
IntWalk_TheFunctionOfTheInt2S.Point = new_instancemethod(_IntWalk.IntWalk_TheFunctionOfTheInt2S_Point, None, IntWalk_TheFunctionOfTheInt2S)
IntWalk_TheFunctionOfTheInt2S.IsTangent = new_instancemethod(_IntWalk.IntWalk_TheFunctionOfTheInt2S_IsTangent, None, IntWalk_TheFunctionOfTheInt2S)
IntWalk_TheFunctionOfTheInt2S.Direction = new_instancemethod(_IntWalk.IntWalk_TheFunctionOfTheInt2S_Direction, None, IntWalk_TheFunctionOfTheInt2S)
IntWalk_TheFunctionOfTheInt2S.DirectionOnS1 = new_instancemethod(_IntWalk.IntWalk_TheFunctionOfTheInt2S_DirectionOnS1, None, IntWalk_TheFunctionOfTheInt2S)
IntWalk_TheFunctionOfTheInt2S.DirectionOnS2 = new_instancemethod(_IntWalk.IntWalk_TheFunctionOfTheInt2S_DirectionOnS2, None, IntWalk_TheFunctionOfTheInt2S)
IntWalk_TheFunctionOfTheInt2S.AuxillarSurface1 = new_instancemethod(_IntWalk.IntWalk_TheFunctionOfTheInt2S_AuxillarSurface1, None, IntWalk_TheFunctionOfTheInt2S)
IntWalk_TheFunctionOfTheInt2S.AuxillarSurface2 = new_instancemethod(_IntWalk.IntWalk_TheFunctionOfTheInt2S_AuxillarSurface2, None, IntWalk_TheFunctionOfTheInt2S)
IntWalk_TheFunctionOfTheInt2S_swigregister = _IntWalk.IntWalk_TheFunctionOfTheInt2S_swigregister
IntWalk_TheFunctionOfTheInt2S_swigregister(IntWalk_TheFunctionOfTheInt2S)

class IntWalk_TheInt2S(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param Param:
        :type Param: TColStd_Array1OfReal &
        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param TolTangency:
        :type TolTangency: float
        :rtype: None

        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param TolTangency:
        :type TolTangency: float
        :rtype: None

        """
        _IntWalk.IntWalk_TheInt2S_swiginit(self, _IntWalk.new_IntWalk_TheInt2S(*args))

    def Perform(self, *args) -> "IntImp_ConstIsoparametric":
        """
        :param Param:
        :type Param: TColStd_Array1OfReal &
        :param Rsnld:
        :type Rsnld: math_FunctionSetRoot &
        :rtype: IntImp_ConstIsoparametric

        :param Param:
        :type Param: TColStd_Array1OfReal &
        :param Rsnld:
        :type Rsnld: math_FunctionSetRoot &
        :param ChoixIso:
        :type ChoixIso: IntImp_ConstIsoparametric
        :rtype: IntImp_ConstIsoparametric

        """
        return _IntWalk.IntWalk_TheInt2S_Perform(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntWalk.IntWalk_TheInt2S_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntWalk.IntWalk_TheInt2S_IsEmpty(self, *args)


    def Point(self, *args) -> "IntSurf_PntOn2S const &":
        """
        :rtype: IntSurf_PntOn2S

        """
        return _IntWalk.IntWalk_TheInt2S_Point(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _IntWalk.IntWalk_TheInt2S_IsTangent(self, *args)


    def Direction(self, *args) -> "gp_Dir const":
        """
        :rtype: gp_Dir

        """
        return _IntWalk.IntWalk_TheInt2S_Direction(self, *args)


    def DirectionOnS1(self, *args) -> "gp_Dir2d const":
        """
        :rtype: gp_Dir2d

        """
        return _IntWalk.IntWalk_TheInt2S_DirectionOnS1(self, *args)


    def DirectionOnS2(self, *args) -> "gp_Dir2d const":
        """
        :rtype: gp_Dir2d

        """
        return _IntWalk.IntWalk_TheInt2S_DirectionOnS2(self, *args)


    def Function(self, *args) -> "IntWalk_TheFunctionOfTheInt2S &":
        """
        :rtype: IntWalk_TheFunctionOfTheInt2S

        """
        return _IntWalk.IntWalk_TheInt2S_Function(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntWalk.delete_IntWalk_TheInt2S
IntWalk_TheInt2S.Perform = new_instancemethod(_IntWalk.IntWalk_TheInt2S_Perform, None, IntWalk_TheInt2S)
IntWalk_TheInt2S.IsDone = new_instancemethod(_IntWalk.IntWalk_TheInt2S_IsDone, None, IntWalk_TheInt2S)
IntWalk_TheInt2S.IsEmpty = new_instancemethod(_IntWalk.IntWalk_TheInt2S_IsEmpty, None, IntWalk_TheInt2S)
IntWalk_TheInt2S.Point = new_instancemethod(_IntWalk.IntWalk_TheInt2S_Point, None, IntWalk_TheInt2S)
IntWalk_TheInt2S.IsTangent = new_instancemethod(_IntWalk.IntWalk_TheInt2S_IsTangent, None, IntWalk_TheInt2S)
IntWalk_TheInt2S.Direction = new_instancemethod(_IntWalk.IntWalk_TheInt2S_Direction, None, IntWalk_TheInt2S)
IntWalk_TheInt2S.DirectionOnS1 = new_instancemethod(_IntWalk.IntWalk_TheInt2S_DirectionOnS1, None, IntWalk_TheInt2S)
IntWalk_TheInt2S.DirectionOnS2 = new_instancemethod(_IntWalk.IntWalk_TheInt2S_DirectionOnS2, None, IntWalk_TheInt2S)
IntWalk_TheInt2S.Function = new_instancemethod(_IntWalk.IntWalk_TheInt2S_Function, None, IntWalk_TheInt2S)
IntWalk_TheInt2S_swigregister = _IntWalk.IntWalk_TheInt2S_swigregister
IntWalk_TheInt2S_swigregister(IntWalk_TheInt2S)

class IntWalk_WalkingData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    ustart = _swig_property(_IntWalk.IntWalk_WalkingData_ustart_get, _IntWalk.IntWalk_WalkingData_ustart_set)
    vstart = _swig_property(_IntWalk.IntWalk_WalkingData_vstart_get, _IntWalk.IntWalk_WalkingData_vstart_set)
    etat = _swig_property(_IntWalk.IntWalk_WalkingData_etat_get, _IntWalk.IntWalk_WalkingData_etat_set)

    __repr__ = _dumps_object

    __swig_destroy__ = _IntWalk.delete_IntWalk_WalkingData
IntWalk_WalkingData_swigregister = _IntWalk.IntWalk_WalkingData_swigregister
IntWalk_WalkingData_swigregister(IntWalk_WalkingData)



