# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _V3d.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_V3d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_V3d')
    _V3d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_V3d', [dirname(__file__)])
        except ImportError:
            import _V3d
            return _V3d
        try:
            _mod = imp.load_module('_V3d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _V3d = swig_import_helper()
    del swig_import_helper
else:
    import _V3d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _V3d.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_V3d.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_V3d.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_V3d.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_V3d.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_V3d.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_V3d.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_V3d.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_V3d.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_V3d.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_V3d.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_V3d.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_V3d.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_V3d.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_V3d.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_V3d.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_V3d.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _V3d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.Graphic3d
import OCC.Standard
import OCC.MMgt
import OCC.gp
import OCC.Quantity
import OCC.TCollection
import OCC.Aspect
import OCC.TColStd
import OCC.Image
import OCC.NCollection
import OCC.Bnd
import OCC.OSD
import OCC.Visual3d

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

V3d_SDO_MONO = _V3d.V3d_SDO_MONO
V3d_SDO_LEFT_EYE = _V3d.V3d_SDO_LEFT_EYE
V3d_SDO_RIGHT_EYE = _V3d.V3d_SDO_RIGHT_EYE
V3d_X = _V3d.V3d_X
V3d_Y = _V3d.V3d_Y
V3d_Z = _V3d.V3d_Z
V3d_TOBM_AUTOMATIC = _V3d.V3d_TOBM_AUTOMATIC
V3d_TOBM_ALWAYS_DISPLAYED = _V3d.V3d_TOBM_ALWAYS_DISPLAYED
V3d_TOBM_NEVER_DISPLAYED = _V3d.V3d_TOBM_NEVER_DISPLAYED
V3d_AMBIENT = _V3d.V3d_AMBIENT
V3d_DIRECTIONAL = _V3d.V3d_DIRECTIONAL
V3d_POSITIONAL = _V3d.V3d_POSITIONAL
V3d_SPOT = _V3d.V3d_SPOT
V3d_Xpos = _V3d.V3d_Xpos
V3d_Ypos = _V3d.V3d_Ypos
V3d_Zpos = _V3d.V3d_Zpos
V3d_Xneg = _V3d.V3d_Xneg
V3d_Yneg = _V3d.V3d_Yneg
V3d_Zneg = _V3d.V3d_Zneg
V3d_XposYpos = _V3d.V3d_XposYpos
V3d_XposZpos = _V3d.V3d_XposZpos
V3d_YposZpos = _V3d.V3d_YposZpos
V3d_XnegYneg = _V3d.V3d_XnegYneg
V3d_XnegYpos = _V3d.V3d_XnegYpos
V3d_XnegZneg = _V3d.V3d_XnegZneg
V3d_XnegZpos = _V3d.V3d_XnegZpos
V3d_YnegZneg = _V3d.V3d_YnegZneg
V3d_YnegZpos = _V3d.V3d_YnegZpos
V3d_XposYneg = _V3d.V3d_XposYneg
V3d_XposZneg = _V3d.V3d_XposZneg
V3d_YposZneg = _V3d.V3d_YposZneg
V3d_XposYposZpos = _V3d.V3d_XposYposZpos
V3d_XposYnegZpos = _V3d.V3d_XposYnegZpos
V3d_XposYposZneg = _V3d.V3d_XposYposZneg
V3d_XnegYposZpos = _V3d.V3d_XnegYposZpos
V3d_XposYnegZneg = _V3d.V3d_XposYnegZneg
V3d_XnegYposZneg = _V3d.V3d_XnegYposZneg
V3d_XnegYnegZpos = _V3d.V3d_XnegYnegZpos
V3d_XnegYnegZneg = _V3d.V3d_XnegYnegZneg
V3d_POSITIONCAMERA = _V3d.V3d_POSITIONCAMERA
V3d_SPACECAMERA = _V3d.V3d_SPACECAMERA
V3d_RADIUSTEXTCAMERA = _V3d.V3d_RADIUSTEXTCAMERA
V3d_ExtRADIUSCAMERA = _V3d.V3d_ExtRADIUSCAMERA
V3d_IntRADIUSCAMERA = _V3d.V3d_IntRADIUSCAMERA
V3d_NOTHINGCAMERA = _V3d.V3d_NOTHINGCAMERA
V3d_POSITIONLIGHT = _V3d.V3d_POSITIONLIGHT
V3d_SPACELIGHT = _V3d.V3d_SPACELIGHT
V3d_RADIUSTEXTLIGHT = _V3d.V3d_RADIUSTEXTLIGHT
V3d_ExtRADIUSLIGHT = _V3d.V3d_ExtRADIUSLIGHT
V3d_IntRADIUSLIGHT = _V3d.V3d_IntRADIUSLIGHT
V3d_NOTHING = _V3d.V3d_NOTHING
V3d_SIMPLE = _V3d.V3d_SIMPLE
V3d_COMPLETE = _V3d.V3d_COMPLETE
V3d_PARTIAL = _V3d.V3d_PARTIAL
V3d_SAMELAST = _V3d.V3d_SAMELAST
V3d_COLOR = _V3d.V3d_COLOR
V3d_FLAT = _V3d.V3d_FLAT
V3d_GOURAUD = _V3d.V3d_GOURAUD
V3d_PHONG = _V3d.V3d_PHONG
V3d_TEX_NONE = _V3d.V3d_TEX_NONE
V3d_TEX_ENVIRONMENT = _V3d.V3d_TEX_ENVIRONMENT
V3d_TEX_ALL = _V3d.V3d_TEX_ALL
V3d_ASAP = _V3d.V3d_ASAP
V3d_WAIT = _V3d.V3d_WAIT
V3d_ORTHOGRAPHIC = _V3d.V3d_ORTHOGRAPHIC
V3d_PERSPECTIVE = _V3d.V3d_PERSPECTIVE
V3d_WIREFRAME = _V3d.V3d_WIREFRAME
V3d_ZBUFFER = _V3d.V3d_ZBUFFER
V3d_OFF = _V3d.V3d_OFF
V3d_BACK = _V3d.V3d_BACK
V3d_FRONT = _V3d.V3d_FRONT
V3d_SLICE = _V3d.V3d_SLICE
class v3d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetProjAxis(*args) -> "Graphic3d_Vector":
        """
        * Determines the orientation vector corresponding to the predefined orientation type.

        :param Orientation:
        :type Orientation: V3d_TypeOfOrientation
        :rtype: Graphic3d_Vector

        """
        return _V3d.v3d_GetProjAxis(*args)

    GetProjAxis = staticmethod(GetProjAxis)

    def ArrowOfRadius(*args) -> "void":
        """
        * Compute the graphic structure of arrow. X0,Y0,Z0 : coordinate of the arrow. DX,DY,DZ : Direction of the arrow. Alpha : Angle of arrow. Lng : Length of arrow.

        :param garrow:
        :type garrow: Handle_Graphic3d_Group &
        :param X0:
        :type X0: V3d_Coordinate
        :param Y0:
        :type Y0: V3d_Coordinate
        :param Z0:
        :type Z0: V3d_Coordinate
        :param DX:
        :type DX: V3d_Parameter
        :param DY:
        :type DY: V3d_Parameter
        :param DZ:
        :type DZ: V3d_Parameter
        :param Alpha:
        :type Alpha: Quantity_PlaneAngle
        :param Lng:
        :type Lng: V3d_Parameter
        :rtype: void

        """
        return _V3d.v3d_ArrowOfRadius(*args)

    ArrowOfRadius = staticmethod(ArrowOfRadius)

    def CircleInPlane(*args) -> "void":
        """
        * Compute the graphic structure of circle. X0,Y0,Z0 : Center of circle. VX,VY,VZ : Axis of circle. Radius : Radius of circle.

        :param gcircle:
        :type gcircle: Handle_Graphic3d_Group &
        :param X0:
        :type X0: V3d_Coordinate
        :param Y0:
        :type Y0: V3d_Coordinate
        :param Z0:
        :type Z0: V3d_Coordinate
        :param VX:
        :type VX: V3d_Parameter
        :param VY:
        :type VY: V3d_Parameter
        :param VZ:
        :type VZ: V3d_Parameter
        :param Radius:
        :type Radius: V3d_Parameter
        :rtype: void

        """
        return _V3d.v3d_CircleInPlane(*args)

    CircleInPlane = staticmethod(CircleInPlane)

    def SwitchViewsinWindow(*args) -> "void":
        """
        :param aPreviousView:
        :type aPreviousView: Handle_V3d_View &
        :param aNextView:
        :type aNextView: Handle_V3d_View &
        :rtype: void

        """
        return _V3d.v3d_SwitchViewsinWindow(*args)

    SwitchViewsinWindow = staticmethod(SwitchViewsinWindow)

    def DrawSphere(*args) -> "void":
        """
        * test.

        :param aViewer:
        :type aViewer: Handle_V3d_Viewer &
        :param aRadius: default value is 1000
        :type aRadius: Quantity_Length
        :rtype: void

        """
        return _V3d.v3d_DrawSphere(*args)

    DrawSphere = staticmethod(DrawSphere)

    def PickGrid(*args) -> "void":
        """
        * test.

        :param aViewer:
        :type aViewer: Handle_V3d_Viewer &
        :param aRadius: default value is 1000
        :type aRadius: Quantity_Length
        :rtype: void

        """
        return _V3d.v3d_PickGrid(*args)

    PickGrid = staticmethod(PickGrid)

    def SetPlane(*args) -> "void":
        """
        * test.

        :param aViewer:
        :type aViewer: Handle_V3d_Viewer &
        :param x1:
        :type x1: Quantity_Length
        :param y1:
        :type y1: Quantity_Length
        :param z1:
        :type z1: Quantity_Length
        :param x2:
        :type x2: Quantity_Length
        :param y2:
        :type y2: Quantity_Length
        :param z2:
        :type z2: Quantity_Length
        :rtype: void

        """
        return _V3d.v3d_SetPlane(*args)

    SetPlane = staticmethod(SetPlane)

    __repr__ = _dumps_object


    def __init__(self):
        _V3d.v3d_swiginit(self, _V3d.new_v3d())
    __swig_destroy__ = _V3d.delete_v3d
v3d_swigregister = _V3d.v3d_swigregister
v3d_swigregister(v3d)

def v3d_GetProjAxis(*args) -> "Graphic3d_Vector":
    """
    * Determines the orientation vector corresponding to the predefined orientation type.

    :param Orientation:
    :type Orientation: V3d_TypeOfOrientation
    :rtype: Graphic3d_Vector

    """
    return _V3d.v3d_GetProjAxis(*args)

def v3d_ArrowOfRadius(*args) -> "void":
    """
    * Compute the graphic structure of arrow. X0,Y0,Z0 : coordinate of the arrow. DX,DY,DZ : Direction of the arrow. Alpha : Angle of arrow. Lng : Length of arrow.

    :param garrow:
    :type garrow: Handle_Graphic3d_Group &
    :param X0:
    :type X0: V3d_Coordinate
    :param Y0:
    :type Y0: V3d_Coordinate
    :param Z0:
    :type Z0: V3d_Coordinate
    :param DX:
    :type DX: V3d_Parameter
    :param DY:
    :type DY: V3d_Parameter
    :param DZ:
    :type DZ: V3d_Parameter
    :param Alpha:
    :type Alpha: Quantity_PlaneAngle
    :param Lng:
    :type Lng: V3d_Parameter
    :rtype: void

    """
    return _V3d.v3d_ArrowOfRadius(*args)

def v3d_CircleInPlane(*args) -> "void":
    """
    * Compute the graphic structure of circle. X0,Y0,Z0 : Center of circle. VX,VY,VZ : Axis of circle. Radius : Radius of circle.

    :param gcircle:
    :type gcircle: Handle_Graphic3d_Group &
    :param X0:
    :type X0: V3d_Coordinate
    :param Y0:
    :type Y0: V3d_Coordinate
    :param Z0:
    :type Z0: V3d_Coordinate
    :param VX:
    :type VX: V3d_Parameter
    :param VY:
    :type VY: V3d_Parameter
    :param VZ:
    :type VZ: V3d_Parameter
    :param Radius:
    :type Radius: V3d_Parameter
    :rtype: void

    """
    return _V3d.v3d_CircleInPlane(*args)

def v3d_SwitchViewsinWindow(*args) -> "void":
    """
    :param aPreviousView:
    :type aPreviousView: Handle_V3d_View &
    :param aNextView:
    :type aNextView: Handle_V3d_View &
    :rtype: void

    """
    return _V3d.v3d_SwitchViewsinWindow(*args)

def v3d_DrawSphere(*args) -> "void":
    """
    * test.

    :param aViewer:
    :type aViewer: Handle_V3d_Viewer &
    :param aRadius: default value is 1000
    :type aRadius: Quantity_Length
    :rtype: void

    """
    return _V3d.v3d_DrawSphere(*args)

def v3d_PickGrid(*args) -> "void":
    """
    * test.

    :param aViewer:
    :type aViewer: Handle_V3d_Viewer &
    :param aRadius: default value is 1000
    :type aRadius: Quantity_Length
    :rtype: void

    """
    return _V3d.v3d_PickGrid(*args)

def v3d_SetPlane(*args) -> "void":
    """
    * test.

    :param aViewer:
    :type aViewer: Handle_V3d_Viewer &
    :param x1:
    :type x1: Quantity_Length
    :param y1:
    :type y1: Quantity_Length
    :param z1:
    :type z1: Quantity_Length
    :param x2:
    :type x2: Quantity_Length
    :param y2:
    :type y2: Quantity_Length
    :param z2:
    :type z2: Quantity_Length
    :rtype: void

    """
    return _V3d.v3d_SetPlane(*args)

class V3d_CircularGrid(OCC.Aspect.Aspect_CircularGrid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param aViewer:
        :type aViewer: V3d_ViewerPointer &
        :param aColor:
        :type aColor: Quantity_Color &
        :param aTenthColor:
        :type aTenthColor: Quantity_Color &
        :rtype: None

        """
        _V3d.V3d_CircularGrid_swiginit(self, _V3d.new_V3d_CircularGrid(*args))

    def GraphicValues(self, *args) -> "void":
        """
        :param Radius:
        :type Radius: float &
        :param OffSet:
        :type OffSet: float &
        :rtype: None

        """
        return _V3d.V3d_CircularGrid_GraphicValues(self, *args)


    def SetGraphicValues(self, *args) -> "void":
        """
        :param Radius:
        :type Radius: float
        :param OffSet:
        :type OffSet: float
        :rtype: None

        """
        return _V3d.V3d_CircularGrid_SetGraphicValues(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_CircularGrid(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_CircularGrid
V3d_CircularGrid.GraphicValues = new_instancemethod(_V3d.V3d_CircularGrid_GraphicValues, None, V3d_CircularGrid)
V3d_CircularGrid.SetGraphicValues = new_instancemethod(_V3d.V3d_CircularGrid_SetGraphicValues, None, V3d_CircularGrid)
V3d_CircularGrid_swigregister = _V3d.V3d_CircularGrid_swigregister
V3d_CircularGrid_swigregister(V3d_CircularGrid)

class Handle_V3d_CircularGrid(OCC.Aspect.Handle_Aspect_CircularGrid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_CircularGrid_swiginit(self, _V3d.new_Handle_V3d_CircularGrid(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_CircularGrid_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_CircularGrid
Handle_V3d_CircularGrid.Nullify = new_instancemethod(_V3d.Handle_V3d_CircularGrid_Nullify, None, Handle_V3d_CircularGrid)
Handle_V3d_CircularGrid.IsNull = new_instancemethod(_V3d.Handle_V3d_CircularGrid_IsNull, None, Handle_V3d_CircularGrid)
Handle_V3d_CircularGrid._get_reference = new_instancemethod(_V3d.Handle_V3d_CircularGrid__get_reference, None, Handle_V3d_CircularGrid)
Handle_V3d_CircularGrid_swigregister = _V3d.Handle_V3d_CircularGrid_swigregister
Handle_V3d_CircularGrid_swigregister(Handle_V3d_CircularGrid)

def Handle_V3d_CircularGrid_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_CircularGrid const":
    return _V3d.Handle_V3d_CircularGrid_DownCast(AnObject)
Handle_V3d_CircularGrid_DownCast = _V3d.Handle_V3d_CircularGrid_DownCast

class V3d_ColorScale(OCC.Aspect.Aspect_ColorScale):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Returns returns ColorScale from V3d. Returns View from V3d.

        :param aMgr:
        :type aMgr: Handle_V3d_LayerMgr &
        :rtype: None

        """
        _V3d.V3d_ColorScale_swiginit(self, _V3d.new_V3d_ColorScale(*args))

    def Display(self, *args) -> "void":
        """
        :rtype: None

        """
        return _V3d.V3d_ColorScale_Display(self, *args)


    def Erase(self, *args) -> "void":
        """
        :rtype: None

        """
        return _V3d.V3d_ColorScale_Erase(self, *args)


    def IsDisplayed(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _V3d.V3d_ColorScale_IsDisplayed(self, *args)


    def TextSize(self, *args) -> "void":
        """
        :param AText:
        :type AText: TCollection_ExtendedString &
        :param AHeight:
        :type AHeight: int
        :param AWidth:
        :type AWidth: int &
        :param AnAscent:
        :type AnAscent: int &
        :param ADescent:
        :type ADescent: int &
        :rtype: None

        """
        return _V3d.V3d_ColorScale_TextSize(self, *args)


    def DrawScale(self, *args) -> "void":
        """
        :rtype: None

        """
        return _V3d.V3d_ColorScale_DrawScale(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_ColorScale(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_ColorScale
V3d_ColorScale.Display = new_instancemethod(_V3d.V3d_ColorScale_Display, None, V3d_ColorScale)
V3d_ColorScale.Erase = new_instancemethod(_V3d.V3d_ColorScale_Erase, None, V3d_ColorScale)
V3d_ColorScale.IsDisplayed = new_instancemethod(_V3d.V3d_ColorScale_IsDisplayed, None, V3d_ColorScale)
V3d_ColorScale.TextSize = new_instancemethod(_V3d.V3d_ColorScale_TextSize, None, V3d_ColorScale)
V3d_ColorScale.DrawScale = new_instancemethod(_V3d.V3d_ColorScale_DrawScale, None, V3d_ColorScale)
V3d_ColorScale_swigregister = _V3d.V3d_ColorScale_swigregister
V3d_ColorScale_swigregister(V3d_ColorScale)

class Handle_V3d_ColorScale(OCC.Aspect.Handle_Aspect_ColorScale):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_ColorScale_swiginit(self, _V3d.new_Handle_V3d_ColorScale(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_ColorScale_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_ColorScale
Handle_V3d_ColorScale.Nullify = new_instancemethod(_V3d.Handle_V3d_ColorScale_Nullify, None, Handle_V3d_ColorScale)
Handle_V3d_ColorScale.IsNull = new_instancemethod(_V3d.Handle_V3d_ColorScale_IsNull, None, Handle_V3d_ColorScale)
Handle_V3d_ColorScale._get_reference = new_instancemethod(_V3d.Handle_V3d_ColorScale__get_reference, None, Handle_V3d_ColorScale)
Handle_V3d_ColorScale_swigregister = _V3d.Handle_V3d_ColorScale_swigregister
Handle_V3d_ColorScale_swigregister(Handle_V3d_ColorScale)

def Handle_V3d_ColorScale_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_ColorScale const":
    return _V3d.Handle_V3d_ColorScale_DownCast(AnObject)
Handle_V3d_ColorScale_DownCast = _V3d.Handle_V3d_ColorScale_DownCast

class V3d_ColorScaleLayerItem(OCC.Visual3d.Visual3d_LayerItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a layer item

        :param aColorScale:
        :type aColorScale: Handle_V3d_ColorScale &
        :rtype: None

        """
        _V3d.V3d_ColorScaleLayerItem_swiginit(self, _V3d.new_V3d_ColorScaleLayerItem(*args))

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_ColorScaleLayerItem(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_ColorScaleLayerItem
V3d_ColorScaleLayerItem_swigregister = _V3d.V3d_ColorScaleLayerItem_swigregister
V3d_ColorScaleLayerItem_swigregister(V3d_ColorScaleLayerItem)

class Handle_V3d_ColorScaleLayerItem(OCC.Visual3d.Handle_Visual3d_LayerItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_ColorScaleLayerItem_swiginit(self, _V3d.new_Handle_V3d_ColorScaleLayerItem(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_ColorScaleLayerItem_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_ColorScaleLayerItem
Handle_V3d_ColorScaleLayerItem.Nullify = new_instancemethod(_V3d.Handle_V3d_ColorScaleLayerItem_Nullify, None, Handle_V3d_ColorScaleLayerItem)
Handle_V3d_ColorScaleLayerItem.IsNull = new_instancemethod(_V3d.Handle_V3d_ColorScaleLayerItem_IsNull, None, Handle_V3d_ColorScaleLayerItem)
Handle_V3d_ColorScaleLayerItem._get_reference = new_instancemethod(_V3d.Handle_V3d_ColorScaleLayerItem__get_reference, None, Handle_V3d_ColorScaleLayerItem)
Handle_V3d_ColorScaleLayerItem_swigregister = _V3d.Handle_V3d_ColorScaleLayerItem_swigregister
Handle_V3d_ColorScaleLayerItem_swigregister(Handle_V3d_ColorScaleLayerItem)

def Handle_V3d_ColorScaleLayerItem_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_ColorScaleLayerItem const":
    return _V3d.Handle_V3d_ColorScaleLayerItem_DownCast(AnObject)
Handle_V3d_ColorScaleLayerItem_DownCast = _V3d.Handle_V3d_ColorScaleLayerItem_DownCast

class V3d_LayerMgr(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        _V3d.V3d_LayerMgr_swiginit(self, _V3d.new_V3d_LayerMgr(*args))

    def Overlay(self, *args) -> "Handle_Visual3d_Layer":
        """
        :rtype: Handle_Visual3d_Layer

        """
        return _V3d.V3d_LayerMgr_Overlay(self, *args)


    def View(self, *args) -> "Handle_V3d_View":
        """
        :rtype: Handle_V3d_View

        """
        return _V3d.V3d_LayerMgr_View(self, *args)


    def ColorScaleDisplay(self, *args) -> "void":
        """
        :rtype: None

        """
        return _V3d.V3d_LayerMgr_ColorScaleDisplay(self, *args)


    def ColorScaleErase(self, *args) -> "void":
        """
        :rtype: None

        """
        return _V3d.V3d_LayerMgr_ColorScaleErase(self, *args)


    def ColorScaleIsDisplayed(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _V3d.V3d_LayerMgr_ColorScaleIsDisplayed(self, *args)


    def ColorScale(self, *args) -> "Handle_Aspect_ColorScale":
        """
        :rtype: Handle_Aspect_ColorScale

        """
        return _V3d.V3d_LayerMgr_ColorScale(self, *args)


    def Compute(self, *args) -> "void":
        """
        * Recompute layer with objects

        :rtype: None

        """
        return _V3d.V3d_LayerMgr_Compute(self, *args)


    def Resized(self, *args) -> "void":
        """
        :rtype: None

        """
        return _V3d.V3d_LayerMgr_Resized(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_LayerMgr(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_LayerMgr
V3d_LayerMgr.Overlay = new_instancemethod(_V3d.V3d_LayerMgr_Overlay, None, V3d_LayerMgr)
V3d_LayerMgr.View = new_instancemethod(_V3d.V3d_LayerMgr_View, None, V3d_LayerMgr)
V3d_LayerMgr.ColorScaleDisplay = new_instancemethod(_V3d.V3d_LayerMgr_ColorScaleDisplay, None, V3d_LayerMgr)
V3d_LayerMgr.ColorScaleErase = new_instancemethod(_V3d.V3d_LayerMgr_ColorScaleErase, None, V3d_LayerMgr)
V3d_LayerMgr.ColorScaleIsDisplayed = new_instancemethod(_V3d.V3d_LayerMgr_ColorScaleIsDisplayed, None, V3d_LayerMgr)
V3d_LayerMgr.ColorScale = new_instancemethod(_V3d.V3d_LayerMgr_ColorScale, None, V3d_LayerMgr)
V3d_LayerMgr.Compute = new_instancemethod(_V3d.V3d_LayerMgr_Compute, None, V3d_LayerMgr)
V3d_LayerMgr.Resized = new_instancemethod(_V3d.V3d_LayerMgr_Resized, None, V3d_LayerMgr)
V3d_LayerMgr_swigregister = _V3d.V3d_LayerMgr_swigregister
V3d_LayerMgr_swigregister(V3d_LayerMgr)

class Handle_V3d_LayerMgr(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_LayerMgr_swiginit(self, _V3d.new_Handle_V3d_LayerMgr(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_LayerMgr_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_LayerMgr
Handle_V3d_LayerMgr.Nullify = new_instancemethod(_V3d.Handle_V3d_LayerMgr_Nullify, None, Handle_V3d_LayerMgr)
Handle_V3d_LayerMgr.IsNull = new_instancemethod(_V3d.Handle_V3d_LayerMgr_IsNull, None, Handle_V3d_LayerMgr)
Handle_V3d_LayerMgr._get_reference = new_instancemethod(_V3d.Handle_V3d_LayerMgr__get_reference, None, Handle_V3d_LayerMgr)
Handle_V3d_LayerMgr_swigregister = _V3d.Handle_V3d_LayerMgr_swigregister
Handle_V3d_LayerMgr_swigregister(Handle_V3d_LayerMgr)

def Handle_V3d_LayerMgr_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_LayerMgr const":
    return _V3d.Handle_V3d_LayerMgr_DownCast(AnObject)
Handle_V3d_LayerMgr_DownCast = _V3d.Handle_V3d_LayerMgr_DownCast

class V3d_Light(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetColor(self, *args) -> "void":
        """
        * Defines the colour of a light source according to the type of colour definition and the three corresponding values.

        :param Type:
        :type Type: Quantity_TypeOfColor
        :param V1:
        :type V1: Quantity_Parameter
        :param V2:
        :type V2: Quantity_Parameter
        :param V3:
        :type V3: Quantity_Parameter
        :rtype: None

        * Defines the colour of a light source by giving the name of the colour in the form Quantity_NOC_xxxx .

        :param Name:
        :type Name: Quantity_NameOfColor
        :rtype: None

        * Defines the colour of a light source by giving the basic colour.

        :param Name:
        :type Name: Quantity_Color &
        :rtype: None

        """
        return _V3d.V3d_Light_SetColor(self, *args)


    def Color(self, *args) -> "Quantity_Color":
        """
        * Returns the colour of the light source depending of the color type.

        :param Type:
        :type Type: Quantity_TypeOfColor
        :param V1:
        :type V1: Quantity_Parameter &
        :param V2:
        :type V2: Quantity_Parameter &
        :param V3:
        :type V3: Quantity_Parameter &
        :rtype: None

        * Returns the colour of the light source.

        :param Name:
        :type Name: Quantity_NameOfColor &
        :rtype: None

        * Returns the colour of the light source.

        :rtype: Quantity_Color

        """
        return _V3d.V3d_Light_Color(self, *args)


    def Type(self, *args) -> "V3d_TypeOfLight":
        """
        * Returns the Type of the Light

        :rtype: V3d_TypeOfLight

        """
        return _V3d.V3d_Light_Type(self, *args)


    def Headlight(self, *args) -> "Standard_Boolean":
        """
        * returns true if the light is a headlight

        :rtype: bool

        """
        return _V3d.V3d_Light_Headlight(self, *args)


    def SetHeadlight(self, *args) -> "void":
        """
        * Setup headlight flag.

        :param theValue:
        :type theValue: bool
        :rtype: None

        """
        return _V3d.V3d_Light_SetHeadlight(self, *args)


    def IsDisplayed(self, *args) -> "Standard_Boolean":
        """
        * Returns True when a light representation is displayed

        :rtype: bool

        """
        return _V3d.V3d_Light_IsDisplayed(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_Light(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_Light
V3d_Light.SetColor = new_instancemethod(_V3d.V3d_Light_SetColor, None, V3d_Light)
V3d_Light.Color = new_instancemethod(_V3d.V3d_Light_Color, None, V3d_Light)
V3d_Light.Type = new_instancemethod(_V3d.V3d_Light_Type, None, V3d_Light)
V3d_Light.Headlight = new_instancemethod(_V3d.V3d_Light_Headlight, None, V3d_Light)
V3d_Light.SetHeadlight = new_instancemethod(_V3d.V3d_Light_SetHeadlight, None, V3d_Light)
V3d_Light.IsDisplayed = new_instancemethod(_V3d.V3d_Light_IsDisplayed, None, V3d_Light)
V3d_Light_swigregister = _V3d.V3d_Light_swigregister
V3d_Light_swigregister(V3d_Light)

class Handle_V3d_Light(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_Light_swiginit(self, _V3d.new_Handle_V3d_Light(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_Light_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_Light
Handle_V3d_Light.Nullify = new_instancemethod(_V3d.Handle_V3d_Light_Nullify, None, Handle_V3d_Light)
Handle_V3d_Light.IsNull = new_instancemethod(_V3d.Handle_V3d_Light_IsNull, None, Handle_V3d_Light)
Handle_V3d_Light._get_reference = new_instancemethod(_V3d.Handle_V3d_Light__get_reference, None, Handle_V3d_Light)
Handle_V3d_Light_swigregister = _V3d.Handle_V3d_Light_swigregister
Handle_V3d_Light_swigregister(Handle_V3d_Light)

def Handle_V3d_Light_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_Light const":
    return _V3d.Handle_V3d_Light_DownCast(AnObject)
Handle_V3d_Light_DownCast = _V3d.Handle_V3d_Light_DownCast

class V3d_ListOfTransient(OCC.TColStd.TColStd_ListOfTransient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Contains(self, *args) -> "Standard_Boolean":
        """
        * Return true if theObject is stored in the list

        :param theObject:
        :type theObject: Handle_Standard_Transient &
        :rtype: bool

        """
        return _V3d.V3d_ListOfTransient_Contains(self, *args)


    def Remove(self, *args) -> "void":
        """
        * Remove all elements equal to theObject from the list

        :param theObject:
        :type theObject: Handle_Standard_Transient &
        :rtype: None

        """
        return _V3d.V3d_ListOfTransient_Remove(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_ListOfTransient
V3d_ListOfTransient.Contains = new_instancemethod(_V3d.V3d_ListOfTransient_Contains, None, V3d_ListOfTransient)
V3d_ListOfTransient.Remove = new_instancemethod(_V3d.V3d_ListOfTransient_Remove, None, V3d_ListOfTransient)
V3d_ListOfTransient_swigregister = _V3d.V3d_ListOfTransient_swigregister
V3d_ListOfTransient_swigregister(V3d_ListOfTransient)

class V3d_Plane(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a clipping plane from plane coefficients.

        :param theA: default value is 0.0
        :type theA: Quantity_Parameter
        :param theB: default value is 0.0
        :type theB: Quantity_Parameter
        :param theC: default value is 1.0
        :type theC: Quantity_Parameter
        :param theD: default value is 0.0
        :type theD: Quantity_Parameter
        :rtype: None

        """
        _V3d.V3d_Plane_swiginit(self, _V3d.new_V3d_Plane(*args))

    def SetPlane(self, *args) -> "void":
        """
        * Change plane equation.

        :param theA:
        :type theA: Quantity_Parameter
        :param theB:
        :type theB: Quantity_Parameter
        :param theC:
        :type theC: Quantity_Parameter
        :param theD:
        :type theD: Quantity_Parameter
        :rtype: None

        """
        return _V3d.V3d_Plane_SetPlane(self, *args)


    def Display(self, *args) -> "void":
        """
        * Display the plane representation in the choosen view.

        :param theView:
        :type theView: Handle_V3d_View &
        :param theColor: default value is Quantity_NOC_GRAY
        :type theColor: Quantity_Color &
        :rtype: void

        """
        return _V3d.V3d_Plane_Display(self, *args)


    def Erase(self, *args) -> "void":
        """
        * Erase the plane representation.

        :rtype: None

        """
        return _V3d.V3d_Plane_Erase(self, *args)


    def Plane(self, *args) -> "void":
        """
        * Returns the parameters of the plane.

        :param theA:
        :type theA: Quantity_Parameter &
        :param theB:
        :type theB: Quantity_Parameter &
        :param theC:
        :type theC: Quantity_Parameter &
        :param theD:
        :type theD: Quantity_Parameter &
        :rtype: None

        """
        return _V3d.V3d_Plane_Plane(self, *args)


    def IsDisplayed(self, *args) -> "Standard_Boolean":
        """
        * Returns True when the plane representation is displayed.

        :rtype: bool

        """
        return _V3d.V3d_Plane_IsDisplayed(self, *args)


    def ClipPlane(self, *args) -> "Handle_Graphic3d_ClipPlane":
        """
        * Use this method to pass clipping plane implementation for standard clipping workflow. returns clipping plane implementation handle.

        :rtype: Handle_Graphic3d_ClipPlane

        """
        return _V3d.V3d_Plane_ClipPlane(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_Plane(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_Plane
V3d_Plane.SetPlane = new_instancemethod(_V3d.V3d_Plane_SetPlane, None, V3d_Plane)
V3d_Plane.Display = new_instancemethod(_V3d.V3d_Plane_Display, None, V3d_Plane)
V3d_Plane.Erase = new_instancemethod(_V3d.V3d_Plane_Erase, None, V3d_Plane)
V3d_Plane.Plane = new_instancemethod(_V3d.V3d_Plane_Plane, None, V3d_Plane)
V3d_Plane.IsDisplayed = new_instancemethod(_V3d.V3d_Plane_IsDisplayed, None, V3d_Plane)
V3d_Plane.ClipPlane = new_instancemethod(_V3d.V3d_Plane_ClipPlane, None, V3d_Plane)
V3d_Plane_swigregister = _V3d.V3d_Plane_swigregister
V3d_Plane_swigregister(V3d_Plane)

class Handle_V3d_Plane(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_Plane_swiginit(self, _V3d.new_Handle_V3d_Plane(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_Plane_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_Plane
Handle_V3d_Plane.Nullify = new_instancemethod(_V3d.Handle_V3d_Plane_Nullify, None, Handle_V3d_Plane)
Handle_V3d_Plane.IsNull = new_instancemethod(_V3d.Handle_V3d_Plane_IsNull, None, Handle_V3d_Plane)
Handle_V3d_Plane._get_reference = new_instancemethod(_V3d.Handle_V3d_Plane__get_reference, None, Handle_V3d_Plane)
Handle_V3d_Plane_swigregister = _V3d.Handle_V3d_Plane_swigregister
Handle_V3d_Plane_swigregister(Handle_V3d_Plane)

def Handle_V3d_Plane_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_Plane const":
    return _V3d.Handle_V3d_Plane_DownCast(AnObject)
Handle_V3d_Plane_DownCast = _V3d.Handle_V3d_Plane_DownCast

class V3d_RectangularGrid(OCC.Aspect.Aspect_RectangularGrid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param aViewer:
        :type aViewer: V3d_ViewerPointer &
        :param aColor:
        :type aColor: Quantity_Color &
        :param aTenthColor:
        :type aTenthColor: Quantity_Color &
        :rtype: None

        """
        _V3d.V3d_RectangularGrid_swiginit(self, _V3d.new_V3d_RectangularGrid(*args))

    def GraphicValues(self, *args) -> "void":
        """
        :param XSize:
        :type XSize: float &
        :param YSize:
        :type YSize: float &
        :param OffSet:
        :type OffSet: float &
        :rtype: None

        """
        return _V3d.V3d_RectangularGrid_GraphicValues(self, *args)


    def SetGraphicValues(self, *args) -> "void":
        """
        :param XSize:
        :type XSize: float
        :param YSize:
        :type YSize: float
        :param OffSet:
        :type OffSet: float
        :rtype: None

        """
        return _V3d.V3d_RectangularGrid_SetGraphicValues(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_RectangularGrid(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_RectangularGrid
V3d_RectangularGrid.GraphicValues = new_instancemethod(_V3d.V3d_RectangularGrid_GraphicValues, None, V3d_RectangularGrid)
V3d_RectangularGrid.SetGraphicValues = new_instancemethod(_V3d.V3d_RectangularGrid_SetGraphicValues, None, V3d_RectangularGrid)
V3d_RectangularGrid_swigregister = _V3d.V3d_RectangularGrid_swigregister
V3d_RectangularGrid_swigregister(V3d_RectangularGrid)

class Handle_V3d_RectangularGrid(OCC.Aspect.Handle_Aspect_RectangularGrid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_RectangularGrid_swiginit(self, _V3d.new_Handle_V3d_RectangularGrid(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_RectangularGrid_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_RectangularGrid
Handle_V3d_RectangularGrid.Nullify = new_instancemethod(_V3d.Handle_V3d_RectangularGrid_Nullify, None, Handle_V3d_RectangularGrid)
Handle_V3d_RectangularGrid.IsNull = new_instancemethod(_V3d.Handle_V3d_RectangularGrid_IsNull, None, Handle_V3d_RectangularGrid)
Handle_V3d_RectangularGrid._get_reference = new_instancemethod(_V3d.Handle_V3d_RectangularGrid__get_reference, None, Handle_V3d_RectangularGrid)
Handle_V3d_RectangularGrid_swigregister = _V3d.Handle_V3d_RectangularGrid_swigregister
Handle_V3d_RectangularGrid_swigregister(Handle_V3d_RectangularGrid)

def Handle_V3d_RectangularGrid_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_RectangularGrid const":
    return _V3d.Handle_V3d_RectangularGrid_DownCast(AnObject)
Handle_V3d_RectangularGrid_DownCast = _V3d.Handle_V3d_RectangularGrid_DownCast

class V3d_View(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the view.

        :param VM:
        :type VM: Handle_V3d_Viewer &
        :param Type: default value is V3d_ORTHOGRAPHIC
        :type Type: V3d_TypeOfView
        :rtype: None

        * Initializes the view by copying.

        :param theVM:
        :type theVM: Handle_V3d_Viewer &
        :param theView:
        :type theView: Handle_V3d_View &
        :rtype: None

        """
        _V3d.V3d_View_swiginit(self, _V3d.new_V3d_View(*args))

    def SetWindow(self, *args) -> "void":
        """
        * Activates the view in the window specified and Map the Window to the screen. Warning! raises MultiplyDefined from Standard if the view is already activated in a window. Warning: The view is centered and resized to preserve the height/width ratio of the window.

        :param IdWin:
        :type IdWin: Handle_Aspect_Window &
        :rtype: None

        * Activates the view in the specified Window If <aContext> is not NULL the graphic context is used to draw something in this view. Otherwise an internal graphic context is created. If <aDisplayCB> is not NULL then a user display CB is call at the end of the OCC graphic traversal and just before the swap of buffers. The <aClientData> is pass to this call back. Warning! raises MultiplyDefined from Standard if the view is already activated in a window. Warning: The view is centered and resized to preserve the height/width ratio of the window.

        :param aWindow:
        :type aWindow: Handle_Aspect_Window &
        :param aContext:
        :type aContext: Aspect_RenderingContext
        :param aDisplayCB:
        :type aDisplayCB: Aspect_GraphicCallbackProc &
        :param aClientData:
        :type aClientData: Standard_Address
        :rtype: None

        """
        return _V3d.V3d_View_SetWindow(self, *args)


    def SetMagnify(self, *args) -> "void":
        """
        :param IdWin:
        :type IdWin: Handle_Aspect_Window &
        :param aPreviousView:
        :type aPreviousView: Handle_V3d_View &
        :param x1:
        :type x1: int
        :param y1:
        :type y1: int
        :param x2:
        :type x2: int
        :param y2:
        :type y2: int
        :rtype: None

        """
        return _V3d.V3d_View_SetMagnify(self, *args)


    def Remove(self, *args) -> "void":
        """
        * Destroys the view.

        :rtype: None

        """
        return _V3d.V3d_View_Remove(self, *args)


    def Update(self, *args) -> "void":
        """
        * Deprecated, Redraw() should be used instead.

        :rtype: None

        """
        return _V3d.V3d_View_Update(self, *args)


    def RedrawImmediate(self, *args) -> "void":
        """
        * Updates layer of immediate presentations.

        :rtype: None

        """
        return _V3d.V3d_View_RedrawImmediate(self, *args)


    def Invalidate(self, *args) -> "void":
        """
        * Invalidates view content but does not redraw it.

        :rtype: None

        """
        return _V3d.V3d_View_Invalidate(self, *args)


    def Redraw(self, *args) -> "void":
        """
        * Redisplays the view even if there has not been any modification. Must be called if the view is shown. (Ex: DeIconification ) .

        :rtype: None

        * Redisplays the view area after esxposure. [x,y] define the min xy area position [width,height] the size of the area in pixel unit.

        :param x:
        :type x: int
        :param y:
        :type y: int
        :param width:
        :type width: int
        :param height:
        :type height: int
        :rtype: None

        """
        return _V3d.V3d_View_Redraw(self, *args)


    def MustBeResized(self, *args) -> "void":
        """
        * Must be called when the window supporting the view changes size. if the view is not mapped on a window. Warning: The view is centered and resized to preserve the height/width ratio of the window.

        :rtype: None

        """
        return _V3d.V3d_View_MustBeResized(self, *args)


    def DoMapping(self, *args) -> "void":
        """
        * Must be called when the window supporting the view is mapped or unmapped.

        :rtype: None

        """
        return _V3d.V3d_View_DoMapping(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns the status of the view regarding the displayed structures inside Returns True is The View is empty

        :rtype: bool

        """
        return _V3d.V3d_View_IsEmpty(self, *args)


    def UpdateLights(self, *args) -> "void":
        """
        * Updates the lights of the view. The view is redrawn.

        :rtype: None

        """
        return _V3d.V3d_View_UpdateLights(self, *args)


    def AutoZFit(self, *args) -> "void":
        """
        * If automatic z-range fitting is turned on, adjusts Z-min and Z-max projection volume planes with call to ZFitAll.

        :rtype: None

        """
        return _V3d.V3d_View_AutoZFit(self, *args)


    def ZFitAll(self, *args) -> "void":
        """
        * Change Z-min and Z-max planes of projection volume to match the displayed objects.

        :param theScaleFactor: default value is 1.0
        :type theScaleFactor: float
        :rtype: None

        """
        return _V3d.V3d_View_ZFitAll(self, *args)


    def SetBackgroundColor(self, *args) -> "void":
        """
        * Defines the background colour of the view by supplying : the colour definition type, and the three corresponding values.

        :param Type:
        :type Type: Quantity_TypeOfColor
        :param V1:
        :type V1: Quantity_Parameter
        :param V2:
        :type V2: Quantity_Parameter
        :param V3:
        :type V3: Quantity_Parameter
        :rtype: None

        * Defines the background colour of the view by supplying : the colour object.

        :param Color:
        :type Color: Quantity_Color &
        :rtype: None

        * Defines the background colour of the view by supplying : the colour name in the form Quantity_NOC_xxxx .

        :param Name:
        :type Name: Quantity_NameOfColor
        :rtype: None

        """
        return _V3d.V3d_View_SetBackgroundColor(self, *args)


    def SetBgGradientColors(self, *args) -> "void":
        """
        * Defines the gradient background colours of the view by supplying : two colour objects, and fill method (horizontal by default)

        :param Color1:
        :type Color1: Quantity_Color &
        :param Color2:
        :type Color2: Quantity_Color &
        :param FillStyle: default value is Aspect_GFM_HOR
        :type FillStyle: Aspect_GradientFillMethod
        :param update: default value is Standard_False
        :type update: bool
        :rtype: None

        * Defines the gradient background colours of the view by supplying : two colour names in the form Quantity_NOC_xxxx, and fill method (horizontal by default)

        :param Color1:
        :type Color1: Quantity_NameOfColor
        :param Color2:
        :type Color2: Quantity_NameOfColor
        :param FillStyle: default value is Aspect_GFM_HOR
        :type FillStyle: Aspect_GradientFillMethod
        :param update: default value is Standard_False
        :type update: bool
        :rtype: None

        """
        return _V3d.V3d_View_SetBgGradientColors(self, *args)


    def SetBgGradientStyle(self, *args) -> "void":
        """
        * Defines the gradient background fill method of the view

        :param AMethod: default value is Aspect_GFM_HOR
        :type AMethod: Aspect_GradientFillMethod
        :param update: default value is Standard_False
        :type update: bool
        :rtype: None

        """
        return _V3d.V3d_View_SetBgGradientStyle(self, *args)


    def SetBackgroundImage(self, *args) -> "void":
        """
        * Defines the background texture of the view by supplying : texture image file name, and fill method (centered by default)

        :param FileName:
        :type FileName: char *
        :param FillStyle: default value is Aspect_FM_CENTERED
        :type FillStyle: Aspect_FillMethod
        :param update: default value is Standard_False
        :type update: bool
        :rtype: None

        """
        return _V3d.V3d_View_SetBackgroundImage(self, *args)


    def SetBgImageStyle(self, *args) -> "void":
        """
        * Defines the textured background fill method of the view

        :param FillStyle:
        :type FillStyle: Aspect_FillMethod
        :param update: default value is Standard_False
        :type update: bool
        :rtype: None

        """
        return _V3d.V3d_View_SetBgImageStyle(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Definition of an axis from its origin and its orientation . This will be the current axis for rotations and movements. Warning! raises BadValue from V3d if the vector normal is NULL. .

        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :param Vx:
        :type Vx: Quantity_Parameter
        :param Vy:
        :type Vy: Quantity_Parameter
        :param Vz:
        :type Vz: Quantity_Parameter
        :rtype: None

        """
        return _V3d.V3d_View_SetAxis(self, *args)


    def SetShadingModel(self, *args) -> "void":
        """
        * Defines the shading model for the visualisation ZBUFFER mode. Various models are available.

        :param Model:
        :type Model: V3d_TypeOfShadingModel
        :rtype: None

        """
        return _V3d.V3d_View_SetShadingModel(self, *args)


    def SetSurfaceDetail(self, *args) -> "void":
        """
        * select the kind of rendering for texture mapping no texture mapping by default

        :param SurfaceDetail:
        :type SurfaceDetail: V3d_TypeOfSurfaceDetail
        :rtype: None

        """
        return _V3d.V3d_View_SetSurfaceDetail(self, *args)


    def SetTextureEnv(self, *args) -> "void":
        """
        * set the environment texture to use no environment texture by default

        :param ATexture:
        :type ATexture: Handle_Graphic3d_TextureEnv &
        :rtype: None

        """
        return _V3d.V3d_View_SetTextureEnv(self, *args)


    def SetVisualization(self, *args) -> "void":
        """
        * Defines the visualisation mode in the view.

        :param Mode:
        :type Mode: V3d_TypeOfVisualization
        :rtype: None

        """
        return _V3d.V3d_View_SetVisualization(self, *args)


    def SetAntialiasingOn(self, *args) -> "void":
        """
        * Activates antialiasing in the view.

        :rtype: None

        """
        return _V3d.V3d_View_SetAntialiasingOn(self, *args)


    def SetAntialiasingOff(self, *args) -> "void":
        """
        * Desactivates antialiasing in the view.

        :rtype: None

        """
        return _V3d.V3d_View_SetAntialiasingOff(self, *args)


    def SetZClippingDepth(self, *args) -> "void":
        """
        * Defines the depth of the medium clipping plane.

        :param Depth:
        :type Depth: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_View_SetZClippingDepth(self, *args)


    def SetZClippingWidth(self, *args) -> "void":
        """
        * Defines the thicknes around the medium clippling plane. .

        :param Width:
        :type Width: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_View_SetZClippingWidth(self, *args)


    def SetZClippingType(self, *args) -> "void":
        """
        * Defines the type of ZClipping.

        :param Type:
        :type Type: V3d_TypeOfZclipping
        :rtype: None

        """
        return _V3d.V3d_View_SetZClippingType(self, *args)


    def SetZCueingDepth(self, *args) -> "void":
        """
        * Defines the depth of the medium plane.

        :param Depth:
        :type Depth: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_View_SetZCueingDepth(self, *args)


    def SetZCueingWidth(self, *args) -> "void":
        """
        * Defines the thickness around the medium plane.

        :param Width:
        :type Width: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_View_SetZCueingWidth(self, *args)


    def SetZCueingOn(self, *args) -> "void":
        """
        * Activates ZCueing in the view.

        :rtype: None

        """
        return _V3d.V3d_View_SetZCueingOn(self, *args)


    def SetZCueingOff(self, *args) -> "void":
        """
        * Desactivates ZCueing in the view.

        :rtype: None

        """
        return _V3d.V3d_View_SetZCueingOff(self, *args)


    def SetLightOn(self, *args) -> "void":
        """
        * Activates MyLight in the view.

        :param MyLight:
        :type MyLight: Handle_V3d_Light &
        :rtype: None

        * Activates all the lights defined in this view.

        :rtype: None

        """
        return _V3d.V3d_View_SetLightOn(self, *args)


    def SetLightOff(self, *args) -> "void":
        """
        * Desactivate MyLight in this view.

        :param MyLight:
        :type MyLight: Handle_V3d_Light &
        :rtype: None

        * Deactivate all the Lights defined in this view.

        :rtype: None

        """
        return _V3d.V3d_View_SetLightOff(self, *args)


    def IsActiveLight(self, *args) -> "Standard_Boolean":
        """
        * Returns True when the light is active in this view.

        :param aLight:
        :type aLight: Handle_V3d_Light &
        :rtype: bool

        """
        return _V3d.V3d_View_IsActiveLight(self, *args)


    def SetTransparency(self, *args) -> "void":
        """
        * Activate/Deactivate the transparency in this view.

        :param AnActivity: default value is Standard_False
        :type AnActivity: bool
        :rtype: None

        """
        return _V3d.V3d_View_SetTransparency(self, *args)


    def SetImmediateUpdate(self, *args) -> "Standard_Boolean":
        """
        * sets the immediate update mode and returns the previous one.

        :param theImmediateUpdate:
        :type theImmediateUpdate: bool
        :rtype: bool

        """
        return _V3d.V3d_View_SetImmediateUpdate(self, *args)


    def ZBufferTriedronSetup(self, *args) -> "void":
        """
        * Customization of the ZBUFFER Triedron. XColor,YColor,ZColor - colors of axis SizeRatio - ratio of decreasing of the trihedron size when its phisical position comes out of the view AxisDiametr - diameter relatively to axis length NbFacettes - number of facettes of cylinders and cones

        :param XColor: default value is Quantity_NOC_RED
        :type XColor: Quantity_NameOfColor
        :param YColor: default value is Quantity_NOC_GREEN
        :type YColor: Quantity_NameOfColor
        :param ZColor: default value is Quantity_NOC_BLUE1
        :type ZColor: Quantity_NameOfColor
        :param SizeRatio: default value is 0.8
        :type SizeRatio: float
        :param AxisDiametr: default value is 0.05
        :type AxisDiametr: float
        :param NbFacettes: default value is 12
        :type NbFacettes: int
        :rtype: None

        """
        return _V3d.V3d_View_ZBufferTriedronSetup(self, *args)


    def TriedronDisplay(self, *args) -> "void":
        """
        * Display of the Triedron. Initialize position, color and length of Triedron axes. The scale is a percent of the window width.

        :param APosition: default value is Aspect_TOTP_CENTER
        :type APosition: Aspect_TypeOfTriedronPosition
        :param AColor: default value is Quantity_NOC_WHITE
        :type AColor: Quantity_NameOfColor
        :param AScale: default value is 0.02
        :type AScale: float
        :param AMode: default value is V3d_WIREFRAME
        :type AMode: V3d_TypeOfVisualization
        :rtype: None

        """
        return _V3d.V3d_View_TriedronDisplay(self, *args)


    def TriedronErase(self, *args) -> "void":
        """
        * Erases the Triedron.

        :rtype: None

        """
        return _V3d.V3d_View_TriedronErase(self, *args)


    def TriedronEcho(self, *args) -> "void":
        """
        * Highlights the echo zone of the Triedron.

        :param AType: default value is Aspect_TOTE_NONE
        :type AType: Aspect_TypeOfTriedronEcho
        :rtype: None

        """
        return _V3d.V3d_View_TriedronEcho(self, *args)


    def GetGraduatedTrihedron(self, *args) -> "void":
        """
        * Returns data of a graduated trihedron.

        :param xname:
        :type xname: TCollection_ExtendedString &
        :param yname:
        :type yname: TCollection_ExtendedString &
        :param zname:
        :type zname: TCollection_ExtendedString &
        :param xdrawname:
        :type xdrawname: bool
        :param ydrawname:
        :type ydrawname: bool
        :param zdrawname:
        :type zdrawname: bool
        :param xdrawvalues:
        :type xdrawvalues: bool
        :param ydrawvalues:
        :type ydrawvalues: bool
        :param zdrawvalues:
        :type zdrawvalues: bool
        :param drawgrid:
        :type drawgrid: bool
        :param drawaxes:
        :type drawaxes: bool
        :param nbx:
        :type nbx: int &
        :param nby:
        :type nby: int &
        :param nbz:
        :type nbz: int &
        :param xoffset:
        :type xoffset: int &
        :param yoffset:
        :type yoffset: int &
        :param zoffset:
        :type zoffset: int &
        :param xaxisoffset:
        :type xaxisoffset: int &
        :param yaxisoffset:
        :type yaxisoffset: int &
        :param zaxisoffset:
        :type zaxisoffset: int &
        :param xdrawtickmarks:
        :type xdrawtickmarks: bool
        :param ydrawtickmarks:
        :type ydrawtickmarks: bool
        :param zdrawtickmarks:
        :type zdrawtickmarks: bool
        :param xtickmarklength:
        :type xtickmarklength: int &
        :param ytickmarklength:
        :type ytickmarklength: int &
        :param ztickmarklength:
        :type ztickmarklength: int &
        :param gridcolor:
        :type gridcolor: Quantity_Color &
        :param xnamecolor:
        :type xnamecolor: Quantity_Color &
        :param ynamecolor:
        :type ynamecolor: Quantity_Color &
        :param znamecolor:
        :type znamecolor: Quantity_Color &
        :param xcolor:
        :type xcolor: Quantity_Color &
        :param ycolor:
        :type ycolor: Quantity_Color &
        :param zcolor:
        :type zcolor: Quantity_Color &
        :param fontOfNames:
        :type fontOfNames: TCollection_AsciiString &
        :param styleOfNames:
        :type styleOfNames: Font_FontAspect &
        :param sizeOfNames:
        :type sizeOfNames: int &
        :param fontOfValues:
        :type fontOfValues: TCollection_AsciiString &
        :param styleOfValues:
        :type styleOfValues: Font_FontAspect &
        :param sizeOfValues:
        :type sizeOfValues: int &
        :rtype: None

        """
        return _V3d.V3d_View_GetGraduatedTrihedron(self, *args)


    def GraduatedTrihedronDisplay(self, *args) -> "void":
        """
        * Displays a graduated trihedron.

        :param xname: default value is 'X'
        :type xname: TCollection_ExtendedString &
        :param yname: default value is 'Y'
        :type yname: TCollection_ExtendedString &
        :param zname: default value is 'Z'
        :type zname: TCollection_ExtendedString &
        :param xdrawname: default value is Standard_True
        :type xdrawname: bool
        :param ydrawname: default value is Standard_True
        :type ydrawname: bool
        :param zdrawname: default value is Standard_True
        :type zdrawname: bool
        :param xdrawvalues: default value is Standard_True
        :type xdrawvalues: bool
        :param ydrawvalues: default value is Standard_True
        :type ydrawvalues: bool
        :param zdrawvalues: default value is Standard_True
        :type zdrawvalues: bool
        :param drawgrid: default value is Standard_True
        :type drawgrid: bool
        :param drawaxes: default value is Standard_True
        :type drawaxes: bool
        :param nbx: default value is 3
        :type nbx: int
        :param nby: default value is 3
        :type nby: int
        :param nbz: default value is 3
        :type nbz: int
        :param xoffset: default value is 10
        :type xoffset: int
        :param yoffset: default value is 10
        :type yoffset: int
        :param zoffset: default value is 10
        :type zoffset: int
        :param xaxisoffset: default value is 30
        :type xaxisoffset: int
        :param yaxisoffset: default value is 30
        :type yaxisoffset: int
        :param zaxisoffset: default value is 30
        :type zaxisoffset: int
        :param xdrawtickmarks: default value is Standard_True
        :type xdrawtickmarks: bool
        :param ydrawtickmarks: default value is Standard_True
        :type ydrawtickmarks: bool
        :param zdrawtickmarks: default value is Standard_True
        :type zdrawtickmarks: bool
        :param xtickmarklength: default value is 10
        :type xtickmarklength: int
        :param ytickmarklength: default value is 10
        :type ytickmarklength: int
        :param ztickmarklength: default value is 10
        :type ztickmarklength: int
        :param gridcolor: default value is Quantity_NOC_WHITE
        :type gridcolor: Quantity_Color &
        :param xnamecolor: default value is Quantity_NOC_RED
        :type xnamecolor: Quantity_Color &
        :param ynamecolor: default value is Quantity_NOC_GREEN
        :type ynamecolor: Quantity_Color &
        :param znamecolor: default value is Quantity_NOC_BLUE1
        :type znamecolor: Quantity_Color &
        :param xcolor: default value is Quantity_NOC_RED
        :type xcolor: Quantity_Color &
        :param ycolor: default value is Quantity_NOC_GREEN
        :type ycolor: Quantity_Color &
        :param zcolor: default value is Quantity_NOC_BLUE1
        :type zcolor: Quantity_Color &
        :param fontOfNames: default value is 'Arial'
        :type fontOfNames: TCollection_AsciiString &
        :param styleOfNames: default value is Font_FA_Bold
        :type styleOfNames: Font_FontAspect
        :param sizeOfNames: default value is 12
        :type sizeOfNames: int
        :param fontOfValues: default value is 'Arial'
        :type fontOfValues: TCollection_AsciiString &
        :param styleOfValues: default value is Font_FA_Regular
        :type styleOfValues: Font_FontAspect
        :param sizeOfValues: default value is 12
        :type sizeOfValues: int
        :rtype: None

        """
        return _V3d.V3d_View_GraduatedTrihedronDisplay(self, *args)


    def GraduatedTrihedronErase(self, *args) -> "void":
        """
        * Erases a graduated trihedron from the view.

        :rtype: None

        """
        return _V3d.V3d_View_GraduatedTrihedronErase(self, *args)


    def SetLayerMgr(self, *args) -> "void":
        """
        :param aMgr:
        :type aMgr: Handle_V3d_LayerMgr &
        :rtype: None

        """
        return _V3d.V3d_View_SetLayerMgr(self, *args)


    def ColorScaleDisplay(self, *args) -> "void":
        """
        :rtype: None

        """
        return _V3d.V3d_View_ColorScaleDisplay(self, *args)


    def ColorScaleErase(self, *args) -> "void":
        """
        :rtype: None

        """
        return _V3d.V3d_View_ColorScaleErase(self, *args)


    def ColorScaleIsDisplayed(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _V3d.V3d_View_ColorScaleIsDisplayed(self, *args)


    def ColorScale(self, *args) -> "Handle_Aspect_ColorScale":
        """
        :rtype: Handle_Aspect_ColorScale

        """
        return _V3d.V3d_View_ColorScale(self, *args)


    def SetFront(self, *args) -> "void":
        """
        * modify the Projection of the view perpendicularly to the privileged plane of the viewer.

        :rtype: None

        """
        return _V3d.V3d_View_SetFront(self, *args)


    def Rotate(self, *args) -> "void":
        """
        * Rotates the eye about the coordinate system of reference of the screen for which the origin is the view point of the projection, with a relative angular value in RADIANS with respect to the initial position expressed by Start = Standard_True Warning! raises BadValue from V3d If the eye, the view point, or the high point are aligned or confused.

        :param Ax:
        :type Ax: Quantity_PlaneAngle
        :param Ay:
        :type Ay: Quantity_PlaneAngle
        :param Az:
        :type Az: Quantity_PlaneAngle
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Rotates the eye about the coordinate system of reference of the screen for which the origin is Gravity point {X,Y,Z}, with a relative angular value in RADIANS with respect to the initial position expressed by Start = Standard_True If the eye, the view point, or the high point are aligned or confused.

        :param Ax:
        :type Ax: Quantity_PlaneAngle
        :param Ay:
        :type Ay: Quantity_PlaneAngle
        :param Az:
        :type Az: Quantity_PlaneAngle
        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Rotates the eye about one of the coordinate axes of of the view for which the origin is the Gravity point{X,Y,Z} with an relative angular value in RADIANS with respect to the initial position expressed by Start = Standard_True

        :param Axe:
        :type Axe: V3d_TypeOfAxe
        :param Angle:
        :type Angle: Quantity_PlaneAngle
        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Rotates the eye about one of the coordinate axes of of the view for which the origin is the view point of the projection with an relative angular value in RADIANS with respect to the initial position expressed by Start = Standard_True

        :param Axe:
        :type Axe: V3d_TypeOfAxe
        :param Angle:
        :type Angle: Quantity_PlaneAngle
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Rotates the eye around the current axis a relative angular value in RADIANS with respect to the initial position expressed by Start = Standard_True

        :param Angle:
        :type Angle: Quantity_PlaneAngle
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        """
        return _V3d.V3d_View_Rotate(self, *args)


    def Move(self, *args) -> "void":
        """
        * Movement of the eye parallel to the coordinate system of reference of the screen a distance relative to the initial position expressed by Start = Standard_True.

        :param Dx:
        :type Dx: Quantity_Length
        :param Dy:
        :type Dy: Quantity_Length
        :param Dz:
        :type Dz: Quantity_Length
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Movement of the eye parallel to one of the axes of the coordinate system of reference of the view a distance relative to the initial position expressed by Start = Standard_True.

        :param Axe:
        :type Axe: V3d_TypeOfAxe
        :param Length:
        :type Length: Quantity_Length
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Movement of the eye parllel to the current axis a distance relative to the initial position expressed by Start = Standard_True

        :param Length:
        :type Length: Quantity_Length
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        """
        return _V3d.V3d_View_Move(self, *args)


    def Translate(self, *args) -> "void":
        """
        * Movement of the ye and the view point parallel to the frame of reference of the screen a distance relative to the initial position expressed by Start = Standard_True

        :param Dx:
        :type Dx: Quantity_Length
        :param Dy:
        :type Dy: Quantity_Length
        :param Dz:
        :type Dz: Quantity_Length
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Movement of the eye and the view point parallel to one of the axes of the fame of reference of the view a distance relative to the initial position expressed by Start = Standard_True

        :param Axe:
        :type Axe: V3d_TypeOfAxe
        :param Length:
        :type Length: Quantity_Length
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Movement of the eye and view point parallel to the current axis a distance relative to the initial position expressed by Start = Standard_True

        :param Length:
        :type Length: Quantity_Length
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        """
        return _V3d.V3d_View_Translate(self, *args)


    def Place(self, *args) -> "void":
        """
        * places the point of the view corresponding at the pixel position x,y at the center of the window and updates the view.

        :param theXp:
        :type theXp: int
        :param theYp:
        :type theYp: int
        :param theZoomFactor: default value is 1
        :type theZoomFactor: Quantity_Factor
        :rtype: None

        """
        return _V3d.V3d_View_Place(self, *args)


    def Turn(self, *args) -> "void":
        """
        * Rotation of the view point around the frame of reference of the screen for which the origin is the eye of the projection with a relative angular value in RADIANS with respect to the initial position expressed by Start = Standard_True

        :param Ax:
        :type Ax: Quantity_PlaneAngle
        :param Ay:
        :type Ay: Quantity_PlaneAngle
        :param Az:
        :type Az: Quantity_PlaneAngle
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Rotation of the view point around one of the axes of the frame of reference of the view for which the origin is the eye of the projection with an angular value in RADIANS relative to the initial position expressed by Start = Standard_True

        :param Axe:
        :type Axe: V3d_TypeOfAxe
        :param Angle:
        :type Angle: Quantity_PlaneAngle
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        * Rotation of the view point around the current axis an angular value in RADIANS relative to the initial position expressed by Start = Standard_True

        :param Angle:
        :type Angle: Quantity_PlaneAngle
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        """
        return _V3d.V3d_View_Turn(self, *args)


    def SetTwist(self, *args) -> "void":
        """
        * Defines the angular position of the high point of the reference frame of the view with respect to the Y screen axis with an absolute angular value in RADIANS.

        :param Angle:
        :type Angle: Quantity_PlaneAngle
        :rtype: None

        """
        return _V3d.V3d_View_SetTwist(self, *args)


    def SetEye(self, *args) -> "void":
        """
        * Defines the position of the eye..

        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :rtype: None

        """
        return _V3d.V3d_View_SetEye(self, *args)


    def SetDepth(self, *args) -> "void":
        """
        * Defines the Depth of the eye from the view point without update the projection .

        :param Depth:
        :type Depth: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_View_SetDepth(self, *args)


    def SetProj(self, *args) -> "void":
        """
        * Defines the orientation of the projection.

        :param Vx:
        :type Vx: Quantity_Parameter
        :param Vy:
        :type Vy: Quantity_Parameter
        :param Vz:
        :type Vz: Quantity_Parameter
        :rtype: None

        * Defines the orientation of the projection .

        :param Orientation:
        :type Orientation: V3d_TypeOfOrientation
        :rtype: None

        """
        return _V3d.V3d_View_SetProj(self, *args)


    def SetAt(self, *args) -> "void":
        """
        * Defines the position of the view point.

        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :rtype: None

        """
        return _V3d.V3d_View_SetAt(self, *args)


    def SetUp(self, *args) -> "void":
        """
        * Defines the orientation of the high point.

        :param Vx:
        :type Vx: Quantity_Parameter
        :param Vy:
        :type Vy: Quantity_Parameter
        :param Vz:
        :type Vz: Quantity_Parameter
        :rtype: None

        * Defines the orientation(SO) of the high point.

        :param Orientation:
        :type Orientation: V3d_TypeOfOrientation
        :rtype: None

        """
        return _V3d.V3d_View_SetUp(self, *args)


    def SetViewOrientationDefault(self, *args) -> "void":
        """
        * Saves the current state of the orientation of the view which will be the return state at ResetViewOrientation.

        :rtype: None

        """
        return _V3d.V3d_View_SetViewOrientationDefault(self, *args)


    def ResetViewOrientation(self, *args) -> "void":
        """
        * Resets the orientation of the view. Updates the view

        :rtype: None

        """
        return _V3d.V3d_View_ResetViewOrientation(self, *args)


    def Panning(self, *args) -> "void":
        """
        * Translates the center of the view along 'x' and 'y' axes of view projection. Can be used to perform interactive panning operation. In that case the DXv, DXy parameters specify panning relative to the point where the operation is started. @param theDXv [in] the relative panning on 'x' axis of view projection, in view space coordinates. @param theDYv [in] the relative panning on 'y' axis of view projection, in view space coordinates. @param theZoomFactor [in] the zooming factor. @param theToStart [in] pass True when starting panning to remember view state prior to panning for relative arguments. If panning is started, passing {0, 0} for {theDXv, theDYv} will return view to initial state. Performs update of view.

        :param theDXv:
        :type theDXv: float
        :param theDYv:
        :type theDYv: float
        :param theZoomFactor: default value is 1
        :type theZoomFactor: Quantity_Factor
        :param theToStart: default value is Standard_True
        :type theToStart: bool
        :rtype: None

        """
        return _V3d.V3d_View_Panning(self, *args)


    def SetCenter(self, *args) -> "void":
        """
        * Relocates center of screen to the point, determined by {Xp, Yp} pixel coordinates relative to the bottom-left corner of screen. To calculate pixel coordinates for any point from world coordinate space, it can be projected using 'Project'. @param theXp [in] the x coordinate. @param theYp [in] the y coordinate.

        :param theXp:
        :type theXp: int
        :param theYp:
        :type theYp: int
        :rtype: None

        """
        return _V3d.V3d_View_SetCenter(self, *args)


    def SetSize(self, *args) -> "void":
        """
        * Defines the view projection size in its maximum dimension, keeping the inital height/width ratio unchanged.

        :param theSize:
        :type theSize: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_View_SetSize(self, *args)


    def SetZSize(self, *args) -> "void":
        """
        * Defines the Depth size of the view Front Plane will be set to Size/2. Back Plane will be set to -Size/2. Any Object located Above the Front Plane or behind the Back Plane will be Clipped . NOTE than the XY Size of the View is NOT modified .

        :param Size:
        :type Size: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_View_SetZSize(self, *args)


    def SetZoom(self, *args) -> "void":
        """
        * Zooms the view by a factor relative to the initial value expressed by Start = Standard_True Updates the view.

        :param Coef:
        :type Coef: Quantity_Factor
        :param Start: default value is Standard_True
        :type Start: bool
        :rtype: None

        """
        return _V3d.V3d_View_SetZoom(self, *args)


    def SetScale(self, *args) -> "void":
        """
        * Zooms the view by a factor relative to the value initialised by SetViewMappingDefault(). Updates the view.

        :param Coef:
        :type Coef: Quantity_Factor
        :rtype: None

        """
        return _V3d.V3d_View_SetScale(self, *args)


    def SetAxialScale(self, *args) -> "void":
        """
        * Sets anisotropic (axial) scale factors <Sx>, <Sy>, <Sz> for view <self>. Anisotropic scaling operation is performed through multiplying the current view orientation matrix by a scaling matrix: || Sx 0 0 0 || || 0 Sy 0 0 || || 0 0 Sz 0 || || 0 0 0 1 || Updates the view.

        :param Sx:
        :type Sx: float
        :param Sy:
        :type Sy: float
        :param Sz:
        :type Sz: float
        :rtype: None

        """
        return _V3d.V3d_View_SetAxialScale(self, *args)


    def DepthFitAll(self, *args) -> "void":
        """
        * Adjusts the viewing volume so as not to clip the displayed objects by front and back and back clipping planes. Also sets depth value automatically depending on the calculated Z size and Aspect parameter. NOTE than the original XY size of the view is NOT modified .

        :param Aspect: default value is 0.01
        :type Aspect: Quantity_Coefficient
        :param Margin: default value is 0.01
        :type Margin: Quantity_Coefficient
        :rtype: None

        """
        return _V3d.V3d_View_DepthFitAll(self, *args)


    def FitAll(self, *args) -> "void":
        """
        * Adjust view parameters to fit the displayed scene, respecting height / width ratio. The Z clipping range (depth range) is fitted if AutoZFit flag is True. Throws program error exception if margin coefficient is < 0 or >= 1. Updates the view. @param theMargin [in] the margin coefficient for view borders. @param theToUpdate [in] flag to perform view update.

        :param theMargin: default value is 0.01
        :type theMargin: Quantity_Coefficient
        :param theToUpdate: default value is Standard_True
        :type theToUpdate: bool
        :rtype: None

        * Centers the defined projection window so that it occupies the maximum space while respecting the initial height/width ratio. NOTE than the original Z size of the view is NOT modified .

        :param theMinXv:
        :type theMinXv: float
        :param theMinYv:
        :type theMinYv: float
        :param theMaxXv:
        :type theMaxXv: float
        :param theMaxYv:
        :type theMaxYv: float
        :rtype: None

        """
        return _V3d.V3d_View_FitAll(self, *args)


    def WindowFit(self, *args) -> "void":
        """
        * Centers the defined PIXEL window so that it occupies the maximum space while respecting the initial height/width ratio. NOTE than the original Z size of the view is NOT modified. @param theMinXp [in] pixel coordinates of minimal corner on x screen axis. @param theMinYp [in] pixel coordinates of minimal corner on y screen axis. @param theMaxXp [in] pixel coordinates of maximal corner on x screen axis. @param theMaxYp [in] pixel coordinates of maximal corner on y screen axis.

        :param theMinXp:
        :type theMinXp: int
        :param theMinYp:
        :type theMinYp: int
        :param theMaxXp:
        :type theMaxXp: int
        :param theMaxYp:
        :type theMaxYp: int
        :rtype: None

        """
        return _V3d.V3d_View_WindowFit(self, *args)


    def SetViewMappingDefault(self, *args) -> "void":
        """
        * Saves the current view mapping. This will be the state returned from ResetViewmapping.

        :rtype: None

        """
        return _V3d.V3d_View_SetViewMappingDefault(self, *args)


    def ResetViewMapping(self, *args) -> "void":
        """
        * Resets the centering of the view. Updates the view

        :rtype: None

        """
        return _V3d.V3d_View_ResetViewMapping(self, *args)


    def Reset(self, *args) -> "void":
        """
        * Resets the centering and the orientation of the view Updates the view

        :param update: default value is Standard_True
        :type update: bool
        :rtype: None

        """
        return _V3d.V3d_View_Reset(self, *args)


    def ConvertWithProj(self, *args) -> "void":
        """
        * Converts the projected point into a point in the reference frame of the view corresponding to the intersection with the projection plane of the eye/view point vector and returns the projection ray for further computations.

        :param Xp:
        :type Xp: int
        :param Yp:
        :type Yp: int
        :param X:
        :type X: V3d_Coordinate &
        :param Y:
        :type Y: V3d_Coordinate &
        :param Z:
        :type Z: V3d_Coordinate &
        :param Vx:
        :type Vx: Quantity_Parameter &
        :param Vy:
        :type Vy: Quantity_Parameter &
        :param Vz:
        :type Vz: Quantity_Parameter &
        :rtype: None

        """
        return _V3d.V3d_View_ConvertWithProj(self, *args)


    def ConvertToGrid(self, *args) -> "void":
        """
        * Converts the projected point into the nearest grid point in the reference frame of the view corresponding to the intersection with the projection plane of the eye/view point vector and display the grid marker. Warning: When the grid is not active the result is identical to the above Convert() method. How to use: 1) Enable the grid echo display myViewer->SetGridEcho(Standard_True); 2) When application receive a move event: 2.1) Check if any object is detected if( myInteractiveContext->MoveTo(x,y) == AIS_SOD_Nothing ) { 2.2) Check if the grid is active if( myViewer->Grid()->IsActive() ) { 2.3) Display the grid echo and gets the grid point myView->ConvertToGrid(x,y,X,Y,Z); myView->Viewer()->ShowGridEcho (myView, Graphic3d_Vertex (X,Y,Z)); myView->RedrawImmediate(); 2.4) Else this is the standard case } else myView->Convert(x,y,X,Y,Z);

        :param Xp:
        :type Xp: int
        :param Yp:
        :type Yp: int
        :param Xg:
        :type Xg: V3d_Coordinate &
        :param Yg:
        :type Yg: V3d_Coordinate &
        :param Zg:
        :type Zg: V3d_Coordinate &
        :rtype: None

        * Converts the point into the nearest grid point and display the grid marker.

        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :param Xg:
        :type Xg: V3d_Coordinate &
        :param Yg:
        :type Yg: V3d_Coordinate &
        :param Zg:
        :type Zg: V3d_Coordinate &
        :rtype: None

        """
        return _V3d.V3d_View_ConvertToGrid(self, *args)


    def Convert(self, *args) -> "void":
        """
        * Converts the PIXEL value to a value in the projection plane.

        :param Vp:
        :type Vp: int
        :rtype: Quantity_Length

        * Converts the point PIXEL into a point projected in the reference frame of the projection plane.

        :param Xp:
        :type Xp: int
        :param Yp:
        :type Yp: int
        :param Xv:
        :type Xv: V3d_Coordinate &
        :param Yv:
        :type Yv: V3d_Coordinate &
        :rtype: None

        * Converts tha value of the projection plane into a PIXEL value.

        :param Vv:
        :type Vv: Quantity_Length
        :rtype: int

        * Converts the point defined in the reference frame of the projection plane into a point PIXEL.

        :param Xv:
        :type Xv: V3d_Coordinate
        :param Yv:
        :type Yv: V3d_Coordinate
        :param Xp:
        :type Xp: int &
        :param Yp:
        :type Yp: int &
        :rtype: None

        * Converts the projected point into a point in the reference frame of the view corresponding to the intersection with the projection plane of the eye/view point vector.

        :param Xp:
        :type Xp: int
        :param Yp:
        :type Yp: int
        :param X:
        :type X: V3d_Coordinate &
        :param Y:
        :type Y: V3d_Coordinate &
        :param Z:
        :type Z: V3d_Coordinate &
        :rtype: None

        * Projects the point defined in the reference frame of the view into the projected point in the associated window.

        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :param Xp:
        :type Xp: int &
        :param Yp:
        :type Yp: int &
        :rtype: None

        """
        return _V3d.V3d_View_Convert(self, *args)


    def Project(self, *args) -> "void":
        """
        * Converts the point defined in the user space of the view to the projected view plane point at z 0.

        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :param Xp:
        :type Xp: V3d_Coordinate &
        :param Yp:
        :type Yp: V3d_Coordinate &
        :rtype: None

        """
        return _V3d.V3d_View_Project(self, *args)


    def BackgroundColor(self, *args) -> "Quantity_Color":
        """
        * Returns the Background color values of the view depending of the color Type.

        :param Type:
        :type Type: Quantity_TypeOfColor
        :param V1:
        :type V1: Quantity_Parameter &
        :param V2:
        :type V2: Quantity_Parameter &
        :param V3:
        :type V3: Quantity_Parameter &
        :rtype: None

        * Returns the Background color object of the view.

        :rtype: Quantity_Color

        """
        return _V3d.V3d_View_BackgroundColor(self, *args)


    def GradientBackgroundColors(self, *args) -> "void":
        """
        * Returns the gradient background colour objects of the view.

        :param Color1:
        :type Color1: Quantity_Color &
        :param Color2:
        :type Color2: Quantity_Color &
        :rtype: None

        """
        return _V3d.V3d_View_GradientBackgroundColors(self, *args)


    def GradientBackground(self, *args) -> "Aspect_GradientBackground":
        """
        * Returns the gradient background of the view.

        :rtype: Aspect_GradientBackground

        """
        return _V3d.V3d_View_GradientBackground(self, *args)


    def Scale(self, *args) -> "Quantity_Factor":
        """
        * Returns the current value of the zoom expressed with respect to SetViewMappingDefault().

        :rtype: Quantity_Factor

        """
        return _V3d.V3d_View_Scale(self, *args)


    def Size(self, *args) -> "void":
        """
        * Returns the height and width of the view.

        :param Width:
        :type Width: Quantity_Length &
        :param Height:
        :type Height: Quantity_Length &
        :rtype: None

        """
        return _V3d.V3d_View_Size(self, *args)


    def ZSize(self, *args) -> "Standard_Real":
        """
        * Returns the Depth of the view .

        :rtype: float

        """
        return _V3d.V3d_View_ZSize(self, *args)


    def Eye(self, *args) -> "void":
        """
        * Returns the position of the eye.

        :param X:
        :type X: V3d_Coordinate &
        :param Y:
        :type Y: V3d_Coordinate &
        :param Z:
        :type Z: V3d_Coordinate &
        :rtype: None

        """
        return _V3d.V3d_View_Eye(self, *args)


    def FocalReferencePoint(self, *args) -> "void":
        """
        * Returns the position of point which emanating the projections.

        :param X:
        :type X: V3d_Coordinate &
        :param Y:
        :type Y: V3d_Coordinate &
        :param Z:
        :type Z: V3d_Coordinate &
        :rtype: None

        """
        return _V3d.V3d_View_FocalReferencePoint(self, *args)


    def ProjReferenceAxe(self, *args) -> "void":
        """
        * Returns the coordinate of the point (Xpix,Ypix) in the view (XP,YP,ZP), and the projection vector of the view passing by the point (for PerspectiveView).

        :param Xpix:
        :type Xpix: int
        :param Ypix:
        :type Ypix: int
        :param XP:
        :type XP: V3d_Coordinate &
        :param YP:
        :type YP: V3d_Coordinate &
        :param ZP:
        :type ZP: V3d_Coordinate &
        :param VX:
        :type VX: V3d_Coordinate &
        :param VY:
        :type VY: V3d_Coordinate &
        :param VZ:
        :type VZ: V3d_Coordinate &
        :rtype: None

        """
        return _V3d.V3d_View_ProjReferenceAxe(self, *args)


    def Depth(self, *args) -> "Quantity_Length":
        """
        * Returns the Distance between the Eye and View Point.

        :rtype: Quantity_Length

        """
        return _V3d.V3d_View_Depth(self, *args)


    def Proj(self, *args) -> "void":
        """
        * Returns the projection vector.

        :param Vx:
        :type Vx: Quantity_Parameter &
        :param Vy:
        :type Vy: Quantity_Parameter &
        :param Vz:
        :type Vz: Quantity_Parameter &
        :rtype: None

        """
        return _V3d.V3d_View_Proj(self, *args)


    def At(self, *args) -> "void":
        """
        * Returns the position of the view point.

        :param X:
        :type X: V3d_Coordinate &
        :param Y:
        :type Y: V3d_Coordinate &
        :param Z:
        :type Z: V3d_Coordinate &
        :rtype: None

        """
        return _V3d.V3d_View_At(self, *args)


    def Up(self, *args) -> "void":
        """
        * Returns the vector giving the position of the high point.

        :param Vx:
        :type Vx: Quantity_Parameter &
        :param Vy:
        :type Vy: Quantity_Parameter &
        :param Vz:
        :type Vz: Quantity_Parameter &
        :rtype: None

        """
        return _V3d.V3d_View_Up(self, *args)


    def Twist(self, *args) -> "Quantity_PlaneAngle":
        """
        * Returns in RADIANS the orientation of the view around the visual axis measured from the Y axis of the screen.

        :rtype: Quantity_PlaneAngle

        """
        return _V3d.V3d_View_Twist(self, *args)


    def ShadingModel(self, *args) -> "V3d_TypeOfShadingModel":
        """
        * Returns the current shading model.

        :rtype: V3d_TypeOfShadingModel

        """
        return _V3d.V3d_View_ShadingModel(self, *args)


    def SurfaceDetail(self, *args) -> "V3d_TypeOfSurfaceDetail":
        """
        :rtype: V3d_TypeOfSurfaceDetail

        """
        return _V3d.V3d_View_SurfaceDetail(self, *args)


    def TextureEnv(self, *args) -> "Handle_Graphic3d_TextureEnv":
        """
        :rtype: Handle_Graphic3d_TextureEnv

        """
        return _V3d.V3d_View_TextureEnv(self, *args)


    def Transparency(self, *args) -> "Standard_Boolean":
        """
        * Returns the transparency activity.

        :rtype: bool

        """
        return _V3d.V3d_View_Transparency(self, *args)


    def Visualization(self, *args) -> "V3d_TypeOfVisualization":
        """
        * Returns the current visualisation mode.

        :rtype: V3d_TypeOfVisualization

        """
        return _V3d.V3d_View_Visualization(self, *args)


    def Antialiasing(self, *args) -> "Standard_Boolean":
        """
        * Indicates if the antialiasing is active (True) or inactive (False).

        :rtype: bool

        """
        return _V3d.V3d_View_Antialiasing(self, *args)


    def ZCueing(self, *args) -> "Standard_Boolean":
        """
        * Returns activity and information on the Zcueing. <Depth> : Depth of plane. <Width> : Thickness around the plane.

        :param Depth:
        :type Depth: Quantity_Length &
        :param Width:
        :type Width: Quantity_Length &
        :rtype: bool

        """
        return _V3d.V3d_View_ZCueing(self, *args)


    def ZClipping(self, *args) -> "V3d_TypeOfZclipping":
        """
        * Returns current information on the ZClipping. <Depth> : Depth of plane. <Width> : Thickness around the plane. <TypeOfZclipping> : 'BACK' 'FRONT' 'SLICE' 'OFF'

        :param Depth:
        :type Depth: Quantity_Length &
        :param Width:
        :type Width: Quantity_Length &
        :rtype: V3d_TypeOfZclipping

        """
        return _V3d.V3d_View_ZClipping(self, *args)


    def IfMoreLights(self, *args) -> "Standard_Boolean":
        """
        * Returns True if One light more can be activated in this View.

        :rtype: bool

        """
        return _V3d.V3d_View_IfMoreLights(self, *args)


    def InitActiveLights(self, *args) -> "void":
        """
        * initializes an iteration on the active Lights.

        :rtype: None

        """
        return _V3d.V3d_View_InitActiveLights(self, *args)


    def MoreActiveLights(self, *args) -> "Standard_Boolean":
        """
        * returns true if there are more active Light(s) to return.

        :rtype: bool

        """
        return _V3d.V3d_View_MoreActiveLights(self, *args)


    def NextActiveLights(self, *args) -> "void":
        """
        * Go to the next active Light (if there is not, ActiveLight will raise an exception)

        :rtype: None

        """
        return _V3d.V3d_View_NextActiveLights(self, *args)


    def ActiveLight(self, *args) -> "Handle_V3d_Light":
        """
        :rtype: Handle_V3d_Light

        """
        return _V3d.V3d_View_ActiveLight(self, *args)


    def Viewer(self, *args) -> "Handle_V3d_Viewer":
        """
        * Returns the viewer in which the view has been created.

        :rtype: Handle_V3d_Viewer

        """
        return _V3d.V3d_View_Viewer(self, *args)


    def IfWindow(self, *args) -> "Standard_Boolean":
        """
        * Returns True if MyView is associated with a window .

        :rtype: bool

        """
        return _V3d.V3d_View_IfWindow(self, *args)


    def Window(self, *args) -> "Handle_Aspect_Window":
        """
        * Returns the Aspect Window associated with the view.

        :rtype: Handle_Aspect_Window

        """
        return _V3d.V3d_View_Window(self, *args)


    def Type(self, *args) -> "V3d_TypeOfView":
        """
        * Returns the Type of the View

        :rtype: V3d_TypeOfView

        """
        return _V3d.V3d_View_Type(self, *args)


    def Pan(self, *args) -> "void":
        """
        * Translates the center of the view along 'x' and 'y' axes of view projection. Can be used to perform interactive panning operation. In that case the DXp, DXp parameters specify panning relative to the point where the operation is started. @param theDXp [in] the relative panning on 'x' axis of view projection, in pixels. @param theDYp [in] the relative panning on 'y' axis of view projection, in pixels. @param theZoomFactor [in] the zooming factor. @param theToStart [in] pass True when starting panning to remember view state prior to panning for relative arguments. Passing 0 for relative panning parameter should return view panning to initial state. Performs update of view.

        :param theDXp:
        :type theDXp: int
        :param theDYp:
        :type theDYp: int
        :param theZoomFactor: default value is 1
        :type theZoomFactor: Quantity_Factor
        :param theToStart: default value is Standard_True
        :type theToStart: bool
        :rtype: None

        """
        return _V3d.V3d_View_Pan(self, *args)


    def Zoom(self, *args) -> "void":
        """
        * Zoom the view according to a zoom factor computed from the distance between the 2 mouse position. @param theXp1 [in] the x coordinate of first mouse position, in pixels. @param theYp1 [in] the y coordinate of first mouse position, in pixels. @param theXp2 [in] the x coordinate of second mouse position, in pixels. @param theYp2 [in] the y coordinate of second mouse position, in pixels.

        :param theXp1:
        :type theXp1: int
        :param theYp1:
        :type theYp1: int
        :param theXp2:
        :type theXp2: int
        :param theYp2:
        :type theYp2: int
        :rtype: None

        """
        return _V3d.V3d_View_Zoom(self, *args)


    def StartZoomAtPoint(self, *args) -> "void":
        """
        * Defines starting point for ZoomAtPoint view operation. @param theXp [in] the x mouse coordinate, in pixels. @param theYp [in] the y mouse coordinate, in pixels.

        :param theXp:
        :type theXp: int
        :param theYp:
        :type theYp: int
        :rtype: None

        """
        return _V3d.V3d_View_StartZoomAtPoint(self, *args)


    def ZoomAtPoint(self, *args) -> "void":
        """
        * Zooms the model at a pixel defined by the method StartZoomAtPoint().

        :param theMouseStartX:
        :type theMouseStartX: int
        :param theMouseStartY:
        :type theMouseStartY: int
        :param theMouseEndX:
        :type theMouseEndX: int
        :param theMouseEndY:
        :type theMouseEndY: int
        :rtype: None

        """
        return _V3d.V3d_View_ZoomAtPoint(self, *args)


    def AxialScale(self, *args) -> "void":
        """
        * Returns the current values of the anisotropic (axial) scale factors.

        :param Sx:
        :type Sx: float &
        :param Sy:
        :type Sy: float &
        :param Sz:
        :type Sz: float &
        :rtype: None

        * Performs anisotropic scaling of <self> view along the given <Axis>. The scale factor is calculated on a basis of the mouse pointer displacement <Dx,Dy>. The calculated scale factor is then passed to SetAxialScale(Sx, Sy, Sz) method.

        :param Dx:
        :type Dx: int
        :param Dy:
        :type Dy: int
        :param Axis:
        :type Axis: V3d_TypeOfAxe
        :rtype: None

        """
        return _V3d.V3d_View_AxialScale(self, *args)


    def StartRotation(self, *args) -> "void":
        """
        * Begin the rotation of the view around the screen axis according to the mouse position <X,Y>. Warning: Enable rotation around the Z screen axis when <zRotationThreshold> factor is > 0 soon the distance from the start point and the center of the view is > (medium viewSize * <zRotationThreshold> ). Generally a value of 0.4 is usable to rotate around XY screen axis inside the circular threshold area and to rotate around Z screen axis outside this area.

        :param X:
        :type X: int
        :param Y:
        :type Y: int
        :param zRotationThreshold: default value is 0.0
        :type zRotationThreshold: Quantity_Ratio
        :rtype: None

        """
        return _V3d.V3d_View_StartRotation(self, *args)


    def Rotation(self, *args) -> "void":
        """
        * Continues the rotation of the view with an angle computed from the last and new mouse position <X,Y>.

        :param X:
        :type X: int
        :param Y:
        :type Y: int
        :rtype: None

        """
        return _V3d.V3d_View_Rotation(self, *args)


    def SetFocale(self, *args) -> "void":
        """
        * Change View Plane Distance for Perspective Views Warning! raises TypeMismatch from Standard if the view is not a perspective view.

        :param Focale:
        :type Focale: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_View_SetFocale(self, *args)


    def Focale(self, *args) -> "Quantity_Length":
        """
        * Returns the View Plane Distance for Perspective Views

        :rtype: Quantity_Length

        """
        return _V3d.V3d_View_Focale(self, *args)


    def View(self, *args) -> "Handle_Visual3d_View":
        """
        * Returns the associated Visual3d view.

        :rtype: Handle_Visual3d_View

        """
        return _V3d.V3d_View_View(self, *args)


    def SetComputedMode(self, *args) -> "void":
        """
        * Switches computed HLR mode in the view

        :param aMode:
        :type aMode: bool
        :rtype: None

        """
        return _V3d.V3d_View_SetComputedMode(self, *args)


    def ComputedMode(self, *args) -> "Standard_Boolean":
        """
        * Returns the computed HLR mode state

        :rtype: bool

        """
        return _V3d.V3d_View_ComputedMode(self, *args)


    def WindowFitAll(self, *args) -> "void":
        """
        * idem than WindowFit

        :param Xmin:
        :type Xmin: int
        :param Ymin:
        :type Ymin: int
        :param Xmax:
        :type Xmax: int
        :param Ymax:
        :type Ymax: int
        :rtype: None

        """
        return _V3d.V3d_View_WindowFitAll(self, *args)


    def SetGrid(self, *args) -> "void":
        """
        * Defines or Updates the definition of the grid in <self>

        :param aPlane:
        :type aPlane: gp_Ax3
        :param aGrid:
        :type aGrid: Handle_Aspect_Grid &
        :rtype: None

        """
        return _V3d.V3d_View_SetGrid(self, *args)


    def SetGridGraphicValues(self, *args) -> "void":
        """
        * Defines or Updates the graphic definition of the grid in <self>

        :param aGrid:
        :type aGrid: Handle_Aspect_Grid &
        :rtype: None

        """
        return _V3d.V3d_View_SetGridGraphicValues(self, *args)


    def SetGridActivity(self, *args) -> "void":
        """
        * Defines or Updates the activity of the grid in <self>

        :param aFlag:
        :type aFlag: bool
        :rtype: None

        """
        return _V3d.V3d_View_SetGridActivity(self, *args)


    def Dump(self, *args) -> "Standard_Boolean":
        """
        * dump the full contents of the view at the same scale in the file <theFile>. The file name extension must be one of '.png','.bmp','.jpg','.gif'. Returns False when the dump has failed

        :param theFile:
        :type theFile: char *
        :param theBufferType: default value is Graphic3d_BT_RGB
        :type theBufferType: Graphic3d_BufferType &
        :rtype: bool

        """
        return _V3d.V3d_View_Dump(self, *args)


    def ToPixMap(self, *args) -> "Standard_Boolean":
        """
        * Dumps the full contents of the view to a pixmap of pixel size <theWidth> * <theHeight> and buffer type <theBufferType>. If <theToKeepAspect> is true the aspect ratio of view will be kept if <theWidth> and <theHeight> define another ratio. Pixmap will be automatically (re)allocated when needed. When dumping stereographic camera - the corresponding middle-point monographic projection will be used for dumping by default. <theStereoOptions> flags are to be used for dumping then left or right eye projections.

        :param theImage:
        :type theImage: Image_PixMap &
        :param theWidth:
        :type theWidth: int
        :param theHeight:
        :type theHeight: int
        :param theBufferType: default value is Graphic3d_BT_RGB
        :type theBufferType: Graphic3d_BufferType &
        :param theToKeepAspect: default value is Standard_True
        :type theToKeepAspect: bool
        :param theStereoOptions: default value is V3d_SDO_MONO
        :type theStereoOptions: V3d_StereoDumpOptions
        :rtype: bool

        """
        return _V3d.V3d_View_ToPixMap(self, *args)


    def SetBackFacingModel(self, *args) -> "void":
        """
        * Manages display of the back faces When <aModel> is TOBM_AUTOMATIC the object backfaces are displayed only for surface objects and never displayed for solid objects. this was the previous mode. <aModel> is TOBM_ALWAYS_DISPLAYED the object backfaces are always displayed both for surfaces or solids. <aModel> is TOBM_NEVER_DISPLAYED the object backfaces are never displayed.

        :param aModel: default value is V3d_TOBM_AUTOMATIC
        :type aModel: V3d_TypeOfBackfacingModel
        :rtype: None

        """
        return _V3d.V3d_View_SetBackFacingModel(self, *args)


    def BackFacingModel(self, *args) -> "V3d_TypeOfBackfacingModel":
        """
        * Returns current state of the back faces display

        :rtype: V3d_TypeOfBackfacingModel

        """
        return _V3d.V3d_View_BackFacingModel(self, *args)


    def EnableDepthTest(self, *args) -> "void":
        """
        * turns on/off opengl depth testing

        :param enable: default value is Standard_True
        :type enable: bool
        :rtype: None

        """
        return _V3d.V3d_View_EnableDepthTest(self, *args)


    def IsDepthTestEnabled(self, *args) -> "Standard_Boolean":
        """
        * returns the current state of the depth testing

        :rtype: bool

        """
        return _V3d.V3d_View_IsDepthTestEnabled(self, *args)


    def EnableGLLight(self, *args) -> "void":
        """
        * turns on/off opengl lighting, currently used in triedron displaying

        :param enable: default value is Standard_True
        :type enable: bool
        :rtype: None

        """
        return _V3d.V3d_View_EnableGLLight(self, *args)


    def IsGLLightEnabled(self, *args) -> "Standard_Boolean":
        """
        * returns the current state of the gl lighting currently used in triedron displaying

        :rtype: bool

        """
        return _V3d.V3d_View_IsGLLightEnabled(self, *args)


    def AddClipPlane(self, *args) -> "void":
        """
        * Adds clip plane to the view. The composition of clip planes truncates the rendering space to convex volume. Number of supported clip planes can be consulted by PlaneLimit method of associated Visual3d_View. Please be aware that the planes which exceed the limit are ignored during rendering. @param thePlane [in] the clip plane to be added to view.

        :param thePlane:
        :type thePlane: Graphic3d_ClipPlane_Handle &
        :rtype: void

        """
        return _V3d.V3d_View_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args) -> "void":
        """
        * Removes clip plane from the view. @param thePlane [in] the clip plane to be removed from view.

        :param thePlane:
        :type thePlane: Graphic3d_ClipPlane_Handle &
        :rtype: void

        """
        return _V3d.V3d_View_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args) -> "void":
        """
        * Sets sequence of clip planes to the view. The planes that have been set before are removed from the view. The composition of clip planes truncates the rendering space to convex volume. Number of supported clip planes can be consulted by PlaneLimit method of associated Visual3d_View. Please be aware that the planes which exceed the limit are ignored during rendering. @param thePlanes [in] the clip planes to set.

        :param thePlanes:
        :type thePlanes: Graphic3d_SequenceOfHClipPlane &
        :rtype: None

        """
        return _V3d.V3d_View_SetClipPlanes(self, *args)


    def GetClipPlanes(self, *args) -> "Graphic3d_SequenceOfHClipPlane const &":
        """
        * Get clip planes. returns sequence clip planes that have been set for the view

        :rtype: Graphic3d_SequenceOfHClipPlane

        """
        return _V3d.V3d_View_GetClipPlanes(self, *args)


    def SetCamera(self, *args) -> "void":
        """
        * Change camera used by view.

        :param theCamera:
        :type theCamera: Graphic3d_Camera_Handle &
        :rtype: None

        """
        return _V3d.V3d_View_SetCamera(self, *args)


    def Camera(self, *args) -> "Graphic3d_Camera_Handle const &":
        """
        * Returns camera object of the view. returns: handle to camera object, or NULL if 3D view does not use the camera approach.

        :rtype: Graphic3d_Camera_Handle

        """
        return _V3d.V3d_View_Camera(self, *args)


    def RenderingParams(self, *args) -> "Graphic3d_RenderingParams const &":
        """
        * Returns current rendering parameters and effect settings.

        :rtype: Graphic3d_RenderingParams

        """
        return _V3d.V3d_View_RenderingParams(self, *args)


    def ChangeRenderingParams(self, *args) -> "Graphic3d_RenderingParams &":
        """
        * Returns reference to current rendering parameters and effect settings.

        :rtype: Graphic3d_RenderingParams

        """
        return _V3d.V3d_View_ChangeRenderingParams(self, *args)


    def IsCullingEnabled(self, *args) -> "Standard_Boolean":
        """
        * returns flag value of objects culling mechanism

        :rtype: bool

        """
        return _V3d.V3d_View_IsCullingEnabled(self, *args)


    def SetFrustumCulling(self, *args) -> "void":
        """
        * Turn on/off automatic culling of objects outside frustrum (ON by default)

        :param theMode:
        :type theMode: bool
        :rtype: None

        """
        return _V3d.V3d_View_SetFrustumCulling(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_View(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_View
V3d_View.SetWindow = new_instancemethod(_V3d.V3d_View_SetWindow, None, V3d_View)
V3d_View.SetMagnify = new_instancemethod(_V3d.V3d_View_SetMagnify, None, V3d_View)
V3d_View.Remove = new_instancemethod(_V3d.V3d_View_Remove, None, V3d_View)
V3d_View.Update = new_instancemethod(_V3d.V3d_View_Update, None, V3d_View)
V3d_View.RedrawImmediate = new_instancemethod(_V3d.V3d_View_RedrawImmediate, None, V3d_View)
V3d_View.Invalidate = new_instancemethod(_V3d.V3d_View_Invalidate, None, V3d_View)
V3d_View.Redraw = new_instancemethod(_V3d.V3d_View_Redraw, None, V3d_View)
V3d_View.MustBeResized = new_instancemethod(_V3d.V3d_View_MustBeResized, None, V3d_View)
V3d_View.DoMapping = new_instancemethod(_V3d.V3d_View_DoMapping, None, V3d_View)
V3d_View.IsEmpty = new_instancemethod(_V3d.V3d_View_IsEmpty, None, V3d_View)
V3d_View.UpdateLights = new_instancemethod(_V3d.V3d_View_UpdateLights, None, V3d_View)
V3d_View.AutoZFit = new_instancemethod(_V3d.V3d_View_AutoZFit, None, V3d_View)
V3d_View.ZFitAll = new_instancemethod(_V3d.V3d_View_ZFitAll, None, V3d_View)
V3d_View.SetBackgroundColor = new_instancemethod(_V3d.V3d_View_SetBackgroundColor, None, V3d_View)
V3d_View.SetBgGradientColors = new_instancemethod(_V3d.V3d_View_SetBgGradientColors, None, V3d_View)
V3d_View.SetBgGradientStyle = new_instancemethod(_V3d.V3d_View_SetBgGradientStyle, None, V3d_View)
V3d_View.SetBackgroundImage = new_instancemethod(_V3d.V3d_View_SetBackgroundImage, None, V3d_View)
V3d_View.SetBgImageStyle = new_instancemethod(_V3d.V3d_View_SetBgImageStyle, None, V3d_View)
V3d_View.SetAxis = new_instancemethod(_V3d.V3d_View_SetAxis, None, V3d_View)
V3d_View.SetShadingModel = new_instancemethod(_V3d.V3d_View_SetShadingModel, None, V3d_View)
V3d_View.SetSurfaceDetail = new_instancemethod(_V3d.V3d_View_SetSurfaceDetail, None, V3d_View)
V3d_View.SetTextureEnv = new_instancemethod(_V3d.V3d_View_SetTextureEnv, None, V3d_View)
V3d_View.SetVisualization = new_instancemethod(_V3d.V3d_View_SetVisualization, None, V3d_View)
V3d_View.SetAntialiasingOn = new_instancemethod(_V3d.V3d_View_SetAntialiasingOn, None, V3d_View)
V3d_View.SetAntialiasingOff = new_instancemethod(_V3d.V3d_View_SetAntialiasingOff, None, V3d_View)
V3d_View.SetZClippingDepth = new_instancemethod(_V3d.V3d_View_SetZClippingDepth, None, V3d_View)
V3d_View.SetZClippingWidth = new_instancemethod(_V3d.V3d_View_SetZClippingWidth, None, V3d_View)
V3d_View.SetZClippingType = new_instancemethod(_V3d.V3d_View_SetZClippingType, None, V3d_View)
V3d_View.SetZCueingDepth = new_instancemethod(_V3d.V3d_View_SetZCueingDepth, None, V3d_View)
V3d_View.SetZCueingWidth = new_instancemethod(_V3d.V3d_View_SetZCueingWidth, None, V3d_View)
V3d_View.SetZCueingOn = new_instancemethod(_V3d.V3d_View_SetZCueingOn, None, V3d_View)
V3d_View.SetZCueingOff = new_instancemethod(_V3d.V3d_View_SetZCueingOff, None, V3d_View)
V3d_View.SetLightOn = new_instancemethod(_V3d.V3d_View_SetLightOn, None, V3d_View)
V3d_View.SetLightOff = new_instancemethod(_V3d.V3d_View_SetLightOff, None, V3d_View)
V3d_View.IsActiveLight = new_instancemethod(_V3d.V3d_View_IsActiveLight, None, V3d_View)
V3d_View.SetTransparency = new_instancemethod(_V3d.V3d_View_SetTransparency, None, V3d_View)
V3d_View.SetImmediateUpdate = new_instancemethod(_V3d.V3d_View_SetImmediateUpdate, None, V3d_View)
V3d_View.ZBufferTriedronSetup = new_instancemethod(_V3d.V3d_View_ZBufferTriedronSetup, None, V3d_View)
V3d_View.TriedronDisplay = new_instancemethod(_V3d.V3d_View_TriedronDisplay, None, V3d_View)
V3d_View.TriedronErase = new_instancemethod(_V3d.V3d_View_TriedronErase, None, V3d_View)
V3d_View.TriedronEcho = new_instancemethod(_V3d.V3d_View_TriedronEcho, None, V3d_View)
V3d_View.GetGraduatedTrihedron = new_instancemethod(_V3d.V3d_View_GetGraduatedTrihedron, None, V3d_View)
V3d_View.GraduatedTrihedronDisplay = new_instancemethod(_V3d.V3d_View_GraduatedTrihedronDisplay, None, V3d_View)
V3d_View.GraduatedTrihedronErase = new_instancemethod(_V3d.V3d_View_GraduatedTrihedronErase, None, V3d_View)
V3d_View.SetLayerMgr = new_instancemethod(_V3d.V3d_View_SetLayerMgr, None, V3d_View)
V3d_View.ColorScaleDisplay = new_instancemethod(_V3d.V3d_View_ColorScaleDisplay, None, V3d_View)
V3d_View.ColorScaleErase = new_instancemethod(_V3d.V3d_View_ColorScaleErase, None, V3d_View)
V3d_View.ColorScaleIsDisplayed = new_instancemethod(_V3d.V3d_View_ColorScaleIsDisplayed, None, V3d_View)
V3d_View.ColorScale = new_instancemethod(_V3d.V3d_View_ColorScale, None, V3d_View)
V3d_View.SetFront = new_instancemethod(_V3d.V3d_View_SetFront, None, V3d_View)
V3d_View.Rotate = new_instancemethod(_V3d.V3d_View_Rotate, None, V3d_View)
V3d_View.Move = new_instancemethod(_V3d.V3d_View_Move, None, V3d_View)
V3d_View.Translate = new_instancemethod(_V3d.V3d_View_Translate, None, V3d_View)
V3d_View.Place = new_instancemethod(_V3d.V3d_View_Place, None, V3d_View)
V3d_View.Turn = new_instancemethod(_V3d.V3d_View_Turn, None, V3d_View)
V3d_View.SetTwist = new_instancemethod(_V3d.V3d_View_SetTwist, None, V3d_View)
V3d_View.SetEye = new_instancemethod(_V3d.V3d_View_SetEye, None, V3d_View)
V3d_View.SetDepth = new_instancemethod(_V3d.V3d_View_SetDepth, None, V3d_View)
V3d_View.SetProj = new_instancemethod(_V3d.V3d_View_SetProj, None, V3d_View)
V3d_View.SetAt = new_instancemethod(_V3d.V3d_View_SetAt, None, V3d_View)
V3d_View.SetUp = new_instancemethod(_V3d.V3d_View_SetUp, None, V3d_View)
V3d_View.SetViewOrientationDefault = new_instancemethod(_V3d.V3d_View_SetViewOrientationDefault, None, V3d_View)
V3d_View.ResetViewOrientation = new_instancemethod(_V3d.V3d_View_ResetViewOrientation, None, V3d_View)
V3d_View.Panning = new_instancemethod(_V3d.V3d_View_Panning, None, V3d_View)
V3d_View.SetCenter = new_instancemethod(_V3d.V3d_View_SetCenter, None, V3d_View)
V3d_View.SetSize = new_instancemethod(_V3d.V3d_View_SetSize, None, V3d_View)
V3d_View.SetZSize = new_instancemethod(_V3d.V3d_View_SetZSize, None, V3d_View)
V3d_View.SetZoom = new_instancemethod(_V3d.V3d_View_SetZoom, None, V3d_View)
V3d_View.SetScale = new_instancemethod(_V3d.V3d_View_SetScale, None, V3d_View)
V3d_View.SetAxialScale = new_instancemethod(_V3d.V3d_View_SetAxialScale, None, V3d_View)
V3d_View.DepthFitAll = new_instancemethod(_V3d.V3d_View_DepthFitAll, None, V3d_View)
V3d_View.FitAll = new_instancemethod(_V3d.V3d_View_FitAll, None, V3d_View)
V3d_View.WindowFit = new_instancemethod(_V3d.V3d_View_WindowFit, None, V3d_View)
V3d_View.SetViewMappingDefault = new_instancemethod(_V3d.V3d_View_SetViewMappingDefault, None, V3d_View)
V3d_View.ResetViewMapping = new_instancemethod(_V3d.V3d_View_ResetViewMapping, None, V3d_View)
V3d_View.Reset = new_instancemethod(_V3d.V3d_View_Reset, None, V3d_View)
V3d_View.ConvertWithProj = new_instancemethod(_V3d.V3d_View_ConvertWithProj, None, V3d_View)
V3d_View.ConvertToGrid = new_instancemethod(_V3d.V3d_View_ConvertToGrid, None, V3d_View)
V3d_View.Convert = new_instancemethod(_V3d.V3d_View_Convert, None, V3d_View)
V3d_View.Project = new_instancemethod(_V3d.V3d_View_Project, None, V3d_View)
V3d_View.BackgroundColor = new_instancemethod(_V3d.V3d_View_BackgroundColor, None, V3d_View)
V3d_View.GradientBackgroundColors = new_instancemethod(_V3d.V3d_View_GradientBackgroundColors, None, V3d_View)
V3d_View.GradientBackground = new_instancemethod(_V3d.V3d_View_GradientBackground, None, V3d_View)
V3d_View.Scale = new_instancemethod(_V3d.V3d_View_Scale, None, V3d_View)
V3d_View.Size = new_instancemethod(_V3d.V3d_View_Size, None, V3d_View)
V3d_View.ZSize = new_instancemethod(_V3d.V3d_View_ZSize, None, V3d_View)
V3d_View.Eye = new_instancemethod(_V3d.V3d_View_Eye, None, V3d_View)
V3d_View.FocalReferencePoint = new_instancemethod(_V3d.V3d_View_FocalReferencePoint, None, V3d_View)
V3d_View.ProjReferenceAxe = new_instancemethod(_V3d.V3d_View_ProjReferenceAxe, None, V3d_View)
V3d_View.Depth = new_instancemethod(_V3d.V3d_View_Depth, None, V3d_View)
V3d_View.Proj = new_instancemethod(_V3d.V3d_View_Proj, None, V3d_View)
V3d_View.At = new_instancemethod(_V3d.V3d_View_At, None, V3d_View)
V3d_View.Up = new_instancemethod(_V3d.V3d_View_Up, None, V3d_View)
V3d_View.Twist = new_instancemethod(_V3d.V3d_View_Twist, None, V3d_View)
V3d_View.ShadingModel = new_instancemethod(_V3d.V3d_View_ShadingModel, None, V3d_View)
V3d_View.SurfaceDetail = new_instancemethod(_V3d.V3d_View_SurfaceDetail, None, V3d_View)
V3d_View.TextureEnv = new_instancemethod(_V3d.V3d_View_TextureEnv, None, V3d_View)
V3d_View.Transparency = new_instancemethod(_V3d.V3d_View_Transparency, None, V3d_View)
V3d_View.Visualization = new_instancemethod(_V3d.V3d_View_Visualization, None, V3d_View)
V3d_View.Antialiasing = new_instancemethod(_V3d.V3d_View_Antialiasing, None, V3d_View)
V3d_View.ZCueing = new_instancemethod(_V3d.V3d_View_ZCueing, None, V3d_View)
V3d_View.ZClipping = new_instancemethod(_V3d.V3d_View_ZClipping, None, V3d_View)
V3d_View.IfMoreLights = new_instancemethod(_V3d.V3d_View_IfMoreLights, None, V3d_View)
V3d_View.InitActiveLights = new_instancemethod(_V3d.V3d_View_InitActiveLights, None, V3d_View)
V3d_View.MoreActiveLights = new_instancemethod(_V3d.V3d_View_MoreActiveLights, None, V3d_View)
V3d_View.NextActiveLights = new_instancemethod(_V3d.V3d_View_NextActiveLights, None, V3d_View)
V3d_View.ActiveLight = new_instancemethod(_V3d.V3d_View_ActiveLight, None, V3d_View)
V3d_View.Viewer = new_instancemethod(_V3d.V3d_View_Viewer, None, V3d_View)
V3d_View.IfWindow = new_instancemethod(_V3d.V3d_View_IfWindow, None, V3d_View)
V3d_View.Window = new_instancemethod(_V3d.V3d_View_Window, None, V3d_View)
V3d_View.Type = new_instancemethod(_V3d.V3d_View_Type, None, V3d_View)
V3d_View.Pan = new_instancemethod(_V3d.V3d_View_Pan, None, V3d_View)
V3d_View.Zoom = new_instancemethod(_V3d.V3d_View_Zoom, None, V3d_View)
V3d_View.StartZoomAtPoint = new_instancemethod(_V3d.V3d_View_StartZoomAtPoint, None, V3d_View)
V3d_View.ZoomAtPoint = new_instancemethod(_V3d.V3d_View_ZoomAtPoint, None, V3d_View)
V3d_View.AxialScale = new_instancemethod(_V3d.V3d_View_AxialScale, None, V3d_View)
V3d_View.StartRotation = new_instancemethod(_V3d.V3d_View_StartRotation, None, V3d_View)
V3d_View.Rotation = new_instancemethod(_V3d.V3d_View_Rotation, None, V3d_View)
V3d_View.SetFocale = new_instancemethod(_V3d.V3d_View_SetFocale, None, V3d_View)
V3d_View.Focale = new_instancemethod(_V3d.V3d_View_Focale, None, V3d_View)
V3d_View.View = new_instancemethod(_V3d.V3d_View_View, None, V3d_View)
V3d_View.SetComputedMode = new_instancemethod(_V3d.V3d_View_SetComputedMode, None, V3d_View)
V3d_View.ComputedMode = new_instancemethod(_V3d.V3d_View_ComputedMode, None, V3d_View)
V3d_View.WindowFitAll = new_instancemethod(_V3d.V3d_View_WindowFitAll, None, V3d_View)
V3d_View.SetGrid = new_instancemethod(_V3d.V3d_View_SetGrid, None, V3d_View)
V3d_View.SetGridGraphicValues = new_instancemethod(_V3d.V3d_View_SetGridGraphicValues, None, V3d_View)
V3d_View.SetGridActivity = new_instancemethod(_V3d.V3d_View_SetGridActivity, None, V3d_View)
V3d_View.Dump = new_instancemethod(_V3d.V3d_View_Dump, None, V3d_View)
V3d_View.ToPixMap = new_instancemethod(_V3d.V3d_View_ToPixMap, None, V3d_View)
V3d_View.SetBackFacingModel = new_instancemethod(_V3d.V3d_View_SetBackFacingModel, None, V3d_View)
V3d_View.BackFacingModel = new_instancemethod(_V3d.V3d_View_BackFacingModel, None, V3d_View)
V3d_View.EnableDepthTest = new_instancemethod(_V3d.V3d_View_EnableDepthTest, None, V3d_View)
V3d_View.IsDepthTestEnabled = new_instancemethod(_V3d.V3d_View_IsDepthTestEnabled, None, V3d_View)
V3d_View.EnableGLLight = new_instancemethod(_V3d.V3d_View_EnableGLLight, None, V3d_View)
V3d_View.IsGLLightEnabled = new_instancemethod(_V3d.V3d_View_IsGLLightEnabled, None, V3d_View)
V3d_View.AddClipPlane = new_instancemethod(_V3d.V3d_View_AddClipPlane, None, V3d_View)
V3d_View.RemoveClipPlane = new_instancemethod(_V3d.V3d_View_RemoveClipPlane, None, V3d_View)
V3d_View.SetClipPlanes = new_instancemethod(_V3d.V3d_View_SetClipPlanes, None, V3d_View)
V3d_View.GetClipPlanes = new_instancemethod(_V3d.V3d_View_GetClipPlanes, None, V3d_View)
V3d_View.SetCamera = new_instancemethod(_V3d.V3d_View_SetCamera, None, V3d_View)
V3d_View.Camera = new_instancemethod(_V3d.V3d_View_Camera, None, V3d_View)
V3d_View.RenderingParams = new_instancemethod(_V3d.V3d_View_RenderingParams, None, V3d_View)
V3d_View.ChangeRenderingParams = new_instancemethod(_V3d.V3d_View_ChangeRenderingParams, None, V3d_View)
V3d_View.IsCullingEnabled = new_instancemethod(_V3d.V3d_View_IsCullingEnabled, None, V3d_View)
V3d_View.SetFrustumCulling = new_instancemethod(_V3d.V3d_View_SetFrustumCulling, None, V3d_View)
V3d_View_swigregister = _V3d.V3d_View_swigregister
V3d_View_swigregister(V3d_View)

class Handle_V3d_View(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_View_swiginit(self, _V3d.new_Handle_V3d_View(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_View_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_View
Handle_V3d_View.Nullify = new_instancemethod(_V3d.Handle_V3d_View_Nullify, None, Handle_V3d_View)
Handle_V3d_View.IsNull = new_instancemethod(_V3d.Handle_V3d_View_IsNull, None, Handle_V3d_View)
Handle_V3d_View._get_reference = new_instancemethod(_V3d.Handle_V3d_View__get_reference, None, Handle_V3d_View)
Handle_V3d_View_swigregister = _V3d.Handle_V3d_View_swigregister
Handle_V3d_View_swigregister(Handle_V3d_View)

def Handle_V3d_View_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_View const":
    return _V3d.Handle_V3d_View_DownCast(AnObject)
Handle_V3d_View_DownCast = _V3d.Handle_V3d_View_DownCast

class V3d_Viewer(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Create a Viewer with the given graphic driver and the given parameters or with their default values. Currently creating of more than 100 viewer instances is not supported and leads to an exception. This limitation might be addressed in some future OCCT releases. If the size of the view is <= 0 Warning: Client must creates a graphic driver

        :param theDriver:
        :type theDriver: Handle_Graphic3d_GraphicDriver &
        :param theName:
        :type theName: Standard_ExtString
        :param theDomain: default value is 
        :type theDomain: char *
        :param theViewSize: default value is 1000.0
        :type theViewSize: Quantity_Length
        :param theViewProj: default value is V3d_XposYnegZpos
        :type theViewProj: V3d_TypeOfOrientation
        :param theViewBackground: default value is Quantity_NOC_GRAY30
        :type theViewBackground: Quantity_NameOfColor
        :param theVisualization: default value is V3d_ZBUFFER
        :type theVisualization: V3d_TypeOfVisualization
        :param theShadingModel: default value is V3d_GOURAUD
        :type theShadingModel: V3d_TypeOfShadingModel
        :param theUpdateMode: default value is V3d_WAIT
        :type theUpdateMode: V3d_TypeOfUpdate
        :param theComputedMode: default value is Standard_True
        :type theComputedMode: bool
        :param theDefaultComputedMode: default value is Standard_True
        :type theDefaultComputedMode: bool
        :param theSurfaceDetail: default value is V3d_TEX_NONE
        :type theSurfaceDetail: V3d_TypeOfSurfaceDetail
        :rtype: None

        """
        _V3d.V3d_Viewer_swiginit(self, _V3d.new_V3d_Viewer(*args))

    def CreateView(self, *args) -> "Handle_V3d_View":
        """
        * creates a view in the viewer according to its default parameters.

        :rtype: Handle_V3d_View

        """
        return _V3d.V3d_Viewer_CreateView(self, *args)


    def SetViewOn(self, *args) -> "void":
        """
        * Activates all of the views of a viewer attached to a window.

        :rtype: None

        * Activates a particular view in the Viewer . Must be call if the Window attached to the view has been Deiconified .

        :param View:
        :type View: Handle_V3d_View &
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetViewOn(self, *args)


    def SetViewOff(self, *args) -> "void":
        """
        * Deactivates all the views of a Viewer attached to a window.

        :rtype: None

        * Deactivates a particular view in the Viewer. Must be call if the Window attached to the view has been Iconified .

        :param View:
        :type View: Handle_V3d_View &
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetViewOff(self, *args)


    def Update(self, *args) -> "void":
        """
        * Deprecated, Redraw() should be used instead.

        :rtype: None

        """
        return _V3d.V3d_Viewer_Update(self, *args)


    def UpdateLights(self, *args) -> "void":
        """
        * Updates the lights of all the views of a viewer.

        :rtype: None

        """
        return _V3d.V3d_Viewer_UpdateLights(self, *args)


    def Redraw(self, *args) -> "void":
        """
        * Redraws all the views of the Viewer even if no modification has taken place. Must be called if all the views of the Viewer are exposed, as for example in a global DeIconification.

        :rtype: None

        """
        return _V3d.V3d_Viewer_Redraw(self, *args)


    def RedrawImmediate(self, *args) -> "void":
        """
        * Updates layer of immediate presentations.

        :rtype: None

        """
        return _V3d.V3d_Viewer_RedrawImmediate(self, *args)


    def Invalidate(self, *args) -> "void":
        """
        * Invalidates viewer content but does not redraw it.

        :rtype: None

        """
        return _V3d.V3d_Viewer_Invalidate(self, *args)


    def Remove(self, *args) -> "void":
        """
        * Suppresses the Viewer.

        :rtype: None

        """
        return _V3d.V3d_Viewer_Remove(self, *args)


    def Erase(self, *args) -> "void":
        """
        * Erase all Objects in All the views.

        :rtype: None

        """
        return _V3d.V3d_Viewer_Erase(self, *args)


    def UnHighlight(self, *args) -> "void":
        """
        * UnHighlight all Objects in All the views.

        :rtype: None

        """
        return _V3d.V3d_Viewer_UnHighlight(self, *args)


    def SetDefaultBackgroundColor(self, *args) -> "void":
        """
        * Defines the default base colour of views attached to the Viewer by supplying the type of colour definition and the three component values..

        :param Type:
        :type Type: Quantity_TypeOfColor
        :param V1:
        :type V1: Quantity_Parameter
        :param V2:
        :type V2: Quantity_Parameter
        :param V3:
        :type V3: Quantity_Parameter
        :rtype: None

        * Defines the default background colour of views attached to the viewer by supplying the name of the colour under the form Quantity_NOC_xxxx .

        :param Name:
        :type Name: Quantity_NameOfColor
        :rtype: None

        * Defines the default background colour of views attached to the viewer by supplying the color object

        :param Color:
        :type Color: Quantity_Color &
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultBackgroundColor(self, *args)


    def SetDefaultBgGradientColors(self, *args) -> "void":
        """
        * Defines the default gradient background colours of view attached to the viewer by supplying the name of the colours under the form Quantity_NOC_xxxx .

        :param Name1:
        :type Name1: Quantity_NameOfColor
        :param Name2:
        :type Name2: Quantity_NameOfColor
        :param FillStyle: default value is Aspect_GFM_HOR
        :type FillStyle: Aspect_GradientFillMethod
        :rtype: None

        * Defines the default gradient background colours of views attached to the viewer by supplying the colour objects

        :param Color1:
        :type Color1: Quantity_Color &
        :param Color2:
        :type Color2: Quantity_Color &
        :param FillStyle: default value is Aspect_GFM_HOR
        :type FillStyle: Aspect_GradientFillMethod
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultBgGradientColors(self, *args)


    def SetDefaultViewSize(self, *args) -> "void":
        """
        * Gives a default size for the creation of views of the viewer.

        :param Size:
        :type Size: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultViewSize(self, *args)


    def SetDefaultViewProj(self, *args) -> "void":
        """
        * Gives the default projection for creating views in the viewer.

        :param Orientation:
        :type Orientation: V3d_TypeOfOrientation
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultViewProj(self, *args)


    def SetDefaultVisualization(self, *args) -> "void":
        """
        * Gives the default visualisation mode..

        :param Type:
        :type Type: V3d_TypeOfVisualization
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultVisualization(self, *args)


    def SetZBufferManagment(self, *args) -> "void":
        """
        * defines the strategy concerning the ZBuffer activity. If Automatic is true, ZBuffer will be activated or deactivated depending on the fact that faces exist or not in the Viewer. This will optimize the response time in the case where only wireframe objects are displayed. If Automatic is False, ZBuffer will be activated or deactivated depending on the choice of SetVisualization in each View. Note that by default, the ZBufferManagment is not automatic.

        :param Automatic:
        :type Automatic: bool
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetZBufferManagment(self, *args)


    def ZBufferManagment(self, *args) -> "Standard_Boolean":
        """
        * returns the ZBuffer stategy choice.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_ZBufferManagment(self, *args)


    def SetDefaultShadingModel(self, *args) -> "void":
        """
        * Gives the default type of SHADING.

        :param Type:
        :type Type: V3d_TypeOfShadingModel
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultShadingModel(self, *args)


    def SetDefaultSurfaceDetail(self, *args) -> "void":
        """
        * Gives the default type of texture mapping.

        :param Type:
        :type Type: V3d_TypeOfSurfaceDetail
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultSurfaceDetail(self, *args)


    def SetDefaultAngle(self, *args) -> "void":
        """
        :param Angle:
        :type Angle: Quantity_PlaneAngle
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultAngle(self, *args)


    def SetUpdateMode(self, *args) -> "void":
        """
        * Defines the mode of regenerating the views making up the viewer. This can be immediate <ASAP> or deferred <WAIT>. In this latter case, the views are updated when the method Update(me) is called.

        :param Mode:
        :type Mode: V3d_TypeOfUpdate
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetUpdateMode(self, *args)


    def SetDefaultTypeOfView(self, *args) -> "void":
        """
        :param Type:
        :type Type: V3d_TypeOfView
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultTypeOfView(self, *args)


    def SetPrivilegedPlane(self, *args) -> "void":
        """
        :param aPlane:
        :type aPlane: gp_Ax3
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetPrivilegedPlane(self, *args)


    def PrivilegedPlane(self, *args) -> "gp_Ax3":
        """
        :rtype: gp_Ax3

        """
        return _V3d.V3d_Viewer_PrivilegedPlane(self, *args)


    def DisplayPrivilegedPlane(self, *args) -> "void":
        """
        :param OnOff:
        :type OnOff: bool
        :param aSize: default value is 1
        :type aSize: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_Viewer_DisplayPrivilegedPlane(self, *args)


    def SetLightOn(self, *args) -> "void":
        """
        * Activates MyLight in the viewer.

        :param MyLight:
        :type MyLight: Handle_V3d_Light &
        :rtype: None

        * Activates all the lights defined in this viewer.

        :rtype: None

        """
        return _V3d.V3d_Viewer_SetLightOn(self, *args)


    def SetLightOff(self, *args) -> "void":
        """
        * Desactivate MyLight in this viewer.

        :param MyLight:
        :type MyLight: Handle_V3d_Light &
        :rtype: None

        * Deactivate all the Lights defined in this viewer.

        :rtype: None

        """
        return _V3d.V3d_Viewer_SetLightOff(self, *args)


    def DelLight(self, *args) -> "void":
        """
        * Delete Light in Sequence Of Lights.

        :param MyLight:
        :type MyLight: Handle_V3d_Light &
        :rtype: None

        """
        return _V3d.V3d_Viewer_DelLight(self, *args)


    def SetCurrentSelectedLight(self, *args) -> "void":
        """
        * Defines the selected light.

        :param TheLight:
        :type TheLight: Handle_V3d_Light &
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetCurrentSelectedLight(self, *args)


    def ClearCurrentSelectedLight(self, *args) -> "void":
        """
        * Defines the selected light at NULL.

        :rtype: None

        """
        return _V3d.V3d_Viewer_ClearCurrentSelectedLight(self, *args)


    def DefaultBackgroundColor(self, *args) -> "Quantity_Color":
        """
        * Returns the default background colour depending of the type.

        :param Type:
        :type Type: Quantity_TypeOfColor
        :param V1:
        :type V1: Quantity_Parameter &
        :param V2:
        :type V2: Quantity_Parameter &
        :param V3:
        :type V3: Quantity_Parameter &
        :rtype: None

        * Returns the default background colour object.

        :rtype: Quantity_Color

        """
        return _V3d.V3d_Viewer_DefaultBackgroundColor(self, *args)


    def DefaultBgGradientColors(self, *args) -> "void":
        """
        * Returns the gradient background colour objects of the view.

        :param Color1:
        :type Color1: Quantity_Color &
        :param Color2:
        :type Color2: Quantity_Color &
        :rtype: None

        """
        return _V3d.V3d_Viewer_DefaultBgGradientColors(self, *args)


    def DefaultViewSize(self, *args) -> "Quantity_Length":
        """
        * Returns the default size of the view.

        :rtype: Quantity_Length

        """
        return _V3d.V3d_Viewer_DefaultViewSize(self, *args)


    def DefaultViewProj(self, *args) -> "V3d_TypeOfOrientation":
        """
        * Returns the default Projection.

        :rtype: V3d_TypeOfOrientation

        """
        return _V3d.V3d_Viewer_DefaultViewProj(self, *args)


    def DefaultVisualization(self, *args) -> "V3d_TypeOfVisualization":
        """
        * Returns the default type of Visualization.

        :rtype: V3d_TypeOfVisualization

        """
        return _V3d.V3d_Viewer_DefaultVisualization(self, *args)


    def DefaultShadingModel(self, *args) -> "V3d_TypeOfShadingModel":
        """
        * Returns the default type of Shading

        :rtype: V3d_TypeOfShadingModel

        """
        return _V3d.V3d_Viewer_DefaultShadingModel(self, *args)


    def DefaultSurfaceDetail(self, *args) -> "V3d_TypeOfSurfaceDetail":
        """
        * Returns the default type of texture mapping

        :rtype: V3d_TypeOfSurfaceDetail

        """
        return _V3d.V3d_Viewer_DefaultSurfaceDetail(self, *args)


    def DefaultAngle(self, *args) -> "Quantity_PlaneAngle":
        """
        :rtype: Quantity_PlaneAngle

        """
        return _V3d.V3d_Viewer_DefaultAngle(self, *args)


    def UpdateMode(self, *args) -> "V3d_TypeOfUpdate":
        """
        * Returns the regeneration mode of views in the viewer.

        :rtype: V3d_TypeOfUpdate

        """
        return _V3d.V3d_Viewer_UpdateMode(self, *args)


    def IfMoreViews(self, *args) -> "Standard_Boolean":
        """
        * Returns True if One View more can be activated in this Viewer.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_IfMoreViews(self, *args)


    def InitActiveViews(self, *args) -> "void":
        """
        * initializes an iteration on the active views.

        :rtype: None

        """
        return _V3d.V3d_Viewer_InitActiveViews(self, *args)


    def MoreActiveViews(self, *args) -> "Standard_Boolean":
        """
        * returns true if there are more active view(s) to return.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_MoreActiveViews(self, *args)


    def NextActiveViews(self, *args) -> "void":
        """
        * Go to the next active view (if there is not, ActiveView will raise an exception)

        :rtype: None

        """
        return _V3d.V3d_Viewer_NextActiveViews(self, *args)


    def ActiveView(self, *args) -> "Handle_V3d_View":
        """
        :rtype: Handle_V3d_View

        """
        return _V3d.V3d_Viewer_ActiveView(self, *args)


    def LastActiveView(self, *args) -> "Standard_Boolean":
        """
        * returns true if there is only one active view.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_LastActiveView(self, *args)


    def InitDefinedViews(self, *args) -> "void":
        """
        * initializes an iteration on the Defined views.

        :rtype: None

        """
        return _V3d.V3d_Viewer_InitDefinedViews(self, *args)


    def MoreDefinedViews(self, *args) -> "Standard_Boolean":
        """
        * returns true if there are more Defined view(s) to return.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_MoreDefinedViews(self, *args)


    def NextDefinedViews(self, *args) -> "void":
        """
        * Go to the next Defined view (if there is not, DefinedView will raise an exception)

        :rtype: None

        """
        return _V3d.V3d_Viewer_NextDefinedViews(self, *args)


    def DefinedView(self, *args) -> "Handle_V3d_View":
        """
        :rtype: Handle_V3d_View

        """
        return _V3d.V3d_Viewer_DefinedView(self, *args)


    def InitActiveLights(self, *args) -> "void":
        """
        * initializes an iteration on the active Lights.

        :rtype: None

        """
        return _V3d.V3d_Viewer_InitActiveLights(self, *args)


    def MoreActiveLights(self, *args) -> "Standard_Boolean":
        """
        * returns true if there are more active Light(s) to return.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_MoreActiveLights(self, *args)


    def NextActiveLights(self, *args) -> "void":
        """
        * Go to the next active Light (if there is not, ActiveLight will raise an exception)

        :rtype: None

        """
        return _V3d.V3d_Viewer_NextActiveLights(self, *args)


    def ActiveLight(self, *args) -> "Handle_V3d_Light":
        """
        :rtype: Handle_V3d_Light

        """
        return _V3d.V3d_Viewer_ActiveLight(self, *args)


    def InitDefinedLights(self, *args) -> "void":
        """
        * initializes an iteration on the Defined Lights.

        :rtype: None

        """
        return _V3d.V3d_Viewer_InitDefinedLights(self, *args)


    def MoreDefinedLights(self, *args) -> "Standard_Boolean":
        """
        * returns true if there are more Defined Light(s) to return.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_MoreDefinedLights(self, *args)


    def NextDefinedLights(self, *args) -> "void":
        """
        * Go to the next Defined Light (if there is not, DefinedLight will raise an exception)

        :rtype: None

        """
        return _V3d.V3d_Viewer_NextDefinedLights(self, *args)


    def DefinedLight(self, *args) -> "Handle_V3d_Light":
        """
        :rtype: Handle_V3d_Light

        """
        return _V3d.V3d_Viewer_DefinedLight(self, *args)


    def Viewer(self, *args) -> "Handle_Visual3d_ViewManager":
        """
        * Returns the viewer associated to Visual3d .

        :rtype: Handle_Visual3d_ViewManager

        """
        return _V3d.V3d_Viewer_Viewer(self, *args)


    def CurrentSelectedLight(self, *args) -> "Handle_V3d_Light":
        """
        * Returns the Selected Light.

        :rtype: Handle_V3d_Light

        """
        return _V3d.V3d_Viewer_CurrentSelectedLight(self, *args)


    def IsGlobalLight(self, *args) -> "Standard_Boolean":
        """
        :param TheLight:
        :type TheLight: Handle_V3d_Light &
        :rtype: bool

        """
        return _V3d.V3d_Viewer_IsGlobalLight(self, *args)


    def ComputedMode(self, *args) -> "Standard_Boolean":
        """
        * returns true if the computed mode can be used.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_ComputedMode(self, *args)


    def DefaultComputedMode(self, *args) -> "Standard_Boolean":
        """
        * returns true if by default the computed mode must be used.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_DefaultComputedMode(self, *args)


    def ActivateGrid(self, *args) -> "void":
        """
        * Activates the grid in all views of <self>.

        :param aGridType:
        :type aGridType: Aspect_GridType
        :param aGridDrawMode:
        :type aGridDrawMode: Aspect_GridDrawMode
        :rtype: None

        """
        return _V3d.V3d_Viewer_ActivateGrid(self, *args)


    def DeactivateGrid(self, *args) -> "void":
        """
        * Deactivates the grid in all views of <self>.

        :rtype: None

        """
        return _V3d.V3d_Viewer_DeactivateGrid(self, *args)


    def SetGridEcho(self, *args) -> "void":
        """
        * Show/Don't show grid echo to the hit point. If True,the grid echo will be shown at ConvertToGrid() time.

        :param showGrid: default value is Standard_True
        :type showGrid: bool
        :rtype: None

        * Show grid echo <aMarker> to the hit point. Warning: When the grid echo marker is not set, a default marker is build with the attributes: marker type : Aspect_TOM_STAR marker color : Quantity_NOC_GRAY90 marker size : 3.0

        :param aMarker:
        :type aMarker: Handle_Graphic3d_AspectMarker3d &
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetGridEcho(self, *args)


    def GridEcho(self, *args) -> "Standard_Boolean":
        """
        * Returns True when grid echo must be displayed at hit point.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_GridEcho(self, *args)


    def IsActive(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if a grid is activated in <self>.

        :rtype: bool

        """
        return _V3d.V3d_Viewer_IsActive(self, *args)


    def Grid(self, *args) -> "Handle_Aspect_Grid":
        """
        * Returns the defined grid in <self>.

        :rtype: Handle_Aspect_Grid

        """
        return _V3d.V3d_Viewer_Grid(self, *args)


    def GridType(self, *args) -> "Aspect_GridType":
        """
        * Returns the current grid type defined in <self>.

        :rtype: Aspect_GridType

        """
        return _V3d.V3d_Viewer_GridType(self, *args)


    def GridDrawMode(self, *args) -> "Aspect_GridDrawMode":
        """
        * Returns the current grid draw mode defined in <self>.

        :rtype: Aspect_GridDrawMode

        """
        return _V3d.V3d_Viewer_GridDrawMode(self, *args)


    def RectangularGridValues(self, *args) -> "void":
        """
        * Returns the definition of the rectangular grid.

        :param XOrigin:
        :type XOrigin: Quantity_Length &
        :param YOrigin:
        :type YOrigin: Quantity_Length &
        :param XStep:
        :type XStep: Quantity_Length &
        :param YStep:
        :type YStep: Quantity_Length &
        :param RotationAngle:
        :type RotationAngle: Quantity_PlaneAngle &
        :rtype: None

        """
        return _V3d.V3d_Viewer_RectangularGridValues(self, *args)


    def SetRectangularGridValues(self, *args) -> "void":
        """
        * Sets the definition of the rectangular grid. <XOrigin>, <YOrigin> defines the origin of the grid. <XStep> defines the interval between 2 vertical lines. <YStep> defines the interval between 2 horizontal lines. <RotationAngle> defines the rotation angle of the grid.

        :param XOrigin:
        :type XOrigin: Quantity_Length
        :param YOrigin:
        :type YOrigin: Quantity_Length
        :param XStep:
        :type XStep: Quantity_Length
        :param YStep:
        :type YStep: Quantity_Length
        :param RotationAngle:
        :type RotationAngle: Quantity_PlaneAngle
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetRectangularGridValues(self, *args)


    def CircularGridValues(self, *args) -> "void":
        """
        * Returns the definition of the circular grid.

        :param XOrigin:
        :type XOrigin: Quantity_Length &
        :param YOrigin:
        :type YOrigin: Quantity_Length &
        :param RadiusStep:
        :type RadiusStep: Quantity_Length &
        :param DivisionNumber:
        :type DivisionNumber: int &
        :param RotationAngle:
        :type RotationAngle: Quantity_PlaneAngle &
        :rtype: None

        """
        return _V3d.V3d_Viewer_CircularGridValues(self, *args)


    def SetCircularGridValues(self, *args) -> "void":
        """
        * Sets the definition of the circular grid. <XOrigin>, <YOrigin> defines the origin of the grid. <RadiusStep> defines the interval between 2 circles. <DivisionNumber> defines the section number of one half circle. <RotationAngle> defines the rotation angle of the grid.

        :param XOrigin:
        :type XOrigin: Quantity_Length
        :param YOrigin:
        :type YOrigin: Quantity_Length
        :param RadiusStep:
        :type RadiusStep: Quantity_Length
        :param DivisionNumber:
        :type DivisionNumber: int
        :param RotationAngle:
        :type RotationAngle: Quantity_PlaneAngle
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetCircularGridValues(self, *args)


    def CircularGridGraphicValues(self, *args) -> "void":
        """
        * Returns the location and the size of the grid.

        :param Radius:
        :type Radius: Quantity_Length &
        :param OffSet:
        :type OffSet: Quantity_Length &
        :rtype: None

        """
        return _V3d.V3d_Viewer_CircularGridGraphicValues(self, *args)


    def SetCircularGridGraphicValues(self, *args) -> "void":
        """
        * Sets the location and the size of the grid. <XSize> defines the width of the grid. <YSize> defines the height of the grid. <OffSet> defines the displacement along the plane normal.

        :param Radius:
        :type Radius: Quantity_Length
        :param OffSet:
        :type OffSet: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetCircularGridGraphicValues(self, *args)


    def RectangularGridGraphicValues(self, *args) -> "void":
        """
        * Returns the location and the size of the grid.

        :param XSize:
        :type XSize: Quantity_Length &
        :param YSize:
        :type YSize: Quantity_Length &
        :param OffSet:
        :type OffSet: Quantity_Length &
        :rtype: None

        """
        return _V3d.V3d_Viewer_RectangularGridGraphicValues(self, *args)


    def SetRectangularGridGraphicValues(self, *args) -> "void":
        """
        * Sets the location and the size of the grid. <XSize> defines the width of the grid. <YSize> defines the height of the grid. <OffSet> defines the displacement along the plane normal.

        :param XSize:
        :type XSize: Quantity_Length
        :param YSize:
        :type YSize: Quantity_Length
        :param OffSet:
        :type OffSet: Quantity_Length
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetRectangularGridGraphicValues(self, *args)


    def GetGradientBackground(self, *args) -> "Aspect_GradientBackground":
        """
        * Returns the gradient background of the view.

        :rtype: Aspect_GradientBackground

        """
        return _V3d.V3d_Viewer_GetGradientBackground(self, *args)


    def SetDefaultLights(self, *args) -> "void":
        """
        * defines default lights - positional-light 0.3 0. 0. directional-light V3d_XnegYposZpos directional-light V3d_XnegYneg ambient-light

        :rtype: None

        """
        return _V3d.V3d_Viewer_SetDefaultLights(self, *args)


    def ShowGridEcho(self, *args) -> "void":
        """
        * Display grid echo at requested point in the view.

        :param theView:
        :type theView: Handle_V3d_View &
        :param thePoint:
        :type thePoint: Graphic3d_Vertex &
        :rtype: None

        """
        return _V3d.V3d_Viewer_ShowGridEcho(self, *args)


    def HideGridEcho(self, *args) -> "void":
        """
        * Temporarly hide grid echo.

        :param theView:
        :type theView: Handle_V3d_View &
        :rtype: None

        """
        return _V3d.V3d_Viewer_HideGridEcho(self, *args)


    def SetZLayerSettings(self, *args) -> "void":
        """
        * Sets the settings for a single Z layer.

        :param theLayerId:
        :type theLayerId: int
        :param theSettings:
        :type theSettings: Graphic3d_ZLayerSettings &
        :rtype: None

        """
        return _V3d.V3d_Viewer_SetZLayerSettings(self, *args)


    def ZLayerSettings(self, *args) -> "Graphic3d_ZLayerSettings":
        """
        * Returns the settings of a single Z layer.

        :param theLayerId:
        :type theLayerId: int
        :rtype: Graphic3d_ZLayerSettings

        """
        return _V3d.V3d_Viewer_ZLayerSettings(self, *args)


    def AddZLayer(self, *args) -> "Standard_Boolean":
        """
        * Add a new top-level Z layer to all managed views and get its ID as <theLayerId> value. The Z layers are controlled entirely by viewer, it is not possible to add a layer to a particular view. The method returns Standard_False if the layer can not be created. The layer mechanism allows to display structures in higher layers in overlay of structures in lower layers.

        :param theLayerId:
        :type theLayerId: int &
        :rtype: bool

        """
        return _V3d.V3d_Viewer_AddZLayer(self, *args)


    def RemoveZLayer(self, *args) -> "Standard_Boolean":
        """
        * Remove Z layer with ID <theLayerId>. Method returns Standard_False if the layer can not be removed or doesn't exists. By default, there are always default bottom-level layer that can't be removed.

        :param theLayerId:
        :type theLayerId: int
        :rtype: bool

        """
        return _V3d.V3d_Viewer_RemoveZLayer(self, *args)


    def GetAllZLayers(self, *args) -> "void":
        """
        * Return all Z layer ids in sequence ordered by overlay level from lowest layer to highest ( foreground ). The first layer ID in sequence is the default layer that can't be removed.

        :param theLayerSeq:
        :type theLayerSeq: TColStd_SequenceOfInteger &
        :rtype: None

        """
        return _V3d.V3d_Viewer_GetAllZLayers(self, *args)


    def Driver(self, *args) -> "Handle_Graphic3d_GraphicDriver":
        """
        :rtype: Handle_Graphic3d_GraphicDriver

        """
        return _V3d.V3d_Viewer_Driver(self, *args)


    def NextName(self, *args) -> "Standard_ExtString":
        """
        :rtype: Standard_ExtString

        """
        return _V3d.V3d_Viewer_NextName(self, *args)


    def Domain(self, *args) -> "char const *":
        """
        :rtype: char *

        """
        return _V3d.V3d_Viewer_Domain(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_Viewer(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_Viewer
V3d_Viewer.CreateView = new_instancemethod(_V3d.V3d_Viewer_CreateView, None, V3d_Viewer)
V3d_Viewer.SetViewOn = new_instancemethod(_V3d.V3d_Viewer_SetViewOn, None, V3d_Viewer)
V3d_Viewer.SetViewOff = new_instancemethod(_V3d.V3d_Viewer_SetViewOff, None, V3d_Viewer)
V3d_Viewer.Update = new_instancemethod(_V3d.V3d_Viewer_Update, None, V3d_Viewer)
V3d_Viewer.UpdateLights = new_instancemethod(_V3d.V3d_Viewer_UpdateLights, None, V3d_Viewer)
V3d_Viewer.Redraw = new_instancemethod(_V3d.V3d_Viewer_Redraw, None, V3d_Viewer)
V3d_Viewer.RedrawImmediate = new_instancemethod(_V3d.V3d_Viewer_RedrawImmediate, None, V3d_Viewer)
V3d_Viewer.Invalidate = new_instancemethod(_V3d.V3d_Viewer_Invalidate, None, V3d_Viewer)
V3d_Viewer.Remove = new_instancemethod(_V3d.V3d_Viewer_Remove, None, V3d_Viewer)
V3d_Viewer.Erase = new_instancemethod(_V3d.V3d_Viewer_Erase, None, V3d_Viewer)
V3d_Viewer.UnHighlight = new_instancemethod(_V3d.V3d_Viewer_UnHighlight, None, V3d_Viewer)
V3d_Viewer.SetDefaultBackgroundColor = new_instancemethod(_V3d.V3d_Viewer_SetDefaultBackgroundColor, None, V3d_Viewer)
V3d_Viewer.SetDefaultBgGradientColors = new_instancemethod(_V3d.V3d_Viewer_SetDefaultBgGradientColors, None, V3d_Viewer)
V3d_Viewer.SetDefaultViewSize = new_instancemethod(_V3d.V3d_Viewer_SetDefaultViewSize, None, V3d_Viewer)
V3d_Viewer.SetDefaultViewProj = new_instancemethod(_V3d.V3d_Viewer_SetDefaultViewProj, None, V3d_Viewer)
V3d_Viewer.SetDefaultVisualization = new_instancemethod(_V3d.V3d_Viewer_SetDefaultVisualization, None, V3d_Viewer)
V3d_Viewer.SetZBufferManagment = new_instancemethod(_V3d.V3d_Viewer_SetZBufferManagment, None, V3d_Viewer)
V3d_Viewer.ZBufferManagment = new_instancemethod(_V3d.V3d_Viewer_ZBufferManagment, None, V3d_Viewer)
V3d_Viewer.SetDefaultShadingModel = new_instancemethod(_V3d.V3d_Viewer_SetDefaultShadingModel, None, V3d_Viewer)
V3d_Viewer.SetDefaultSurfaceDetail = new_instancemethod(_V3d.V3d_Viewer_SetDefaultSurfaceDetail, None, V3d_Viewer)
V3d_Viewer.SetDefaultAngle = new_instancemethod(_V3d.V3d_Viewer_SetDefaultAngle, None, V3d_Viewer)
V3d_Viewer.SetUpdateMode = new_instancemethod(_V3d.V3d_Viewer_SetUpdateMode, None, V3d_Viewer)
V3d_Viewer.SetDefaultTypeOfView = new_instancemethod(_V3d.V3d_Viewer_SetDefaultTypeOfView, None, V3d_Viewer)
V3d_Viewer.SetPrivilegedPlane = new_instancemethod(_V3d.V3d_Viewer_SetPrivilegedPlane, None, V3d_Viewer)
V3d_Viewer.PrivilegedPlane = new_instancemethod(_V3d.V3d_Viewer_PrivilegedPlane, None, V3d_Viewer)
V3d_Viewer.DisplayPrivilegedPlane = new_instancemethod(_V3d.V3d_Viewer_DisplayPrivilegedPlane, None, V3d_Viewer)
V3d_Viewer.SetLightOn = new_instancemethod(_V3d.V3d_Viewer_SetLightOn, None, V3d_Viewer)
V3d_Viewer.SetLightOff = new_instancemethod(_V3d.V3d_Viewer_SetLightOff, None, V3d_Viewer)
V3d_Viewer.DelLight = new_instancemethod(_V3d.V3d_Viewer_DelLight, None, V3d_Viewer)
V3d_Viewer.SetCurrentSelectedLight = new_instancemethod(_V3d.V3d_Viewer_SetCurrentSelectedLight, None, V3d_Viewer)
V3d_Viewer.ClearCurrentSelectedLight = new_instancemethod(_V3d.V3d_Viewer_ClearCurrentSelectedLight, None, V3d_Viewer)
V3d_Viewer.DefaultBackgroundColor = new_instancemethod(_V3d.V3d_Viewer_DefaultBackgroundColor, None, V3d_Viewer)
V3d_Viewer.DefaultBgGradientColors = new_instancemethod(_V3d.V3d_Viewer_DefaultBgGradientColors, None, V3d_Viewer)
V3d_Viewer.DefaultViewSize = new_instancemethod(_V3d.V3d_Viewer_DefaultViewSize, None, V3d_Viewer)
V3d_Viewer.DefaultViewProj = new_instancemethod(_V3d.V3d_Viewer_DefaultViewProj, None, V3d_Viewer)
V3d_Viewer.DefaultVisualization = new_instancemethod(_V3d.V3d_Viewer_DefaultVisualization, None, V3d_Viewer)
V3d_Viewer.DefaultShadingModel = new_instancemethod(_V3d.V3d_Viewer_DefaultShadingModel, None, V3d_Viewer)
V3d_Viewer.DefaultSurfaceDetail = new_instancemethod(_V3d.V3d_Viewer_DefaultSurfaceDetail, None, V3d_Viewer)
V3d_Viewer.DefaultAngle = new_instancemethod(_V3d.V3d_Viewer_DefaultAngle, None, V3d_Viewer)
V3d_Viewer.UpdateMode = new_instancemethod(_V3d.V3d_Viewer_UpdateMode, None, V3d_Viewer)
V3d_Viewer.IfMoreViews = new_instancemethod(_V3d.V3d_Viewer_IfMoreViews, None, V3d_Viewer)
V3d_Viewer.InitActiveViews = new_instancemethod(_V3d.V3d_Viewer_InitActiveViews, None, V3d_Viewer)
V3d_Viewer.MoreActiveViews = new_instancemethod(_V3d.V3d_Viewer_MoreActiveViews, None, V3d_Viewer)
V3d_Viewer.NextActiveViews = new_instancemethod(_V3d.V3d_Viewer_NextActiveViews, None, V3d_Viewer)
V3d_Viewer.ActiveView = new_instancemethod(_V3d.V3d_Viewer_ActiveView, None, V3d_Viewer)
V3d_Viewer.LastActiveView = new_instancemethod(_V3d.V3d_Viewer_LastActiveView, None, V3d_Viewer)
V3d_Viewer.InitDefinedViews = new_instancemethod(_V3d.V3d_Viewer_InitDefinedViews, None, V3d_Viewer)
V3d_Viewer.MoreDefinedViews = new_instancemethod(_V3d.V3d_Viewer_MoreDefinedViews, None, V3d_Viewer)
V3d_Viewer.NextDefinedViews = new_instancemethod(_V3d.V3d_Viewer_NextDefinedViews, None, V3d_Viewer)
V3d_Viewer.DefinedView = new_instancemethod(_V3d.V3d_Viewer_DefinedView, None, V3d_Viewer)
V3d_Viewer.InitActiveLights = new_instancemethod(_V3d.V3d_Viewer_InitActiveLights, None, V3d_Viewer)
V3d_Viewer.MoreActiveLights = new_instancemethod(_V3d.V3d_Viewer_MoreActiveLights, None, V3d_Viewer)
V3d_Viewer.NextActiveLights = new_instancemethod(_V3d.V3d_Viewer_NextActiveLights, None, V3d_Viewer)
V3d_Viewer.ActiveLight = new_instancemethod(_V3d.V3d_Viewer_ActiveLight, None, V3d_Viewer)
V3d_Viewer.InitDefinedLights = new_instancemethod(_V3d.V3d_Viewer_InitDefinedLights, None, V3d_Viewer)
V3d_Viewer.MoreDefinedLights = new_instancemethod(_V3d.V3d_Viewer_MoreDefinedLights, None, V3d_Viewer)
V3d_Viewer.NextDefinedLights = new_instancemethod(_V3d.V3d_Viewer_NextDefinedLights, None, V3d_Viewer)
V3d_Viewer.DefinedLight = new_instancemethod(_V3d.V3d_Viewer_DefinedLight, None, V3d_Viewer)
V3d_Viewer.Viewer = new_instancemethod(_V3d.V3d_Viewer_Viewer, None, V3d_Viewer)
V3d_Viewer.CurrentSelectedLight = new_instancemethod(_V3d.V3d_Viewer_CurrentSelectedLight, None, V3d_Viewer)
V3d_Viewer.IsGlobalLight = new_instancemethod(_V3d.V3d_Viewer_IsGlobalLight, None, V3d_Viewer)
V3d_Viewer.ComputedMode = new_instancemethod(_V3d.V3d_Viewer_ComputedMode, None, V3d_Viewer)
V3d_Viewer.DefaultComputedMode = new_instancemethod(_V3d.V3d_Viewer_DefaultComputedMode, None, V3d_Viewer)
V3d_Viewer.ActivateGrid = new_instancemethod(_V3d.V3d_Viewer_ActivateGrid, None, V3d_Viewer)
V3d_Viewer.DeactivateGrid = new_instancemethod(_V3d.V3d_Viewer_DeactivateGrid, None, V3d_Viewer)
V3d_Viewer.SetGridEcho = new_instancemethod(_V3d.V3d_Viewer_SetGridEcho, None, V3d_Viewer)
V3d_Viewer.GridEcho = new_instancemethod(_V3d.V3d_Viewer_GridEcho, None, V3d_Viewer)
V3d_Viewer.IsActive = new_instancemethod(_V3d.V3d_Viewer_IsActive, None, V3d_Viewer)
V3d_Viewer.Grid = new_instancemethod(_V3d.V3d_Viewer_Grid, None, V3d_Viewer)
V3d_Viewer.GridType = new_instancemethod(_V3d.V3d_Viewer_GridType, None, V3d_Viewer)
V3d_Viewer.GridDrawMode = new_instancemethod(_V3d.V3d_Viewer_GridDrawMode, None, V3d_Viewer)
V3d_Viewer.RectangularGridValues = new_instancemethod(_V3d.V3d_Viewer_RectangularGridValues, None, V3d_Viewer)
V3d_Viewer.SetRectangularGridValues = new_instancemethod(_V3d.V3d_Viewer_SetRectangularGridValues, None, V3d_Viewer)
V3d_Viewer.CircularGridValues = new_instancemethod(_V3d.V3d_Viewer_CircularGridValues, None, V3d_Viewer)
V3d_Viewer.SetCircularGridValues = new_instancemethod(_V3d.V3d_Viewer_SetCircularGridValues, None, V3d_Viewer)
V3d_Viewer.CircularGridGraphicValues = new_instancemethod(_V3d.V3d_Viewer_CircularGridGraphicValues, None, V3d_Viewer)
V3d_Viewer.SetCircularGridGraphicValues = new_instancemethod(_V3d.V3d_Viewer_SetCircularGridGraphicValues, None, V3d_Viewer)
V3d_Viewer.RectangularGridGraphicValues = new_instancemethod(_V3d.V3d_Viewer_RectangularGridGraphicValues, None, V3d_Viewer)
V3d_Viewer.SetRectangularGridGraphicValues = new_instancemethod(_V3d.V3d_Viewer_SetRectangularGridGraphicValues, None, V3d_Viewer)
V3d_Viewer.GetGradientBackground = new_instancemethod(_V3d.V3d_Viewer_GetGradientBackground, None, V3d_Viewer)
V3d_Viewer.SetDefaultLights = new_instancemethod(_V3d.V3d_Viewer_SetDefaultLights, None, V3d_Viewer)
V3d_Viewer.ShowGridEcho = new_instancemethod(_V3d.V3d_Viewer_ShowGridEcho, None, V3d_Viewer)
V3d_Viewer.HideGridEcho = new_instancemethod(_V3d.V3d_Viewer_HideGridEcho, None, V3d_Viewer)
V3d_Viewer.SetZLayerSettings = new_instancemethod(_V3d.V3d_Viewer_SetZLayerSettings, None, V3d_Viewer)
V3d_Viewer.ZLayerSettings = new_instancemethod(_V3d.V3d_Viewer_ZLayerSettings, None, V3d_Viewer)
V3d_Viewer.AddZLayer = new_instancemethod(_V3d.V3d_Viewer_AddZLayer, None, V3d_Viewer)
V3d_Viewer.RemoveZLayer = new_instancemethod(_V3d.V3d_Viewer_RemoveZLayer, None, V3d_Viewer)
V3d_Viewer.GetAllZLayers = new_instancemethod(_V3d.V3d_Viewer_GetAllZLayers, None, V3d_Viewer)
V3d_Viewer.Driver = new_instancemethod(_V3d.V3d_Viewer_Driver, None, V3d_Viewer)
V3d_Viewer.NextName = new_instancemethod(_V3d.V3d_Viewer_NextName, None, V3d_Viewer)
V3d_Viewer.Domain = new_instancemethod(_V3d.V3d_Viewer_Domain, None, V3d_Viewer)
V3d_Viewer_swigregister = _V3d.V3d_Viewer_swigregister
V3d_Viewer_swigregister(V3d_Viewer)

class Handle_V3d_Viewer(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_Viewer_swiginit(self, _V3d.new_Handle_V3d_Viewer(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_Viewer_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_Viewer
Handle_V3d_Viewer.Nullify = new_instancemethod(_V3d.Handle_V3d_Viewer_Nullify, None, Handle_V3d_Viewer)
Handle_V3d_Viewer.IsNull = new_instancemethod(_V3d.Handle_V3d_Viewer_IsNull, None, Handle_V3d_Viewer)
Handle_V3d_Viewer._get_reference = new_instancemethod(_V3d.Handle_V3d_Viewer__get_reference, None, Handle_V3d_Viewer)
Handle_V3d_Viewer_swigregister = _V3d.Handle_V3d_Viewer_swigregister
Handle_V3d_Viewer_swigregister(Handle_V3d_Viewer)

def Handle_V3d_Viewer_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_Viewer const":
    return _V3d.Handle_V3d_Viewer_DownCast(AnObject)
Handle_V3d_Viewer_DownCast = _V3d.Handle_V3d_Viewer_DownCast

class V3d_AmbientLight(V3d_Light):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an ambient light source in the viewer VM. The default Color of this light source is WHITE.

        :param VM:
        :type VM: Handle_V3d_Viewer &
        :param Color: default value is Quantity_NOC_WHITE
        :type Color: Quantity_NameOfColor
        :rtype: None

        """
        _V3d.V3d_AmbientLight_swiginit(self, _V3d.new_V3d_AmbientLight(*args))

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_AmbientLight(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_AmbientLight
V3d_AmbientLight_swigregister = _V3d.V3d_AmbientLight_swigregister
V3d_AmbientLight_swigregister(V3d_AmbientLight)

class Handle_V3d_AmbientLight(Handle_V3d_Light):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_AmbientLight_swiginit(self, _V3d.new_Handle_V3d_AmbientLight(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_AmbientLight_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_AmbientLight
Handle_V3d_AmbientLight.Nullify = new_instancemethod(_V3d.Handle_V3d_AmbientLight_Nullify, None, Handle_V3d_AmbientLight)
Handle_V3d_AmbientLight.IsNull = new_instancemethod(_V3d.Handle_V3d_AmbientLight_IsNull, None, Handle_V3d_AmbientLight)
Handle_V3d_AmbientLight._get_reference = new_instancemethod(_V3d.Handle_V3d_AmbientLight__get_reference, None, Handle_V3d_AmbientLight)
Handle_V3d_AmbientLight_swigregister = _V3d.Handle_V3d_AmbientLight_swigregister
Handle_V3d_AmbientLight_swigregister(Handle_V3d_AmbientLight)

def Handle_V3d_AmbientLight_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_AmbientLight const":
    return _V3d.Handle_V3d_AmbientLight_DownCast(AnObject)
Handle_V3d_AmbientLight_DownCast = _V3d.Handle_V3d_AmbientLight_DownCast

class V3d_PositionLight(V3d_Light):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetPosition(self, *args) -> "void":
        """
        * Defines the position of the light source. Should be redefined!

        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :rtype: void

        """
        return _V3d.V3d_PositionLight_SetPosition(self, *args)


    def SetTarget(self, *args) -> "void":
        """
        * Defines the target of the light (the center of the sphere)

        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :rtype: None

        """
        return _V3d.V3d_PositionLight_SetTarget(self, *args)


    def SetRadius(self, *args) -> "void":
        """
        * Define the radius.

        :param Radius:
        :type Radius: Quantity_Parameter
        :rtype: None

        """
        return _V3d.V3d_PositionLight_SetRadius(self, *args)


    def OnHideFace(self, *args) -> "void":
        """
        * Calculate the position of the light, on the hide face of the picking sphere.

        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        return _V3d.V3d_PositionLight_OnHideFace(self, *args)


    def OnSeeFace(self, *args) -> "void":
        """
        * Calculate the position of the light, on the seen face of the picking sphere.

        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: None

        """
        return _V3d.V3d_PositionLight_OnSeeFace(self, *args)


    def Tracking(self, *args) -> "void":
        """
        * Tracking the light position, or the light space, or the radius of the light space, that depends of initial picking 'WhatPick' (see the pick method). If WhatPick is SPACELIGHT, then the parameters Xpix, Ypix are the coordinates of a translation vector.

        :param aView:
        :type aView: Handle_V3d_View &
        :param WathPick:
        :type WathPick: V3d_TypeOfPickLight
        :param Xpix:
        :type Xpix: int
        :param Ypix:
        :type Ypix: int
        :rtype: None

        """
        return _V3d.V3d_PositionLight_Tracking(self, *args)


    def Display(self, *args) -> "void":
        """
        * Display the graphic structure of light source in the choosen view. We have three type of representation - SIMPLE : Only the light source is displayed. - PARTIAL : The light source and the light space are displayed. - COMPLETE : The light source, the light space and the radius of light space are displayed. We can choose the 'SAMELAST' as parameter of representation In this case the graphic structure representation will be the last displayed.

        :param aView:
        :type aView: Handle_V3d_View &
        :param Representation: default value is V3d_SIMPLE
        :type Representation: V3d_TypeOfRepresentation
        :rtype: void

        """
        return _V3d.V3d_PositionLight_Display(self, *args)


    def Erase(self, *args) -> "void":
        """
        * Erase the graphic structure of light source.

        :rtype: None

        """
        return _V3d.V3d_PositionLight_Erase(self, *args)


    def Radius(self, *args) -> "Quantity_Parameter":
        """
        * Returns the radius of the picking sphere.

        :rtype: Quantity_Parameter

        """
        return _V3d.V3d_PositionLight_Radius(self, *args)


    def SeeOrHide(self, *args) -> "Standard_Boolean":
        """
        * Returns the visibility status If True the source is visible. If False it's hidden.

        :param aView:
        :type aView: Handle_V3d_View &
        :rtype: bool

        """
        return _V3d.V3d_PositionLight_SeeOrHide(self, *args)


    def Position(self, *args) -> "void":
        """
        * Returns the position of the light source.

        :param X:
        :type X: V3d_Coordinate &
        :param Y:
        :type Y: V3d_Coordinate &
        :param Z:
        :type Z: V3d_Coordinate &
        :rtype: void

        """
        return _V3d.V3d_PositionLight_Position(self, *args)


    def Target(self, *args) -> "void":
        """
        * Returns the position of the target of the light source.

        :param X:
        :type X: V3d_Coordinate &
        :param Y:
        :type Y: V3d_Coordinate &
        :param Z:
        :type Z: V3d_Coordinate &
        :rtype: None

        """
        return _V3d.V3d_PositionLight_Target(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_PositionLight(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_PositionLight
V3d_PositionLight.SetPosition = new_instancemethod(_V3d.V3d_PositionLight_SetPosition, None, V3d_PositionLight)
V3d_PositionLight.SetTarget = new_instancemethod(_V3d.V3d_PositionLight_SetTarget, None, V3d_PositionLight)
V3d_PositionLight.SetRadius = new_instancemethod(_V3d.V3d_PositionLight_SetRadius, None, V3d_PositionLight)
V3d_PositionLight.OnHideFace = new_instancemethod(_V3d.V3d_PositionLight_OnHideFace, None, V3d_PositionLight)
V3d_PositionLight.OnSeeFace = new_instancemethod(_V3d.V3d_PositionLight_OnSeeFace, None, V3d_PositionLight)
V3d_PositionLight.Tracking = new_instancemethod(_V3d.V3d_PositionLight_Tracking, None, V3d_PositionLight)
V3d_PositionLight.Display = new_instancemethod(_V3d.V3d_PositionLight_Display, None, V3d_PositionLight)
V3d_PositionLight.Erase = new_instancemethod(_V3d.V3d_PositionLight_Erase, None, V3d_PositionLight)
V3d_PositionLight.Radius = new_instancemethod(_V3d.V3d_PositionLight_Radius, None, V3d_PositionLight)
V3d_PositionLight.SeeOrHide = new_instancemethod(_V3d.V3d_PositionLight_SeeOrHide, None, V3d_PositionLight)
V3d_PositionLight.Position = new_instancemethod(_V3d.V3d_PositionLight_Position, None, V3d_PositionLight)
V3d_PositionLight.Target = new_instancemethod(_V3d.V3d_PositionLight_Target, None, V3d_PositionLight)
V3d_PositionLight_swigregister = _V3d.V3d_PositionLight_swigregister
V3d_PositionLight_swigregister(V3d_PositionLight)

class Handle_V3d_PositionLight(Handle_V3d_Light):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_PositionLight_swiginit(self, _V3d.new_Handle_V3d_PositionLight(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_PositionLight_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_PositionLight
Handle_V3d_PositionLight.Nullify = new_instancemethod(_V3d.Handle_V3d_PositionLight_Nullify, None, Handle_V3d_PositionLight)
Handle_V3d_PositionLight.IsNull = new_instancemethod(_V3d.Handle_V3d_PositionLight_IsNull, None, Handle_V3d_PositionLight)
Handle_V3d_PositionLight._get_reference = new_instancemethod(_V3d.Handle_V3d_PositionLight__get_reference, None, Handle_V3d_PositionLight)
Handle_V3d_PositionLight_swigregister = _V3d.Handle_V3d_PositionLight_swigregister
Handle_V3d_PositionLight_swigregister(Handle_V3d_PositionLight)

def Handle_V3d_PositionLight_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_PositionLight const":
    return _V3d.Handle_V3d_PositionLight_DownCast(AnObject)
Handle_V3d_PositionLight_DownCast = _V3d.Handle_V3d_PositionLight_DownCast

class V3d_DirectionalLight(V3d_PositionLight):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a directional light source in the viewer.

        :param VM:
        :type VM: Handle_V3d_Viewer &
        :param Direction: default value is V3d_XposYposZpos
        :type Direction: V3d_TypeOfOrientation
        :param Color: default value is Quantity_NOC_WHITE
        :type Color: Quantity_NameOfColor
        :param Headlight: default value is Standard_False
        :type Headlight: bool
        :rtype: None

        * Creates a directional light source in the viewer. Xt,Yt,Zt : Coordinate of light source Target. Xp,Yp,Zp : Coordinate of light source Position. The others parameters describe before.

        :param VM:
        :type VM: Handle_V3d_Viewer &
        :param Xt:
        :type Xt: V3d_Coordinate
        :param Yt:
        :type Yt: V3d_Coordinate
        :param Zt:
        :type Zt: V3d_Coordinate
        :param Xp:
        :type Xp: V3d_Coordinate
        :param Yp:
        :type Yp: V3d_Coordinate
        :param Zp:
        :type Zp: V3d_Coordinate
        :param Color: default value is Quantity_NOC_WHITE
        :type Color: Quantity_NameOfColor
        :param Headlight: default value is Standard_False
        :type Headlight: bool
        :rtype: None

        """
        _V3d.V3d_DirectionalLight_swiginit(self, _V3d.new_V3d_DirectionalLight(*args))

    def SetDirection(self, *args) -> "void":
        """
        * Defines the direction of the light source by a predefined orientation.

        :param Direction:
        :type Direction: V3d_TypeOfOrientation
        :rtype: None

        * Defines the direction of the light source by the predefined vector Xm,Ym,Zm. Warning: raises BadValue from V3d if the vector is null.

        :param Xm:
        :type Xm: Quantity_Parameter
        :param Ym:
        :type Ym: Quantity_Parameter
        :param Zm:
        :type Zm: Quantity_Parameter
        :rtype: None

        """
        return _V3d.V3d_DirectionalLight_SetDirection(self, *args)


    def SetDisplayPosition(self, *args) -> "void":
        """
        * Defines the point of light source representation.

        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :rtype: None

        """
        return _V3d.V3d_DirectionalLight_SetDisplayPosition(self, *args)


    def DisplayPosition(self, *args) -> "void":
        """
        * Returns the choosen position to represent the light source.

        :param X:
        :type X: V3d_Coordinate &
        :param Y:
        :type Y: V3d_Coordinate &
        :param Z:
        :type Z: V3d_Coordinate &
        :rtype: None

        """
        return _V3d.V3d_DirectionalLight_DisplayPosition(self, *args)


    def Direction(self, *args) -> "void":
        """
        * Returns the Vx,Vy,Vz direction of the light source.

        :param Vx:
        :type Vx: Quantity_Parameter &
        :param Vy:
        :type Vy: Quantity_Parameter &
        :param Vz:
        :type Vz: Quantity_Parameter &
        :rtype: None

        """
        return _V3d.V3d_DirectionalLight_Direction(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_DirectionalLight(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_DirectionalLight
V3d_DirectionalLight.SetDirection = new_instancemethod(_V3d.V3d_DirectionalLight_SetDirection, None, V3d_DirectionalLight)
V3d_DirectionalLight.SetDisplayPosition = new_instancemethod(_V3d.V3d_DirectionalLight_SetDisplayPosition, None, V3d_DirectionalLight)
V3d_DirectionalLight.DisplayPosition = new_instancemethod(_V3d.V3d_DirectionalLight_DisplayPosition, None, V3d_DirectionalLight)
V3d_DirectionalLight.Direction = new_instancemethod(_V3d.V3d_DirectionalLight_Direction, None, V3d_DirectionalLight)
V3d_DirectionalLight_swigregister = _V3d.V3d_DirectionalLight_swigregister
V3d_DirectionalLight_swigregister(V3d_DirectionalLight)

class Handle_V3d_DirectionalLight(Handle_V3d_PositionLight):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_DirectionalLight_swiginit(self, _V3d.new_Handle_V3d_DirectionalLight(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_DirectionalLight_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_DirectionalLight
Handle_V3d_DirectionalLight.Nullify = new_instancemethod(_V3d.Handle_V3d_DirectionalLight_Nullify, None, Handle_V3d_DirectionalLight)
Handle_V3d_DirectionalLight.IsNull = new_instancemethod(_V3d.Handle_V3d_DirectionalLight_IsNull, None, Handle_V3d_DirectionalLight)
Handle_V3d_DirectionalLight._get_reference = new_instancemethod(_V3d.Handle_V3d_DirectionalLight__get_reference, None, Handle_V3d_DirectionalLight)
Handle_V3d_DirectionalLight_swigregister = _V3d.Handle_V3d_DirectionalLight_swigregister
Handle_V3d_DirectionalLight_swigregister(Handle_V3d_DirectionalLight)

def Handle_V3d_DirectionalLight_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_DirectionalLight const":
    return _V3d.Handle_V3d_DirectionalLight_DownCast(AnObject)
Handle_V3d_DirectionalLight_DownCast = _V3d.Handle_V3d_DirectionalLight_DownCast

class V3d_PositionalLight(V3d_PositionLight):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates an isolated light source X,Y,Z in the viewer. It is also defined by the color Color and two attenuation factors Attenuation1, Attenuation2. The resulting attenuation factor determining the illumination of a surface depends on the following formula : F = 1/(A1 + A2*Length) A1,A2 being the two factors of attenuation Length is the distance of the isolated source from the surface. Warning! raises BadValue from V3d if one of the attenuation coefficients is not between 0 et 1.

        :param VM:
        :type VM: Handle_V3d_Viewer &
        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :param Color: default value is Quantity_NOC_WHITE
        :type Color: Quantity_NameOfColor
        :param Attenuation1: default value is 1.0
        :type Attenuation1: Quantity_Coefficient
        :param Attenuation2: default value is 0.0
        :type Attenuation2: Quantity_Coefficient
        :rtype: None

        * Creates a light source of the Positional type in the viewer. Xt,Yt,Zt : Coordinate of Target light source. Xp,Yp,Zp : Coordinate of Position light source. The light source is also defined by the color Color and two attenuation factors Attenuation1, Attenuation2 that determine the illumination of a surface using the following formula : F = 1/(A1 + A2*Length) where: - A1,A2 are the two attenuation factors, and - Length is the distance from the isolated source. Warning! raises BadValue from V3d if one of the attenuation coefficients is not between 0 et 1.

        :param VM:
        :type VM: Handle_V3d_Viewer &
        :param Xt:
        :type Xt: V3d_Coordinate
        :param Yt:
        :type Yt: V3d_Coordinate
        :param Zt:
        :type Zt: V3d_Coordinate
        :param Xp:
        :type Xp: V3d_Coordinate
        :param Yp:
        :type Yp: V3d_Coordinate
        :param Zp:
        :type Zp: V3d_Coordinate
        :param Color: default value is Quantity_NOC_WHITE
        :type Color: Quantity_NameOfColor
        :param Attenuation1: default value is 1.0
        :type Attenuation1: Quantity_Coefficient
        :param Attenuation2: default value is 0.0
        :type Attenuation2: Quantity_Coefficient
        :rtype: None

        """
        _V3d.V3d_PositionalLight_swiginit(self, _V3d.new_V3d_PositionalLight(*args))

    def SetAttenuation(self, *args) -> "void":
        """
        * Defines the attenuation factors. Warning: raises BadValue from V3d if one of the attenuation coefficients is not between 0 et 1.

        :param A1:
        :type A1: Quantity_Coefficient
        :param A2:
        :type A2: Quantity_Coefficient
        :rtype: None

        """
        return _V3d.V3d_PositionalLight_SetAttenuation(self, *args)


    def Attenuation(self, *args) -> "void":
        """
        * Returns the attenuation factors A1,A2 of the light source used at construction time.

        :param A1:
        :type A1: Quantity_Coefficient &
        :param A2:
        :type A2: Quantity_Coefficient &
        :rtype: None

        """
        return _V3d.V3d_PositionalLight_Attenuation(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_PositionalLight(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_PositionalLight
V3d_PositionalLight.SetAttenuation = new_instancemethod(_V3d.V3d_PositionalLight_SetAttenuation, None, V3d_PositionalLight)
V3d_PositionalLight.Attenuation = new_instancemethod(_V3d.V3d_PositionalLight_Attenuation, None, V3d_PositionalLight)
V3d_PositionalLight_swigregister = _V3d.V3d_PositionalLight_swigregister
V3d_PositionalLight_swigregister(V3d_PositionalLight)

class Handle_V3d_PositionalLight(Handle_V3d_PositionLight):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_PositionalLight_swiginit(self, _V3d.new_Handle_V3d_PositionalLight(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_PositionalLight_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_PositionalLight
Handle_V3d_PositionalLight.Nullify = new_instancemethod(_V3d.Handle_V3d_PositionalLight_Nullify, None, Handle_V3d_PositionalLight)
Handle_V3d_PositionalLight.IsNull = new_instancemethod(_V3d.Handle_V3d_PositionalLight_IsNull, None, Handle_V3d_PositionalLight)
Handle_V3d_PositionalLight._get_reference = new_instancemethod(_V3d.Handle_V3d_PositionalLight__get_reference, None, Handle_V3d_PositionalLight)
Handle_V3d_PositionalLight_swigregister = _V3d.Handle_V3d_PositionalLight_swigregister
Handle_V3d_PositionalLight_swigregister(Handle_V3d_PositionalLight)

def Handle_V3d_PositionalLight_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_PositionalLight const":
    return _V3d.Handle_V3d_PositionalLight_DownCast(AnObject)
Handle_V3d_PositionalLight_DownCast = _V3d.Handle_V3d_PositionalLight_DownCast

class V3d_SpotLight(V3d_PositionLight):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a light source of the Spot type in the viewer. The attenuation factor F which determines the illumination of a surface depends on the following formula : F = 1/(A1 + A2*Length) A1,A2 being the 2 factors of attenuation Length is the distance from the source to the surface. The default values (1.0,0.0) correspond to a minimum of attenuation . The concentration factor determines the dispersion of the light on the surface, the default value (1.0) corresponds to a minimum of dispersion . Warning! raises BadValue from V3d - If one of the coefficients is not between 0 and 1 . If the lighting angle is <= 0 ou > PI .

        :param VM:
        :type VM: Handle_V3d_Viewer &
        :param X:
        :type X: V3d_Coordinate
        :param Y:
        :type Y: V3d_Coordinate
        :param Z:
        :type Z: V3d_Coordinate
        :param Direction: default value is V3d_XnegYnegZpos
        :type Direction: V3d_TypeOfOrientation
        :param Color: default value is Quantity_NOC_WHITE
        :type Color: Quantity_NameOfColor
        :param Attenuation1: default value is 1.0
        :type Attenuation1: Quantity_Coefficient
        :param Attenuation2: default value is 0.0
        :type Attenuation2: Quantity_Coefficient
        :param Concentration: default value is 1.0
        :type Concentration: Quantity_Coefficient
        :param Angle: default value is 0.523599
        :type Angle: Quantity_PlaneAngle
        :rtype: None

        * Creates a light source of the Spot type in the viewer. Xt,Yt,Zt : Coordinate of light source Target. Xp,Yp,Zp : Coordinate of light source Position. The others parameters describe before. Warning! raises BadValue from V3d - If one of the coefficients is not between 0 and 1 . If the lighting angle is <= 0 ou > PI .

        :param VM:
        :type VM: Handle_V3d_Viewer &
        :param Xt:
        :type Xt: V3d_Coordinate
        :param Yt:
        :type Yt: V3d_Coordinate
        :param Zt:
        :type Zt: V3d_Coordinate
        :param Xp:
        :type Xp: V3d_Coordinate
        :param Yp:
        :type Yp: V3d_Coordinate
        :param Zp:
        :type Zp: V3d_Coordinate
        :param Color: default value is Quantity_NOC_WHITE
        :type Color: Quantity_NameOfColor
        :param Attenuation1: default value is 1.0
        :type Attenuation1: Quantity_Coefficient
        :param Attenuation2: default value is 0.0
        :type Attenuation2: Quantity_Coefficient
        :param Concentration: default value is 1.0
        :type Concentration: Quantity_Coefficient
        :param Angle: default value is 0.523599
        :type Angle: Quantity_PlaneAngle
        :rtype: None

        """
        _V3d.V3d_SpotLight_swiginit(self, _V3d.new_V3d_SpotLight(*args))

    def SetDirection(self, *args) -> "void":
        """
        * Defines the direction of the light source. If the normal vector is NULL.

        :param Vx:
        :type Vx: Quantity_Parameter
        :param Vy:
        :type Vy: Quantity_Parameter
        :param Vz:
        :type Vz: Quantity_Parameter
        :rtype: None

        * Defines the direction of the light source according to a predefined directional vector.

        :param Orientation:
        :type Orientation: V3d_TypeOfOrientation
        :rtype: None

        """
        return _V3d.V3d_SpotLight_SetDirection(self, *args)


    def SetAttenuation(self, *args) -> "void":
        """
        * Defines the coefficients of attenuation. Warning! raises BadValue from V3d if one of the coefficient is <0 ou >1 .

        :param A1:
        :type A1: Quantity_Coefficient
        :param A2:
        :type A2: Quantity_Coefficient
        :rtype: None

        """
        return _V3d.V3d_SpotLight_SetAttenuation(self, *args)


    def SetConcentration(self, *args) -> "void":
        """
        * Defines the coefficient of concentration. if the coefficient is <0 ou >1 .

        :param C:
        :type C: Quantity_Coefficient
        :rtype: None

        """
        return _V3d.V3d_SpotLight_SetConcentration(self, *args)


    def SetAngle(self, *args) -> "void":
        """
        * Defines the spot angle in RADIANS. Warning: raises BadValue from from V3d If the angle is <= 0 ou > PI .

        :param Angle:
        :type Angle: Quantity_PlaneAngle
        :rtype: None

        """
        return _V3d.V3d_SpotLight_SetAngle(self, *args)


    def Direction(self, *args) -> "void":
        """
        * Returns the direction of the light source defined by Vx,Vy,Vz.

        :param Vx:
        :type Vx: Quantity_Parameter &
        :param Vy:
        :type Vy: Quantity_Parameter &
        :param Vz:
        :type Vz: Quantity_Parameter &
        :rtype: None

        """
        return _V3d.V3d_SpotLight_Direction(self, *args)


    def Attenuation(self, *args) -> "void":
        """
        * Returns the attenuation factors A1,A2 of the light source.

        :param A1:
        :type A1: Quantity_Coefficient &
        :param A2:
        :type A2: Quantity_Coefficient &
        :rtype: None

        """
        return _V3d.V3d_SpotLight_Attenuation(self, *args)


    def Concentration(self, *args) -> "Quantity_Coefficient":
        """
        :rtype: Quantity_Coefficient

        """
        return _V3d.V3d_SpotLight_Concentration(self, *args)


    def Angle(self, *args) -> "Quantity_PlaneAngle":
        """
        * Returns the spot angle.

        :rtype: Quantity_PlaneAngle

        """
        return _V3d.V3d_SpotLight_Angle(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_V3d_SpotLight(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _V3d.delete_V3d_SpotLight
V3d_SpotLight.SetDirection = new_instancemethod(_V3d.V3d_SpotLight_SetDirection, None, V3d_SpotLight)
V3d_SpotLight.SetAttenuation = new_instancemethod(_V3d.V3d_SpotLight_SetAttenuation, None, V3d_SpotLight)
V3d_SpotLight.SetConcentration = new_instancemethod(_V3d.V3d_SpotLight_SetConcentration, None, V3d_SpotLight)
V3d_SpotLight.SetAngle = new_instancemethod(_V3d.V3d_SpotLight_SetAngle, None, V3d_SpotLight)
V3d_SpotLight.Direction = new_instancemethod(_V3d.V3d_SpotLight_Direction, None, V3d_SpotLight)
V3d_SpotLight.Attenuation = new_instancemethod(_V3d.V3d_SpotLight_Attenuation, None, V3d_SpotLight)
V3d_SpotLight.Concentration = new_instancemethod(_V3d.V3d_SpotLight_Concentration, None, V3d_SpotLight)
V3d_SpotLight.Angle = new_instancemethod(_V3d.V3d_SpotLight_Angle, None, V3d_SpotLight)
V3d_SpotLight_swigregister = _V3d.V3d_SpotLight_swigregister
V3d_SpotLight_swigregister(V3d_SpotLight)

class Handle_V3d_SpotLight(Handle_V3d_PositionLight):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _V3d.Handle_V3d_SpotLight_swiginit(self, _V3d.new_Handle_V3d_SpotLight(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_V3d.Handle_V3d_SpotLight_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _V3d.delete_Handle_V3d_SpotLight
Handle_V3d_SpotLight.Nullify = new_instancemethod(_V3d.Handle_V3d_SpotLight_Nullify, None, Handle_V3d_SpotLight)
Handle_V3d_SpotLight.IsNull = new_instancemethod(_V3d.Handle_V3d_SpotLight_IsNull, None, Handle_V3d_SpotLight)
Handle_V3d_SpotLight._get_reference = new_instancemethod(_V3d.Handle_V3d_SpotLight__get_reference, None, Handle_V3d_SpotLight)
Handle_V3d_SpotLight_swigregister = _V3d.Handle_V3d_SpotLight_swigregister
Handle_V3d_SpotLight_swigregister(Handle_V3d_SpotLight)

def Handle_V3d_SpotLight_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_V3d_SpotLight const":
    return _V3d.Handle_V3d_SpotLight_DownCast(AnObject)
Handle_V3d_SpotLight_DownCast = _V3d.Handle_V3d_SpotLight_DownCast



