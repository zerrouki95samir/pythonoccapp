# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BRepMesh.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepMesh')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepMesh')
    _BRepMesh = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepMesh', [dirname(__file__)])
        except ImportError:
            import _BRepMesh
            return _BRepMesh
        try:
            _mod = imp.load_module('_BRepMesh', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepMesh = swig_import_helper()
    del swig_import_helper
else:
    import _BRepMesh
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepMesh.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BRepMesh.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BRepMesh.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BRepMesh.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BRepMesh.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BRepMesh.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BRepMesh.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BRepMesh.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BRepMesh.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BRepMesh.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BRepMesh.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BRepMesh.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BRepMesh.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BRepMesh.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BRepMesh.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BRepMesh.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BRepMesh.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BRepMesh.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.gp
import OCC.Standard
import OCC.NCollection
import OCC.TopAbs
import OCC.TColStd
import OCC.TCollection
import OCC.MMgt
import OCC.TopoDS
import OCC.TopLoc
import OCC.Poly
import OCC.TColgp
import OCC.TShort
import OCC.Bnd
import OCC.TopTools
import OCC.Message
import OCC.BRepAdaptor
import OCC.Adaptor3d
import OCC.GeomAbs
import OCC.Geom
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.math
import OCC.GeomAdaptor
import OCC.Geom2dAdaptor

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

BRepMesh_Free = _BRepMesh.BRepMesh_Free
BRepMesh_InVolume = _BRepMesh.BRepMesh_InVolume
BRepMesh_OnSurface = _BRepMesh.BRepMesh_OnSurface
BRepMesh_OnCurve = _BRepMesh.BRepMesh_OnCurve
BRepMesh_Fixed = _BRepMesh.BRepMesh_Fixed
BRepMesh_Frontier = _BRepMesh.BRepMesh_Frontier
BRepMesh_Deleted = _BRepMesh.BRepMesh_Deleted
BRepMesh_FE_NOERROR = _BRepMesh.BRepMesh_FE_NOERROR
BRepMesh_FE_LIBRARYNOTFOUND = _BRepMesh.BRepMesh_FE_LIBRARYNOTFOUND
BRepMesh_FE_FUNCTIONNOTFOUND = _BRepMesh.BRepMesh_FE_FUNCTIONNOTFOUND
BRepMesh_FE_CANNOTCREATEALGO = _BRepMesh.BRepMesh_FE_CANNOTCREATEALGO
BRepMesh_NoError = _BRepMesh.BRepMesh_NoError
BRepMesh_OpenWire = _BRepMesh.BRepMesh_OpenWire
BRepMesh_SelfIntersectingWire = _BRepMesh.BRepMesh_SelfIntersectingWire
BRepMesh_Failure = _BRepMesh.BRepMesh_Failure
BRepMesh_ReMesh = _BRepMesh.BRepMesh_ReMesh
class BRepMesh_Circle(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Default constructor.

        :rtype: None

        * Constructor. @param theLocation location of a circle. @param theRadius radius of a circle.

        :param theLocation:
        :type theLocation: gp_XY
        :param theRadius:
        :type theRadius: float
        :rtype: None

        """
        _BRepMesh.BRepMesh_Circle_swiginit(self, _BRepMesh.new_BRepMesh_Circle(*args))

    def SetLocation(self, *args) -> "void":
        """
        * Sets location of a circle. @param theLocation location of a circle.

        :param theLocation:
        :type theLocation: gp_XY
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_Circle_SetLocation(self, *args)


    def SetRadius(self, *args) -> "void":
        """
        * Sets radius of a circle. @param theRadius radius of a circle.

        :param theRadius:
        :type theRadius: float
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_Circle_SetRadius(self, *args)


    def Location(self, *args) -> "gp_XY const":
        """
        * Returns location of a circle.

        :rtype: inline  gp_XY

        """
        return _BRepMesh.BRepMesh_Circle_Location(self, *args)


    def Radius(self, *args) -> "Standard_Real const &":
        """
        * Returns radius of a circle.

        :rtype: inline  float

        """
        return _BRepMesh.BRepMesh_Circle_Radius(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Circle
BRepMesh_Circle.SetLocation = new_instancemethod(_BRepMesh.BRepMesh_Circle_SetLocation, None, BRepMesh_Circle)
BRepMesh_Circle.SetRadius = new_instancemethod(_BRepMesh.BRepMesh_Circle_SetRadius, None, BRepMesh_Circle)
BRepMesh_Circle.Location = new_instancemethod(_BRepMesh.BRepMesh_Circle_Location, None, BRepMesh_Circle)
BRepMesh_Circle.Radius = new_instancemethod(_BRepMesh.BRepMesh_Circle_Radius, None, BRepMesh_Circle)
BRepMesh_Circle_swigregister = _BRepMesh.BRepMesh_Circle_swigregister
BRepMesh_Circle_swigregister(BRepMesh_Circle)

class BRepMesh_CircleInspector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. @param theTolerance tolerance to be used for identification of shot circles. @param theReservedSize size to be reserved for vector of circles. @param theAllocator memory allocator to be used by internal collections.

        :param theTolerance:
        :type theTolerance: float
        :param theReservedSize:
        :type theReservedSize: int
        :param theAllocator:
        :type theAllocator: Handle_NCollection_IncAllocator &
        :rtype: None

        """
        _BRepMesh.BRepMesh_CircleInspector_swiginit(self, _BRepMesh.new_BRepMesh_CircleInspector(*args))

    def Bind(self, *args) -> "void":
        """
        * Adds the circle to vector of circles at the given position. @param theIndex position of circle in the vector. @param theCircle circle to be added.

        :param theIndex:
        :type theIndex: int
        :param theCircle:
        :type theCircle: BRepMesh_Circle &
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_CircleInspector_Bind(self, *args)


    def Circles(self, *args) -> "BRepMesh::VectorOfCircle const &":
        """
        * Resutns vector of registered circles.

        :rtype: inline  BRepMesh::VectorOfCircle

        """
        return _BRepMesh.BRepMesh_CircleInspector_Circles(self, *args)


    def Circle(self, *args) -> "BRepMesh_Circle &":
        """
        * Returns circle with the given index. @param theIndex index of circle. returns circle with the given index.

        :param theIndex:
        :type theIndex: int
        :rtype: inline BRepMesh_Circle

        """
        return _BRepMesh.BRepMesh_CircleInspector_Circle(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        * Set reference point to be checked. @param thePoint bullet point.

        :param thePoint:
        :type thePoint: gp_XY
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_CircleInspector_SetPoint(self, *args)


    def GetShotCircles(self, *args) -> "BRepMesh::ListOfInteger &":
        """
        * Returns list of circles shot by the reference point.

        :rtype: inline BRepMesh::ListOfInteger

        """
        return _BRepMesh.BRepMesh_CircleInspector_GetShotCircles(self, *args)


    def Inspect(self, *args) -> "NCollection_CellFilter_Action":
        """
        * Performs inspection of a circle with the given index. @param theTargetIndex index of a circle to be checked. returns status of the check.

        :param theTargetIndex:
        :type theTargetIndex: int
        :rtype: NCollection_CellFilter_Action

        """
        return _BRepMesh.BRepMesh_CircleInspector_Inspect(self, *args)


    def IsEqual(*args) -> "Standard_Boolean":
        """
        * Checks indices for equlity.

        :param theIndex:
        :type theIndex: int
        :param theTargetIndex:
        :type theTargetIndex: int
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_CircleInspector_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_CircleInspector
BRepMesh_CircleInspector.Bind = new_instancemethod(_BRepMesh.BRepMesh_CircleInspector_Bind, None, BRepMesh_CircleInspector)
BRepMesh_CircleInspector.Circles = new_instancemethod(_BRepMesh.BRepMesh_CircleInspector_Circles, None, BRepMesh_CircleInspector)
BRepMesh_CircleInspector.Circle = new_instancemethod(_BRepMesh.BRepMesh_CircleInspector_Circle, None, BRepMesh_CircleInspector)
BRepMesh_CircleInspector.SetPoint = new_instancemethod(_BRepMesh.BRepMesh_CircleInspector_SetPoint, None, BRepMesh_CircleInspector)
BRepMesh_CircleInspector.GetShotCircles = new_instancemethod(_BRepMesh.BRepMesh_CircleInspector_GetShotCircles, None, BRepMesh_CircleInspector)
BRepMesh_CircleInspector.Inspect = new_instancemethod(_BRepMesh.BRepMesh_CircleInspector_Inspect, None, BRepMesh_CircleInspector)
BRepMesh_CircleInspector_swigregister = _BRepMesh.BRepMesh_CircleInspector_swigregister
BRepMesh_CircleInspector_swigregister(BRepMesh_CircleInspector)

def BRepMesh_CircleInspector_IsEqual(*args) -> "Standard_Boolean":
    """
    * Checks indices for equlity.

    :param theIndex:
    :type theIndex: int
    :param theTargetIndex:
    :type theTargetIndex: int
    :rtype: bool

    """
    return _BRepMesh.BRepMesh_CircleInspector_IsEqual(*args)

class BRepMesh_CircleTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. @param theAllocator memory allocator to be used by internal structures.

        :param theAllocator:
        :type theAllocator: Handle_NCollection_IncAllocator &
        :rtype: None

        * Constructor. @param theReservedSize size to be reserved for vector of circles. @param theAllocator memory allocator to be used by internal structures.

        :param theReservedSize:
        :type theReservedSize: int
        :param theAllocator:
        :type theAllocator: Handle_NCollection_IncAllocator &
        :rtype: None

        """
        _BRepMesh.BRepMesh_CircleTool_swiginit(self, _BRepMesh.new_BRepMesh_CircleTool(*args))

    def Init(self, *args) -> "void":
        """
        * Initializes the tool. @param theReservedSize size to be reserved for vector of circles.

        :param Standard_Integer:
        :type Standard_Integer: 
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_CircleTool_Init(self, *args)


    def SetCellSize(self, *args) -> "void":
        """
        * Sets new size for cell filter. @param theSize cell size to be set for X and Y dimensions.

        :param theSize:
        :type theSize: float
        :rtype: inline void

        * Sets new size for cell filter. @param theSizeX cell size to be set for X dimension. @param theSizeY cell size to be set for Y dimension.

        :param theSizeX:
        :type theSizeX: float
        :param theSizeY:
        :type theSizeY: float
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_CircleTool_SetCellSize(self, *args)


    def SetMinMaxSize(self, *args) -> "void":
        """
        * Sets limits of inspection area. @param theMin bottom left corner of inspection area. @param theMax top right corner of inspection area.

        :param theMin:
        :type theMin: gp_XY
        :param theMax:
        :type theMax: gp_XY
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_CircleTool_SetMinMaxSize(self, *args)


    def Bind(self, *args) -> "Standard_Boolean":
        """
        * Binds the circle to the tool. @param theIndex index a circle should be bound with. @param theCircle circle to be bound.

        :param theIndex:
        :type theIndex: int
        :param theCircle:
        :type theCircle: gp_Circ2d
        :rtype: None

        * Computes circle on three points and bind it to the tool. @param theIndex index a circle should be bound with. @param thePoint1 first point. @param thePoint2 second point. @param thePoint3 third point. returns False in case of impossibility to build a circle on the given points, True elsewhere.

        :param theIndex:
        :type theIndex: int
        :param thePoint1:
        :type thePoint1: gp_XY
        :param thePoint2:
        :type thePoint2: gp_XY
        :param thePoint3:
        :type thePoint3: gp_XY
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_CircleTool_Bind(self, *args)


    def MocBind(self, *args) -> "void":
        """
        * Binds implicit zero circle. @param theIndex index a zero circle should be bound with.

        :param theIndex:
        :type theIndex: int
        :rtype: None

        """
        return _BRepMesh.BRepMesh_CircleTool_MocBind(self, *args)


    def Delete(self, *args) -> "void":
        """
        * Deletes a circle from the tool. @param theIndex index of a circle to be removed.

        :param theIndex:
        :type theIndex: int
        :rtype: None

        """
        return _BRepMesh.BRepMesh_CircleTool_Delete(self, *args)


    def Select(self, *args) -> "BRepMesh::ListOfInteger &":
        """
        * Select the circles shot by the given point. @param thePoint bullet point.

        :param thePoint:
        :type thePoint: gp_XY
        :rtype: BRepMesh::ListOfInteger

        """
        return _BRepMesh.BRepMesh_CircleTool_Select(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_CircleTool
BRepMesh_CircleTool.Init = new_instancemethod(_BRepMesh.BRepMesh_CircleTool_Init, None, BRepMesh_CircleTool)
BRepMesh_CircleTool.SetCellSize = new_instancemethod(_BRepMesh.BRepMesh_CircleTool_SetCellSize, None, BRepMesh_CircleTool)
BRepMesh_CircleTool.SetMinMaxSize = new_instancemethod(_BRepMesh.BRepMesh_CircleTool_SetMinMaxSize, None, BRepMesh_CircleTool)
BRepMesh_CircleTool.Bind = new_instancemethod(_BRepMesh.BRepMesh_CircleTool_Bind, None, BRepMesh_CircleTool)
BRepMesh_CircleTool.MocBind = new_instancemethod(_BRepMesh.BRepMesh_CircleTool_MocBind, None, BRepMesh_CircleTool)
BRepMesh_CircleTool.Delete = new_instancemethod(_BRepMesh.BRepMesh_CircleTool_Delete, None, BRepMesh_CircleTool)
BRepMesh_CircleTool.Select = new_instancemethod(_BRepMesh.BRepMesh_CircleTool_Select, None, BRepMesh_CircleTool)
BRepMesh_CircleTool_swigregister = _BRepMesh.BRepMesh_CircleTool_swigregister
BRepMesh_CircleTool_swigregister(BRepMesh_CircleTool)

class BRepMesh_Classifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor.

        :rtype: None

        """
        _BRepMesh.BRepMesh_Classifier_swiginit(self, _BRepMesh.new_BRepMesh_Classifier(*args))

    def Destroy(self, *args) -> "void":
        """
        * Method is called on destruction. Clears internal data structures.

        :rtype: None

        """
        return _BRepMesh.BRepMesh_Classifier_Destroy(self, *args)


    def Perform(self, *args) -> "TopAbs_State":
        """
        * Performs classification of the given point regarding to face internals. @param thePoint Point in parametric space to be classified. returns

        :param thePoint:
        :type thePoint: gp_Pnt2d
        :rtype: TopAbs_State

        """
        return _BRepMesh.BRepMesh_Classifier_Perform(self, *args)


    def RegisterWire(self, *args) -> "void":
        """
        * Registers wire specified by sequence of points for further classification of points. @param theWire Wire to be registered. Specified by sequence of points. @param theTolUV Tolerance to be used for calculations in parametric space. @param theUmin Lower U boundary of the face in parametric space. @param theUmax Upper U boundary of the face in parametric space. @param theVmin Lower V boundary of the face in parametric space. @param theVmax Upper V boundary of the face in parametric space.

        :param theWire:
        :type theWire: NCollection_Sequence<gp_Pnt2d>
        :param theTolUV:
        :type theTolUV: float
        :param theUmin:
        :type theUmin: float
        :param theUmax:
        :type theUmax: float
        :param theVmin:
        :type theVmin: float
        :param theVmax:
        :type theVmax: float
        :rtype: None

        """
        return _BRepMesh.BRepMesh_Classifier_RegisterWire(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Classifier
BRepMesh_Classifier.Destroy = new_instancemethod(_BRepMesh.BRepMesh_Classifier_Destroy, None, BRepMesh_Classifier)
BRepMesh_Classifier.Perform = new_instancemethod(_BRepMesh.BRepMesh_Classifier_Perform, None, BRepMesh_Classifier)
BRepMesh_Classifier.RegisterWire = new_instancemethod(_BRepMesh.BRepMesh_Classifier_RegisterWire, None, BRepMesh_Classifier)
BRepMesh_Classifier_swigregister = _BRepMesh.BRepMesh_Classifier_swigregister
BRepMesh_Classifier_swigregister(BRepMesh_Classifier)

class BRepMesh_DataStructureOfDelaun(OCC.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. @param theAllocator memory allocator to be used by internal structures. @param theReservedNodeSize presumed number of nodes in this mesh.

        :param theAllocator:
        :type theAllocator: Handle_NCollection_IncAllocator &
        :param theReservedNodeSize: default value is 100
        :type theReservedNodeSize: int
        :rtype: None

        """
        _BRepMesh.BRepMesh_DataStructureOfDelaun_swiginit(self, _BRepMesh.new_BRepMesh_DataStructureOfDelaun(*args))

    def NbNodes(self, *args) -> "Standard_Integer":
        """
        * @name API for accessing mesh nodes. Returns number of nodes.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_NbNodes(self, *args)


    def AddNode(self, *args) -> "Standard_Integer":
        """
        * Adds node to the mesh if it is not already in the mesh. @param theNode node to be added to the mesh. @param isForceAdd adds the given node to structure without checking on coincidence with other nodes. returns index of the node in the structure.

        :param theNode:
        :type theNode: BRepMesh_Vertex &
        :param isForceAdd: default value is Standard_False
        :type isForceAdd: bool
        :rtype: int

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_AddNode(self, *args)


    def GetNode(self, *args) -> "BRepMesh_Vertex const &":
        """
        * Get node by the index. @param theIndex index of a node. returns node with the given index.

        :param theIndex:
        :type theIndex: int
        :rtype: inline  BRepMesh_Vertex

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_GetNode(self, *args)


    def SubstituteNode(self, *args) -> "Standard_Boolean":
        """
        * Substitutes the node with the given index by new one. @param theIndex index of node to be substituted. @param theNewNode substituting node. returns False in case if new node is already in the structure, True elsewhere.

        :param theIndex:
        :type theIndex: int
        :param theNewNode:
        :type theNewNode: BRepMesh_Vertex &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_SubstituteNode(self, *args)


    def RemoveNode(self, *args) -> "void":
        """
        * Removes node from the mesh in case if it has no connected links and its type is Free. @param theIndex index of node to be removed. @param isForce if True node will be removed even if movability is not Free.

        :param theIndex:
        :type theIndex: int
        :param isForce: default value is Standard_False
        :type isForce: bool
        :rtype: None

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_RemoveNode(self, *args)


    def LinksConnectedTo(self, *args) -> "BRepMesh::ListOfInteger const &":
        """
        * Get list of links attached to the node with the given index. @param theIndex index of node whose links should be retrieved. returns list of links attached to the node.

        :param theIndex:
        :type theIndex: int
        :rtype: inline  BRepMesh::ListOfInteger

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_LinksConnectedTo(self, *args)


    def NbLinks(self, *args) -> "Standard_Integer":
        """
        * @name API for accessing mesh links. Returns number of links.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_NbLinks(self, *args)


    def AddLink(self, *args) -> "Standard_Integer":
        """
        * Adds link to the mesh if it is not already in the mesh. @param theLink link to be added to the mesh. returns index of the link in the structure.

        :param theLink:
        :type theLink: BRepMesh_Edge &
        :rtype: int

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_AddLink(self, *args)


    def GetLink(self, *args) -> "BRepMesh_Edge const &":
        """
        * Get link by the index. @param theIndex index of a link. returns link with the given index.

        :param theIndex:
        :type theIndex: int
        :rtype: BRepMesh_Edge

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_GetLink(self, *args)


    def LinksOfDomain(self, *args) -> "BRepMesh::MapOfInteger const &":
        """
        * Returns map of indices of links registered in mesh.

        :rtype: inline  BRepMesh::MapOfInteger

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_LinksOfDomain(self, *args)


    def SubstituteLink(self, *args) -> "Standard_Boolean":
        """
        * Substitutes the link with the given index by new one. @param theIndex index of link to be substituted. @param theNewLink substituting link. returns False in case if new link is already in the structure, True elsewhere.

        :param theIndex:
        :type theIndex: int
        :param theNewLink:
        :type theNewLink: BRepMesh_Edge &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_SubstituteLink(self, *args)


    def RemoveLink(self, *args) -> "void":
        """
        * Removes link from the mesh in case if it has no connected elements and its type is Free. @param theIndex index of link to be removed. @param isForce if True link will be removed even if movability is not Free.

        :param theIndex:
        :type theIndex: int
        :param isForce: default value is Standard_False
        :type isForce: bool
        :rtype: None

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_RemoveLink(self, *args)


    def ElementsConnectedTo(self, *args) -> "BRepMesh_PairOfIndex const &":
        """
        * Returns indices of elements conected to the link with the given index. @param theLinkIndex index of link whose data should be retrieved. returns indices of elements conected to the link.

        :param theLinkIndex:
        :type theLinkIndex: int
        :rtype: BRepMesh_PairOfIndex

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_ElementsConnectedTo(self, *args)


    def NbElements(self, *args) -> "Standard_Integer":
        """
        * @name API for accessing mesh elements. Returns number of links.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_NbElements(self, *args)


    def AddElement(self, *args) -> "Standard_Integer":
        """
        * Adds element to the mesh if it is not already in the mesh. @param theElement element to be added to the mesh. returns index of the element in the structure.

        :param theElement:
        :type theElement: BRepMesh_Triangle &
        :rtype: int

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_AddElement(self, *args)


    def IndexOf(self, *args) -> "Standard_Integer":
        """
        * Finds the index of the given node. @param theNode node to find. returns index of the given element of zero if node is not in the mesh.

        :param theNode:
        :type theNode: BRepMesh_Vertex &
        :rtype: int

        * Finds the index of the given link. @param theLink link to find. returns index of the given element of zero if link is not in the mesh.

        :param theLink:
        :type theLink: BRepMesh_Edge &
        :rtype: int

        * Finds the index of the given element. @param theElement element to find. returns index of the given element of zero if element is not in the mesh.

        :param theElement:
        :type theElement: BRepMesh_Triangle &
        :rtype: int

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_IndexOf(self, *args)


    def GetElement(self, *args) -> "BRepMesh_Triangle const &":
        """
        * Get element by the index. @param theIndex index of an element. returns element with the given index.

        :param theIndex:
        :type theIndex: int
        :rtype: BRepMesh_Triangle

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_GetElement(self, *args)


    def ElementsOfDomain(self, *args) -> "BRepMesh::MapOfInteger const &":
        """
        * Returns map of indices of elements registered in mesh.

        :rtype: inline  BRepMesh::MapOfInteger

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_ElementsOfDomain(self, *args)


    def SubstituteElement(self, *args) -> "Standard_Boolean":
        """
        * Substitutes the element with the given index by new one. @param theIndex index of element to be substituted. @param theNewLink substituting element. returns False in case if new element is already in the structure, True elsewhere.

        :param theIndex:
        :type theIndex: int
        :param theNewElement:
        :type theNewElement: BRepMesh_Triangle &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_SubstituteElement(self, *args)


    def RemoveElement(self, *args) -> "void":
        """
        * Removes element from the mesh. @param theIndex index of element to be removed.

        :param theIndex:
        :type theIndex: int
        :rtype: None

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_RemoveElement(self, *args)


    def ElementNodes(self, *args) -> "void":
        """
        * Returns indices of nodes forming the given element. @param theElement element which nodes should be retrieved. @param[out] theNodes nodes of the given element.

        :param theElement:
        :type theElement: BRepMesh_Triangle &
        :param :
        :type : int(&theNodes)
        :rtype: None

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_ElementNodes(self, *args)


    def StatisticsToString(self) -> "std::string":
        """StatisticsToString(BRepMesh_DataStructureOfDelaun self) -> std::string"""
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_StatisticsToString(self)


    def Allocator(self, *args) -> "Handle_NCollection_IncAllocator":
        """
        * Returns memory allocator used by the structure.

        :rtype: inline  Handle_NCollection_IncAllocator

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_Allocator(self, *args)


    def Data(self, *args) -> "BRepMesh::HVertexTool &":
        """
        * Gives the data structure for initialization of cell size and tolerance.

        :rtype: inline BRepMesh::HVertexTool

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_Data(self, *args)


    def ClearDomain(self, *args) -> "void":
        """
        * Removes all elements.

        :rtype: None

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_ClearDomain(self, *args)


    def ClearDeleted(self, *args) -> "void":
        """
        * Substitutes deleted items by the last one from corresponding map to have only non-deleted elements, links or nodes in the structure.

        :rtype: None

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_ClearDeleted(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepMesh_DataStructureOfDelaun(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_DataStructureOfDelaun
BRepMesh_DataStructureOfDelaun.NbNodes = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_NbNodes, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.AddNode = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_AddNode, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.GetNode = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_GetNode, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.SubstituteNode = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_SubstituteNode, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.RemoveNode = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_RemoveNode, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.LinksConnectedTo = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_LinksConnectedTo, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.NbLinks = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_NbLinks, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.AddLink = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_AddLink, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.GetLink = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_GetLink, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.LinksOfDomain = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_LinksOfDomain, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.SubstituteLink = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_SubstituteLink, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.RemoveLink = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_RemoveLink, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.ElementsConnectedTo = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_ElementsConnectedTo, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.NbElements = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_NbElements, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.AddElement = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_AddElement, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.IndexOf = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_IndexOf, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.GetElement = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_GetElement, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.ElementsOfDomain = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_ElementsOfDomain, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.SubstituteElement = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_SubstituteElement, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.RemoveElement = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_RemoveElement, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.ElementNodes = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_ElementNodes, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.StatisticsToString = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_StatisticsToString, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.Allocator = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_Allocator, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.Data = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_Data, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.ClearDomain = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_ClearDomain, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun.ClearDeleted = new_instancemethod(_BRepMesh.BRepMesh_DataStructureOfDelaun_ClearDeleted, None, BRepMesh_DataStructureOfDelaun)
BRepMesh_DataStructureOfDelaun_swigregister = _BRepMesh.BRepMesh_DataStructureOfDelaun_swigregister
BRepMesh_DataStructureOfDelaun_swigregister(BRepMesh_DataStructureOfDelaun)

class Handle_BRepMesh_DataStructureOfDelaun(OCC.Standard.Handle_Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_swiginit(self, _BRepMesh.new_Handle_BRepMesh_DataStructureOfDelaun(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_DataStructureOfDelaun
Handle_BRepMesh_DataStructureOfDelaun.Nullify = new_instancemethod(_BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_Nullify, None, Handle_BRepMesh_DataStructureOfDelaun)
Handle_BRepMesh_DataStructureOfDelaun.IsNull = new_instancemethod(_BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_IsNull, None, Handle_BRepMesh_DataStructureOfDelaun)
Handle_BRepMesh_DataStructureOfDelaun._get_reference = new_instancemethod(_BRepMesh.Handle_BRepMesh_DataStructureOfDelaun__get_reference, None, Handle_BRepMesh_DataStructureOfDelaun)
Handle_BRepMesh_DataStructureOfDelaun_swigregister = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_swigregister
Handle_BRepMesh_DataStructureOfDelaun_swigregister(Handle_BRepMesh_DataStructureOfDelaun)

def Handle_BRepMesh_DataStructureOfDelaun_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_BRepMesh_DataStructureOfDelaun const":
    return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_DownCast(AnObject)
Handle_BRepMesh_DataStructureOfDelaun_DownCast = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_DownCast

class BRepMesh_Delaun(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates the triangulation with an empty Mesh data structure.

        :param theVertices:
        :type theVertices: BRepMesh::Array1OfVertexOfDelaun &
        :rtype: None

        * Creates the triangulation with an existent Mesh data structure.

        :param theOldMesh:
        :type theOldMesh: Handle_BRepMesh_DataStructureOfDelaun &
        :param theVertices:
        :type theVertices: BRepMesh::Array1OfVertexOfDelaun &
        :rtype: None

        * Creates the triangulation with an existant Mesh data structure.

        :param theOldMesh:
        :type theOldMesh: Handle_BRepMesh_DataStructureOfDelaun &
        :param theVertexIndices:
        :type theVertexIndices: BRepMesh::Array1OfInteger &
        :rtype: None

        """
        _BRepMesh.BRepMesh_Delaun_swiginit(self, _BRepMesh.new_BRepMesh_Delaun(*args))

    def Init(self, *args) -> "void":
        """
        * Initializes the triangulation with an array of vertices.

        :param theVertices:
        :type theVertices: BRepMesh::Array1OfVertexOfDelaun &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_Delaun_Init(self, *args)


    def RemoveVertex(self, *args) -> "void":
        """
        * Removes a vertex from the triangulation.

        :param theVertex:
        :type theVertex: BRepMesh_Vertex &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_Delaun_RemoveVertex(self, *args)


    def AddVertices(self, *args) -> "void":
        """
        * Adds some vertices into the triangulation.

        :param theVertices:
        :type theVertices: BRepMesh::Array1OfVertexOfDelaun &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_Delaun_AddVertices(self, *args)


    def UseEdge(self, *args) -> "Standard_Boolean":
        """
        * Modify mesh to use the edge. returns True if done

        :param theEdge:
        :type theEdge: int
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_Delaun_UseEdge(self, *args)


    def Result(self, *args) -> "Handle_BRepMesh_DataStructureOfDelaun":
        """
        * Gives the Mesh data structure.

        :rtype: inline  Handle_BRepMesh_DataStructureOfDelaun

        """
        return _BRepMesh.BRepMesh_Delaun_Result(self, *args)


    def GetVertex(self, *args) -> "BRepMesh_Vertex const &":
        """
        * Gives vertex with the given index

        :param theIndex:
        :type theIndex: int
        :rtype: inline  BRepMesh_Vertex

        """
        return _BRepMesh.BRepMesh_Delaun_GetVertex(self, *args)


    def GetEdge(self, *args) -> "BRepMesh_Edge const &":
        """
        * Gives edge with the given index

        :param theIndex:
        :type theIndex: int
        :rtype: inline  BRepMesh_Edge

        """
        return _BRepMesh.BRepMesh_Delaun_GetEdge(self, *args)


    def GetTriangle(self, *args) -> "BRepMesh_Triangle const &":
        """
        * Gives triangle with the given index

        :param theIndex:
        :type theIndex: int
        :rtype: inline  BRepMesh_Triangle

        """
        return _BRepMesh.BRepMesh_Delaun_GetTriangle(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        * Test is the given triangle contains the given vertex. If theEdgeOn != 0 the vertex lies onto the edge index returned through this parameter.

        :param theTriangleId:
        :type theTriangleId: int
        :param theVertex:
        :type theVertex: BRepMesh_Vertex &
        :param theEdgeOn:
        :type theEdgeOn: int &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_Delaun_Contains(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Delaun
BRepMesh_Delaun.Init = new_instancemethod(_BRepMesh.BRepMesh_Delaun_Init, None, BRepMesh_Delaun)
BRepMesh_Delaun.RemoveVertex = new_instancemethod(_BRepMesh.BRepMesh_Delaun_RemoveVertex, None, BRepMesh_Delaun)
BRepMesh_Delaun.AddVertices = new_instancemethod(_BRepMesh.BRepMesh_Delaun_AddVertices, None, BRepMesh_Delaun)
BRepMesh_Delaun.UseEdge = new_instancemethod(_BRepMesh.BRepMesh_Delaun_UseEdge, None, BRepMesh_Delaun)
BRepMesh_Delaun.Result = new_instancemethod(_BRepMesh.BRepMesh_Delaun_Result, None, BRepMesh_Delaun)
BRepMesh_Delaun.GetVertex = new_instancemethod(_BRepMesh.BRepMesh_Delaun_GetVertex, None, BRepMesh_Delaun)
BRepMesh_Delaun.GetEdge = new_instancemethod(_BRepMesh.BRepMesh_Delaun_GetEdge, None, BRepMesh_Delaun)
BRepMesh_Delaun.GetTriangle = new_instancemethod(_BRepMesh.BRepMesh_Delaun_GetTriangle, None, BRepMesh_Delaun)
BRepMesh_Delaun.Contains = new_instancemethod(_BRepMesh.BRepMesh_Delaun_Contains, None, BRepMesh_Delaun)
BRepMesh_Delaun_swigregister = _BRepMesh.BRepMesh_Delaun_swigregister
BRepMesh_Delaun_swigregister(BRepMesh_Delaun)

class BRepMesh_DiscretFactory(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Get(*args) -> "BRepMesh_DiscretFactory &":
        """
        * Returns the global factory instance.

        :rtype: BRepMesh_DiscretFactory

        """
        return _BRepMesh.BRepMesh_DiscretFactory_Get(*args)

    Get = staticmethod(Get)

    def Names(self, *args) -> "TColStd_MapOfAsciiString const &":
        """
        * Returns the list of registered meshing algorithms.

        :rtype: inline  TColStd_MapOfAsciiString

        """
        return _BRepMesh.BRepMesh_DiscretFactory_Names(self, *args)


    def SetDefaultName(self, *args) -> "Standard_Boolean":
        """
        * Setup meshing algorithm by name. Returns True if requested tool is available. On fail Factory will continue to use previous algo.

        :param theName:
        :type theName: TCollection_AsciiString &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_DiscretFactory_SetDefaultName(self, *args)


    def DefaultName(self, *args) -> "TCollection_AsciiString const &":
        """
        * Returns name for current meshing algorithm.

        :rtype: inline  TCollection_AsciiString

        """
        return _BRepMesh.BRepMesh_DiscretFactory_DefaultName(self, *args)


    def SetFunctionName(self, *args) -> "Standard_Boolean":
        """
        * Advanced function. Changes function name to retrieve from plugin. Returns True if requested tool is available. On fail Factory will continue to use previous algo.

        :param theFuncName:
        :type theFuncName: TCollection_AsciiString &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_DiscretFactory_SetFunctionName(self, *args)


    def FunctionName(self, *args) -> "TCollection_AsciiString const &":
        """
        * Returns function name that should be exported by plugin.

        :rtype: inline  TCollection_AsciiString

        """
        return _BRepMesh.BRepMesh_DiscretFactory_FunctionName(self, *args)


    def ErrorStatus(self, *args) -> "BRepMesh_FactoryError":
        """
        * Returns error status for last meshing algorithm switch.

        :rtype: inline BRepMesh_FactoryError

        """
        return _BRepMesh.BRepMesh_DiscretFactory_ErrorStatus(self, *args)


    def SetDefault(self, *args) -> "Standard_Boolean":
        """
        * Setup meshing algorithm that should be created by this Factory. Returns True if requested tool is available. On fail Factory will continue to use previous algo. Call ::ErrorStatus() method to retrieve fault reason.

        :param theName:
        :type theName: TCollection_AsciiString &
        :param theFuncName: default value is 'DISCRETALGO'
        :type theFuncName: TCollection_AsciiString &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_DiscretFactory_SetDefault(self, *args)


    def Discret(self, *args) -> "Handle_BRepMesh_DiscretRoot":
        """
        * Returns triangulation algorithm instance. @param theShape shape to be meshed. @param theLinDeflection linear deflection to be used for meshing. @param theAngDeflection angular deflection to be used for meshing.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theLinDeflection:
        :type theLinDeflection: float
        :param theAngDeflection:
        :type theAngDeflection: float
        :rtype: Handle_BRepMesh_DiscretRoot

        """
        return _BRepMesh.BRepMesh_DiscretFactory_Discret(self, *args)


    __repr__ = _dumps_object

BRepMesh_DiscretFactory.Names = new_instancemethod(_BRepMesh.BRepMesh_DiscretFactory_Names, None, BRepMesh_DiscretFactory)
BRepMesh_DiscretFactory.SetDefaultName = new_instancemethod(_BRepMesh.BRepMesh_DiscretFactory_SetDefaultName, None, BRepMesh_DiscretFactory)
BRepMesh_DiscretFactory.DefaultName = new_instancemethod(_BRepMesh.BRepMesh_DiscretFactory_DefaultName, None, BRepMesh_DiscretFactory)
BRepMesh_DiscretFactory.SetFunctionName = new_instancemethod(_BRepMesh.BRepMesh_DiscretFactory_SetFunctionName, None, BRepMesh_DiscretFactory)
BRepMesh_DiscretFactory.FunctionName = new_instancemethod(_BRepMesh.BRepMesh_DiscretFactory_FunctionName, None, BRepMesh_DiscretFactory)
BRepMesh_DiscretFactory.ErrorStatus = new_instancemethod(_BRepMesh.BRepMesh_DiscretFactory_ErrorStatus, None, BRepMesh_DiscretFactory)
BRepMesh_DiscretFactory.SetDefault = new_instancemethod(_BRepMesh.BRepMesh_DiscretFactory_SetDefault, None, BRepMesh_DiscretFactory)
BRepMesh_DiscretFactory.Discret = new_instancemethod(_BRepMesh.BRepMesh_DiscretFactory_Discret, None, BRepMesh_DiscretFactory)
BRepMesh_DiscretFactory_swigregister = _BRepMesh.BRepMesh_DiscretFactory_swigregister
BRepMesh_DiscretFactory_swigregister(BRepMesh_DiscretFactory)

def BRepMesh_DiscretFactory_Get(*args) -> "BRepMesh_DiscretFactory &":
    """
    * Returns the global factory instance.

    :rtype: BRepMesh_DiscretFactory

    """
    return _BRepMesh.BRepMesh_DiscretFactory_Get(*args)

class BRepMesh_DiscretRoot(OCC.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetDeflection(self, *args) -> "void":
        """
        * Setup linear deflection.

        :param theDeflection:
        :type theDeflection: float
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_DiscretRoot_SetDeflection(self, *args)


    def Deflection(self, *args) -> "Standard_Real":
        """
        * Returns linear deflection.

        :rtype: inline float

        """
        return _BRepMesh.BRepMesh_DiscretRoot_Deflection(self, *args)


    def SetAngle(self, *args) -> "void":
        """
        * Setup angular deflection.

        :param theAngle:
        :type theAngle: float
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_DiscretRoot_SetAngle(self, *args)


    def Angle(self, *args) -> "Standard_Real":
        """
        * Returns angular deflection.

        :rtype: inline float

        """
        return _BRepMesh.BRepMesh_DiscretRoot_Angle(self, *args)


    def SetShape(self, *args) -> "void":
        """
        * Set the shape to triangulate.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_DiscretRoot_SetShape(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape const":
        """
        :rtype: inline  TopoDS_Shape

        """
        return _BRepMesh.BRepMesh_DiscretRoot_Shape(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if triangualtion was performed and has success.

        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_DiscretRoot_IsDone(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Compute triangulation for set shape.

        :rtype: void

        """
        return _BRepMesh.BRepMesh_DiscretRoot_Perform(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepMesh_DiscretRoot(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_DiscretRoot
BRepMesh_DiscretRoot.SetDeflection = new_instancemethod(_BRepMesh.BRepMesh_DiscretRoot_SetDeflection, None, BRepMesh_DiscretRoot)
BRepMesh_DiscretRoot.Deflection = new_instancemethod(_BRepMesh.BRepMesh_DiscretRoot_Deflection, None, BRepMesh_DiscretRoot)
BRepMesh_DiscretRoot.SetAngle = new_instancemethod(_BRepMesh.BRepMesh_DiscretRoot_SetAngle, None, BRepMesh_DiscretRoot)
BRepMesh_DiscretRoot.Angle = new_instancemethod(_BRepMesh.BRepMesh_DiscretRoot_Angle, None, BRepMesh_DiscretRoot)
BRepMesh_DiscretRoot.SetShape = new_instancemethod(_BRepMesh.BRepMesh_DiscretRoot_SetShape, None, BRepMesh_DiscretRoot)
BRepMesh_DiscretRoot.Shape = new_instancemethod(_BRepMesh.BRepMesh_DiscretRoot_Shape, None, BRepMesh_DiscretRoot)
BRepMesh_DiscretRoot.IsDone = new_instancemethod(_BRepMesh.BRepMesh_DiscretRoot_IsDone, None, BRepMesh_DiscretRoot)
BRepMesh_DiscretRoot.Perform = new_instancemethod(_BRepMesh.BRepMesh_DiscretRoot_Perform, None, BRepMesh_DiscretRoot)
BRepMesh_DiscretRoot_swigregister = _BRepMesh.BRepMesh_DiscretRoot_swigregister
BRepMesh_DiscretRoot_swigregister(BRepMesh_DiscretRoot)

class Handle_BRepMesh_DiscretRoot(OCC.Standard.Handle_Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _BRepMesh.Handle_BRepMesh_DiscretRoot_swiginit(self, _BRepMesh.new_Handle_BRepMesh_DiscretRoot(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_DiscretRoot_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_DiscretRoot
Handle_BRepMesh_DiscretRoot.Nullify = new_instancemethod(_BRepMesh.Handle_BRepMesh_DiscretRoot_Nullify, None, Handle_BRepMesh_DiscretRoot)
Handle_BRepMesh_DiscretRoot.IsNull = new_instancemethod(_BRepMesh.Handle_BRepMesh_DiscretRoot_IsNull, None, Handle_BRepMesh_DiscretRoot)
Handle_BRepMesh_DiscretRoot._get_reference = new_instancemethod(_BRepMesh.Handle_BRepMesh_DiscretRoot__get_reference, None, Handle_BRepMesh_DiscretRoot)
Handle_BRepMesh_DiscretRoot_swigregister = _BRepMesh.Handle_BRepMesh_DiscretRoot_swigregister
Handle_BRepMesh_DiscretRoot_swigregister(Handle_BRepMesh_DiscretRoot)

def Handle_BRepMesh_DiscretRoot_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_BRepMesh_DiscretRoot const":
    return _BRepMesh.Handle_BRepMesh_DiscretRoot_DownCast(AnObject)
Handle_BRepMesh_DiscretRoot_DownCast = _BRepMesh.Handle_BRepMesh_DiscretRoot_DownCast

class BRepMesh_EdgeChecker(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor @param theFaceTri Poly triangulation of face the edges relie to. @param theFaceLoc Face location to be used to extract polygon on triangulation. @param theMutex Upper level shared mutex to protect isFailed flag from concurrent write access. @param isFailed Upper level shared flag indicating that polygon on triangulation of checked edge is not consistent. If this flag is set to True, other tasks will not check details of their data.

        :param theFaceTri:
        :type theFaceTri: Handle_Poly_Triangulation &
        :param theFaceLoc:
        :type theFaceLoc: TopLoc_Location &
        :param theMutex:
        :type theMutex: Standard_Mutex &
        :param isFailed:
        :type isFailed: bool
        :rtype: None

        """
        _BRepMesh.BRepMesh_EdgeChecker_swiginit(self, _BRepMesh.new_BRepMesh_EdgeChecker(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_EdgeChecker
BRepMesh_EdgeChecker_swigregister = _BRepMesh.BRepMesh_EdgeChecker_swigregister
BRepMesh_EdgeChecker_swigregister(BRepMesh_EdgeChecker)

class BRepMesh_FaceChecker(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor @param isInParallel Flag indicates that face edges should be checked in parallel.

        :param isInParallel:
        :type isInParallel: bool
        :rtype: None

        """
        _BRepMesh.BRepMesh_FaceChecker_swiginit(self, _BRepMesh.new_BRepMesh_FaceChecker(*args))

    def IsValid(self, *args) -> "Standard_Boolean":
        """
        * Returns status of the check.

        :rtype: bool

        """
        return _BRepMesh.BRepMesh_FaceChecker_IsValid(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_FaceChecker
BRepMesh_FaceChecker.IsValid = new_instancemethod(_BRepMesh.BRepMesh_FaceChecker_IsValid, None, BRepMesh_FaceChecker)
BRepMesh_FaceChecker_swigregister = _BRepMesh.BRepMesh_FaceChecker_swigregister
BRepMesh_FaceChecker_swigregister(BRepMesh_FaceChecker)

class BRepMesh_FastDiscret(OCC.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param defle:
        :type defle: float
        :param angle:
        :type angle: float
        :param B:
        :type B: Bnd_Box &
        :param withShare: default value is Standard_True
        :type withShare: bool
        :param inshape: default value is Standard_False
        :type inshape: bool
        :param relative: default value is Standard_False
        :type relative: bool
        :param shapetrigu: default value is Standard_False
        :type shapetrigu: bool
        :param isInParallel: default value is Standard_False
        :type isInParallel: bool
        :rtype: None

        * if the boolean <relative> is True, the deflection used for the polygonalisation of each edge will be <defle> * Size of Edge. the deflection used for the faces will be the maximum deflection of their edges. if <shapetrigu> is True, the triangulation, if exists with a correct deflection, can be used to re-triangulate the shape. if <inshape> is True, the calculated triangulation will be stored in the shape.

        :param shape:
        :type shape: TopoDS_Shape &
        :param defle:
        :type defle: float
        :param angle:
        :type angle: float
        :param B:
        :type B: Bnd_Box &
        :param withShare: default value is Standard_True
        :type withShare: bool
        :param inshape: default value is Standard_False
        :type inshape: bool
        :param relative: default value is Standard_False
        :type relative: bool
        :param shapetrigu: default value is Standard_False
        :type shapetrigu: bool
        :param isInParallel: default value is Standard_False
        :type isInParallel: bool
        :rtype: None

        """
        _BRepMesh.BRepMesh_FastDiscret_swiginit(self, _BRepMesh.new_BRepMesh_FastDiscret(*args))

    def Perform(self, *args) -> "void":
        """
        * Build triangulation on the whole shape.

        :param shape:
        :type shape: TopoDS_Shape &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_FastDiscret_Perform(self, *args)


    def Add(self, *args) -> "Standard_Integer":
        """
        * Record a face for further processing. returns status flags collected during discretization of boundaries of the given face.

        :param face:
        :type face: TopoDS_Face &
        :rtype: int

        """
        return _BRepMesh.BRepMesh_FastDiscret_Add(self, *args)


    def Process(self, *args) -> "void":
        """
        * Triangulate a face previously recorded for processing by call to Add(). Can be executed in parallel threads.

        :param face:
        :type face: TopoDS_Face &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_FastDiscret_Process(self, *args)


    def SetParallel(self, *args) -> "void":
        """
        * Request algorithm to launch in multiple threads to improve performance (should be supported by plugin).

        :param theInParallel:
        :type theInParallel: bool
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_FastDiscret_SetParallel(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * Returns the multi-threading usage flag.

        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_FastDiscret_IsParallel(self, *args)


    def GetDeflection(self, *args) -> "Standard_Real":
        """
        * returns the deflection value.

        :rtype: inline float

        """
        return _BRepMesh.BRepMesh_FastDiscret_GetDeflection(self, *args)


    def GetAngle(self, *args) -> "Standard_Real":
        """
        * returns the deflection value.

        :rtype: inline float

        """
        return _BRepMesh.BRepMesh_FastDiscret_GetAngle(self, *args)


    def WithShare(self, *args) -> "Standard_Boolean":
        """
        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_FastDiscret_WithShare(self, *args)


    def InShape(self, *args) -> "Standard_Boolean":
        """
        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_FastDiscret_InShape(self, *args)


    def ShapeTrigu(self, *args) -> "Standard_Boolean":
        """
        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_FastDiscret_ShapeTrigu(self, *args)


    def InitSharedFaces(self, *args) -> "void":
        """
        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_FastDiscret_InitSharedFaces(self, *args)


    def SharedFaces(self, *args) -> "TopTools_IndexedDataMapOfShapeListOfShape const &":
        """
        :rtype: inline  TopTools_IndexedDataMapOfShapeListOfShape

        """
        return _BRepMesh.BRepMesh_FastDiscret_SharedFaces(self, *args)


    def GetFaceAttribute(self, *args) -> "Standard_Boolean":
        """
        * Gives face attribute.

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theAttribute:
        :type theAttribute: Handle_BRepMesh_FaceAttribute &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_FastDiscret_GetFaceAttribute(self, *args)


    def RemoveFaceAttribute(self, *args) -> "void":
        """
        * Remove face attribute as useless to free locate memory.

        :param theFace:
        :type theFace: TopoDS_Face &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_FastDiscret_RemoveFaceAttribute(self, *args)


    def NbBoundaryPoints(self, *args) -> "Standard_Integer":
        """
        * Returns number of boundary 3d points.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_FastDiscret_NbBoundaryPoints(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepMesh_FastDiscret(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_FastDiscret
BRepMesh_FastDiscret.Perform = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_Perform, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.Add = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_Add, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.Process = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_Process, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.SetParallel = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_SetParallel, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.IsParallel = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_IsParallel, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.GetDeflection = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_GetDeflection, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.GetAngle = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_GetAngle, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.WithShare = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_WithShare, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.InShape = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_InShape, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.ShapeTrigu = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_ShapeTrigu, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.InitSharedFaces = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_InitSharedFaces, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.SharedFaces = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_SharedFaces, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.GetFaceAttribute = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_GetFaceAttribute, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.RemoveFaceAttribute = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_RemoveFaceAttribute, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret.NbBoundaryPoints = new_instancemethod(_BRepMesh.BRepMesh_FastDiscret_NbBoundaryPoints, None, BRepMesh_FastDiscret)
BRepMesh_FastDiscret_swigregister = _BRepMesh.BRepMesh_FastDiscret_swigregister
BRepMesh_FastDiscret_swigregister(BRepMesh_FastDiscret)

class Handle_BRepMesh_FastDiscret(OCC.Standard.Handle_Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _BRepMesh.Handle_BRepMesh_FastDiscret_swiginit(self, _BRepMesh.new_Handle_BRepMesh_FastDiscret(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_FastDiscret_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_FastDiscret
Handle_BRepMesh_FastDiscret.Nullify = new_instancemethod(_BRepMesh.Handle_BRepMesh_FastDiscret_Nullify, None, Handle_BRepMesh_FastDiscret)
Handle_BRepMesh_FastDiscret.IsNull = new_instancemethod(_BRepMesh.Handle_BRepMesh_FastDiscret_IsNull, None, Handle_BRepMesh_FastDiscret)
Handle_BRepMesh_FastDiscret._get_reference = new_instancemethod(_BRepMesh.Handle_BRepMesh_FastDiscret__get_reference, None, Handle_BRepMesh_FastDiscret)
Handle_BRepMesh_FastDiscret_swigregister = _BRepMesh.Handle_BRepMesh_FastDiscret_swigregister
Handle_BRepMesh_FastDiscret_swigregister(Handle_BRepMesh_FastDiscret)

def Handle_BRepMesh_FastDiscret_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_BRepMesh_FastDiscret const":
    return _BRepMesh.Handle_BRepMesh_FastDiscret_DownCast(AnObject)
Handle_BRepMesh_FastDiscret_DownCast = _BRepMesh.Handle_BRepMesh_FastDiscret_DownCast

class BRepMesh_FastDiscretFace(OCC.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param theAngle:
        :type theAngle: float
        :rtype: None

        """
        _BRepMesh.BRepMesh_FastDiscretFace_swiginit(self, _BRepMesh.new_BRepMesh_FastDiscretFace(*args))

    def Perform(self, *args) -> "void":
        """
        :param theAttribute:
        :type theAttribute: Handle_BRepMesh_FaceAttribute &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_FastDiscretFace_Perform(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepMesh_FastDiscretFace(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_FastDiscretFace
BRepMesh_FastDiscretFace.Perform = new_instancemethod(_BRepMesh.BRepMesh_FastDiscretFace_Perform, None, BRepMesh_FastDiscretFace)
BRepMesh_FastDiscretFace_swigregister = _BRepMesh.BRepMesh_FastDiscretFace_swigregister
BRepMesh_FastDiscretFace_swigregister(BRepMesh_FastDiscretFace)

class Handle_BRepMesh_FastDiscretFace(OCC.Standard.Handle_Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _BRepMesh.Handle_BRepMesh_FastDiscretFace_swiginit(self, _BRepMesh.new_Handle_BRepMesh_FastDiscretFace(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_FastDiscretFace_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_FastDiscretFace
Handle_BRepMesh_FastDiscretFace.Nullify = new_instancemethod(_BRepMesh.Handle_BRepMesh_FastDiscretFace_Nullify, None, Handle_BRepMesh_FastDiscretFace)
Handle_BRepMesh_FastDiscretFace.IsNull = new_instancemethod(_BRepMesh.Handle_BRepMesh_FastDiscretFace_IsNull, None, Handle_BRepMesh_FastDiscretFace)
Handle_BRepMesh_FastDiscretFace._get_reference = new_instancemethod(_BRepMesh.Handle_BRepMesh_FastDiscretFace__get_reference, None, Handle_BRepMesh_FastDiscretFace)
Handle_BRepMesh_FastDiscretFace_swigregister = _BRepMesh.Handle_BRepMesh_FastDiscretFace_swigregister
Handle_BRepMesh_FastDiscretFace_swigregister(Handle_BRepMesh_FastDiscretFace)

def Handle_BRepMesh_FastDiscretFace_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_BRepMesh_FastDiscretFace const":
    return _BRepMesh.Handle_BRepMesh_FastDiscretFace_DownCast(AnObject)
Handle_BRepMesh_FastDiscretFace_DownCast = _BRepMesh.Handle_BRepMesh_FastDiscretFace_DownCast

class BRepMesh_GeomTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    NoIntersection = _BRepMesh.BRepMesh_GeomTool_NoIntersection
    Cross = _BRepMesh.BRepMesh_GeomTool_Cross
    EndPointTouch = _BRepMesh.BRepMesh_GeomTool_EndPointTouch
    PointOnSegment = _BRepMesh.BRepMesh_GeomTool_PointOnSegment
    Glued = _BRepMesh.BRepMesh_GeomTool_Glued
    Same = _BRepMesh.BRepMesh_GeomTool_Same

    def __init__(self, *args):
        """
        * Constructor. Initiates discretization of the given geometric curve. @param theCurve curve to be discretized. @param theFirstParam first parameter of the curve. @param theLastParam last parameter of the curve. @param theLinDeflection linear deflection. @param theAngDeflection angular deflection. @param theMinPointsNb minimum nuber of points to be produced.

        :param theCurve:
        :type theCurve: BRepAdaptor_Curve &
        :param theFirstParam:
        :type theFirstParam: float
        :param theLastParam:
        :type theLastParam: float
        :param theLinDeflection:
        :type theLinDeflection: float
        :param theAngDeflection:
        :type theAngDeflection: float
        :param theMinPointsNb: default value is 2
        :type theMinPointsNb: int
        :rtype: None

        * Constructor. Initiates discretization of geometric curve corresponding to iso curve of the given surface. @param theSurface surface the iso curve to be taken from. @param theIsoType type of iso curve to be used, U or V. @param theParamIso parameter on the surface specifying the iso curve. @param theFirstParam first parameter of the curve. @param theLastParam last parameter of the curve. @param theLinDeflection linear deflection. @param theAngDeflection angular deflection. @param theMinPointsNb minimum nuber of points to be produced.

        :param theSurface:
        :type theSurface: Handle_BRepAdaptor_HSurface &
        :param theIsoType:
        :type theIsoType: GeomAbs_IsoType
        :param theParamIso:
        :type theParamIso: float
        :param theFirstParam:
        :type theFirstParam: float
        :param theLastParam:
        :type theLastParam: float
        :param theLinDeflection:
        :type theLinDeflection: float
        :param theAngDeflection:
        :type theAngDeflection: float
        :param theMinPointsNb: default value is 2
        :type theMinPointsNb: int
        :rtype: None

        """
        _BRepMesh.BRepMesh_GeomTool_swiginit(self, _BRepMesh.new_BRepMesh_GeomTool(*args))

    def AddPoint(self, *args) -> "Standard_Integer":
        """
        * Adds point to already calculated points (or replaces existing). @param thePoint point to be added. @param theParam parameter on the curve corresponding to the given point. @param theIsReplace if True replaces existing point lying within parameteric tolerance of the given point. returns index of new added point or found with parametric tolerance

        :param thePoint:
        :type thePoint: gp_Pnt
        :param theParam:
        :type theParam: float
        :param theIsReplace: default value is Standard_True
        :type theIsReplace: bool
        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_GeomTool_AddPoint(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * Returns number of discretization points.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_GeomTool_NbPoints(self, *args)


    def Value(self, *args) -> "Standard_Boolean":
        """
        * Gets parameters of discretization point with the given index. @param theIndex index of discretization point. @param theIsoParam parameter on surface to be used as second coordinate of resulting 2d point. @param theParam[out] parameter of the point on the iso curve. @param thePoint[out] discretization point. @param theUV[out] discretization point in parametric space of the surface. returns True on success, False elsewhere.

        :param theIndex:
        :type theIndex: int
        :param theIsoParam:
        :type theIsoParam: float
        :param theParam:
        :type theParam: float &
        :param thePoint:
        :type thePoint: gp_Pnt
        :param theUV:
        :type theUV: gp_Pnt2d
        :rtype: bool

        * Gets parameters of discretization point with the given index. @param theIndex index of discretization point. @param theSurface surface the curve is lying onto. @param theParam[out] parameter of the point on the curve. @param thePoint[out] discretization point. @param theUV[out] discretization point in parametric space of the surface. returns True on success, False elsewhere.

        :param theIndex:
        :type theIndex: int
        :param theSurface:
        :type theSurface: Handle_BRepAdaptor_HSurface &
        :param theParam:
        :type theParam: float &
        :param thePoint:
        :type thePoint: gp_Pnt
        :param theUV:
        :type theUV: gp_Pnt2d
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_GeomTool_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_GeomTool
BRepMesh_GeomTool.AddPoint = new_instancemethod(_BRepMesh.BRepMesh_GeomTool_AddPoint, None, BRepMesh_GeomTool)
BRepMesh_GeomTool.NbPoints = new_instancemethod(_BRepMesh.BRepMesh_GeomTool_NbPoints, None, BRepMesh_GeomTool)
BRepMesh_GeomTool.Value = new_instancemethod(_BRepMesh.BRepMesh_GeomTool_Value, None, BRepMesh_GeomTool)
BRepMesh_GeomTool_swigregister = _BRepMesh.BRepMesh_GeomTool_swigregister
BRepMesh_GeomTool_swigregister(BRepMesh_GeomTool)

class BRepMesh_IEdgeTool(OCC.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * Returns number of tessellation points.

        :rtype: int

        """
        return _BRepMesh.BRepMesh_IEdgeTool_NbPoints(self, *args)


    def Value(self, *args) -> "void":
        """
        * Returns parameters of solution with the given index. @param theIndex index of tessellation point. @param theParameter parameters on PCurve corresponded to the solution. @param thePoint tessellation point. @param theUV coordinates of tessellation point in parametric space of face.

        :param theIndex:
        :type theIndex: int
        :param theParameter:
        :type theParameter: float &
        :param thePoint:
        :type thePoint: gp_Pnt
        :param theUV:
        :type theUV: gp_Pnt2d
        :rtype: None

        """
        return _BRepMesh.BRepMesh_IEdgeTool_Value(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepMesh_IEdgeTool(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_IEdgeTool
BRepMesh_IEdgeTool.NbPoints = new_instancemethod(_BRepMesh.BRepMesh_IEdgeTool_NbPoints, None, BRepMesh_IEdgeTool)
BRepMesh_IEdgeTool.Value = new_instancemethod(_BRepMesh.BRepMesh_IEdgeTool_Value, None, BRepMesh_IEdgeTool)
BRepMesh_IEdgeTool_swigregister = _BRepMesh.BRepMesh_IEdgeTool_swigregister
BRepMesh_IEdgeTool_swigregister(BRepMesh_IEdgeTool)

class Handle_BRepMesh_IEdgeTool(OCC.Standard.Handle_Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _BRepMesh.Handle_BRepMesh_IEdgeTool_swiginit(self, _BRepMesh.new_Handle_BRepMesh_IEdgeTool(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_IEdgeTool_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_IEdgeTool
Handle_BRepMesh_IEdgeTool.Nullify = new_instancemethod(_BRepMesh.Handle_BRepMesh_IEdgeTool_Nullify, None, Handle_BRepMesh_IEdgeTool)
Handle_BRepMesh_IEdgeTool.IsNull = new_instancemethod(_BRepMesh.Handle_BRepMesh_IEdgeTool_IsNull, None, Handle_BRepMesh_IEdgeTool)
Handle_BRepMesh_IEdgeTool._get_reference = new_instancemethod(_BRepMesh.Handle_BRepMesh_IEdgeTool__get_reference, None, Handle_BRepMesh_IEdgeTool)
Handle_BRepMesh_IEdgeTool_swigregister = _BRepMesh.Handle_BRepMesh_IEdgeTool_swigregister
Handle_BRepMesh_IEdgeTool_swigregister(Handle_BRepMesh_IEdgeTool)

def Handle_BRepMesh_IEdgeTool_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_BRepMesh_IEdgeTool const":
    return _BRepMesh.Handle_BRepMesh_IEdgeTool_DownCast(AnObject)
Handle_BRepMesh_IEdgeTool_DownCast = _BRepMesh.Handle_BRepMesh_IEdgeTool_DownCast

class BRepMesh_OrientedEdge(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Default constructor.

        :rtype: None

        * Constructs a link between two vertices.

        :param theFirstNode:
        :type theFirstNode: int
        :param theLastNode:
        :type theLastNode: int
        :rtype: None

        """
        _BRepMesh.BRepMesh_OrientedEdge_swiginit(self, _BRepMesh.new_BRepMesh_OrientedEdge(*args))

    def FirstNode(self, *args) -> "Standard_Integer":
        """
        * Returns index of first node of the Link.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_OrientedEdge_FirstNode(self, *args)


    def LastNode(self, *args) -> "Standard_Integer":
        """
        * Returns index of last node of the Link.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_OrientedEdge_LastNode(self, *args)


    def HashCode(self, *args) -> "Standard_Integer":
        """
        * Returns hash code for this edge. @param theUpper upper index in the container. returns hash code.

        :param theUpper:
        :type theUpper: int
        :rtype: int

        """
        return _BRepMesh.BRepMesh_OrientedEdge_HashCode(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Checks this and other edge for equality. @param theOther edge to be checked against this one. @retrun True if edges have the same orientation, False if not.

        :param theOther:
        :type theOther: BRepMesh_OrientedEdge &
        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_OrientedEdge_IsEqual(self, *args)


    def __eq__(self,right):
        try:
            return self.__eq_wrapper__(right)
        except:
            return False


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_OrientedEdge
BRepMesh_OrientedEdge.FirstNode = new_instancemethod(_BRepMesh.BRepMesh_OrientedEdge_FirstNode, None, BRepMesh_OrientedEdge)
BRepMesh_OrientedEdge.LastNode = new_instancemethod(_BRepMesh.BRepMesh_OrientedEdge_LastNode, None, BRepMesh_OrientedEdge)
BRepMesh_OrientedEdge.HashCode = new_instancemethod(_BRepMesh.BRepMesh_OrientedEdge_HashCode, None, BRepMesh_OrientedEdge)
BRepMesh_OrientedEdge.__hash__ = new_instancemethod(_BRepMesh.BRepMesh_OrientedEdge___hash__, None, BRepMesh_OrientedEdge)
BRepMesh_OrientedEdge.IsEqual = new_instancemethod(_BRepMesh.BRepMesh_OrientedEdge_IsEqual, None, BRepMesh_OrientedEdge)
BRepMesh_OrientedEdge.__eq_wrapper__ = new_instancemethod(_BRepMesh.BRepMesh_OrientedEdge___eq_wrapper__, None, BRepMesh_OrientedEdge)
BRepMesh_OrientedEdge_swigregister = _BRepMesh.BRepMesh_OrientedEdge_swigregister
BRepMesh_OrientedEdge_swigregister(BRepMesh_OrientedEdge)

class BRepMesh_PairOfIndex(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Default constructor

        :rtype: None

        """
        _BRepMesh.BRepMesh_PairOfIndex_swiginit(self, _BRepMesh.new_BRepMesh_PairOfIndex(*args))

    def Clear(self, *args) -> "void":
        """
        * Clears indices.

        :rtype: None

        """
        return _BRepMesh.BRepMesh_PairOfIndex_Clear(self, *args)


    def Append(self, *args) -> "void":
        """
        * Appends index to the pair.

        :param theIndex:
        :type theIndex: int
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_PairOfIndex_Append(self, *args)


    def Prepend(self, *args) -> "void":
        """
        * Prepends index to the pair.

        :param theIndex:
        :type theIndex: int
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_PairOfIndex_Prepend(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns is pair is empty.

        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_PairOfIndex_IsEmpty(self, *args)


    def Extent(self, *args) -> "Standard_Integer":
        """
        * Returns number of initialized indeces.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_PairOfIndex_Extent(self, *args)


    def FirstIndex(self, *args) -> "Standard_Integer":
        """
        * Returns first index of pair.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_PairOfIndex_FirstIndex(self, *args)


    def LastIndex(self, *args) -> "Standard_Integer":
        """
        * Returns last index of pair

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_PairOfIndex_LastIndex(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        * Returns index corresponding to the given position in the pair. @param thePairPos position of index in the pair (1 or 2).

        :param thePairPos:
        :type thePairPos: int
        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_PairOfIndex_Index(self, *args)


    def SetIndex(self, *args) -> "void":
        """
        * Sets index corresponding to the given position in the pair. @param thePairPos position of index in the pair (1 or 2). @param theIndex index to be stored.

        :param thePairPos:
        :type thePairPos: int
        :param theIndex:
        :type theIndex: int
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_PairOfIndex_SetIndex(self, *args)


    def RemoveIndex(self, *args) -> "void":
        """
        * Remove index from the given position. @param thePairPos position of index in the pair (1 or 2).

        :param thePairPos:
        :type thePairPos: int
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_PairOfIndex_RemoveIndex(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_PairOfIndex
BRepMesh_PairOfIndex.Clear = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_Clear, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex.Append = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_Append, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex.Prepend = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_Prepend, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex.IsEmpty = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_IsEmpty, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex.Extent = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_Extent, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex.FirstIndex = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_FirstIndex, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex.LastIndex = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_LastIndex, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex.Index = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_Index, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex.SetIndex = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_SetIndex, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex.RemoveIndex = new_instancemethod(_BRepMesh.BRepMesh_PairOfIndex_RemoveIndex, None, BRepMesh_PairOfIndex)
BRepMesh_PairOfIndex_swigregister = _BRepMesh.BRepMesh_PairOfIndex_swigregister
BRepMesh_PairOfIndex_swigregister(BRepMesh_PairOfIndex)

class BRepMesh_PairOfPolygon(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. Creates empty pair with null fileds.

        :rtype: None

        """
        _BRepMesh.BRepMesh_PairOfPolygon_swiginit(self, _BRepMesh.new_BRepMesh_PairOfPolygon(*args))

    def Clear(self, *args) -> "void":
        """
        * Clears pair handles.

        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_PairOfPolygon_Clear(self, *args)


    def Prepend(self, *args) -> "void":
        """
        * Sets the first element of the pair. If last element is empty, also assignes the given polygon to it. @param thePolygon plygon to be set.

        :param thePolygon:
        :type thePolygon: Handle_Poly_PolygonOnTriangulation &
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_PairOfPolygon_Prepend(self, *args)


    def Append(self, *args) -> "void":
        """
        * Sets the last element of the pair. If first element is empty, also assignes the given polygon to it. @param thePolygon plygon to be set.

        :param thePolygon:
        :type thePolygon: Handle_Poly_PolygonOnTriangulation &
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_PairOfPolygon_Append(self, *args)


    def First(self, *args) -> "Handle_Poly_PolygonOnTriangulation":
        """
        * Returns first polygon on triangulation.

        :rtype: inline  Handle_Poly_PolygonOnTriangulation

        """
        return _BRepMesh.BRepMesh_PairOfPolygon_First(self, *args)


    def Last(self, *args) -> "Handle_Poly_PolygonOnTriangulation":
        """
        * Returns last polygon on triangulation.

        :rtype: inline  Handle_Poly_PolygonOnTriangulation

        """
        return _BRepMesh.BRepMesh_PairOfPolygon_Last(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_PairOfPolygon
BRepMesh_PairOfPolygon.Clear = new_instancemethod(_BRepMesh.BRepMesh_PairOfPolygon_Clear, None, BRepMesh_PairOfPolygon)
BRepMesh_PairOfPolygon.Prepend = new_instancemethod(_BRepMesh.BRepMesh_PairOfPolygon_Prepend, None, BRepMesh_PairOfPolygon)
BRepMesh_PairOfPolygon.Append = new_instancemethod(_BRepMesh.BRepMesh_PairOfPolygon_Append, None, BRepMesh_PairOfPolygon)
BRepMesh_PairOfPolygon.First = new_instancemethod(_BRepMesh.BRepMesh_PairOfPolygon_First, None, BRepMesh_PairOfPolygon)
BRepMesh_PairOfPolygon.Last = new_instancemethod(_BRepMesh.BRepMesh_PairOfPolygon_Last, None, BRepMesh_PairOfPolygon)
BRepMesh_PairOfPolygon_swigregister = _BRepMesh.BRepMesh_PairOfPolygon_swigregister
BRepMesh_PairOfPolygon_swigregister(BRepMesh_PairOfPolygon)

class BRepMesh_SelectorOfDataStructureOfDelaun(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Default constructor.

        :rtype: None

        * Constructor. Initializes selector by the mesh.

        :param theMesh:
        :type theMesh: Handle_BRepMesh_DataStructureOfDelaun &
        :rtype: None

        """
        _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_swiginit(self, _BRepMesh.new_BRepMesh_SelectorOfDataStructureOfDelaun(*args))

    def Initialize(self, *args) -> "void":
        """
        * Initializes selector by the mesh.

        :param theMesh:
        :type theMesh: Handle_BRepMesh_DataStructureOfDelaun &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Initialize(self, *args)


    def NeighboursOfNode(self, *args) -> "void":
        """
        * Selects all neighboring elements of node with the given index.

        :param theNodeIndex:
        :type theNodeIndex: int
        :rtype: None

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOfNode(self, *args)


    def NeighboursOfLink(self, *args) -> "void":
        """
        * Selects all neighboring elements of link with the given index.

        :param theLinkIndex:
        :type theLinkIndex: int
        :rtype: None

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOfLink(self, *args)


    def NeighboursOfElement(self, *args) -> "void":
        """
        * Selects all neighboring elements by nodes of the given element.

        :param theElementIndex:
        :type theElementIndex: int
        :rtype: None

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOfElement(self, *args)


    def NeighboursByEdgeOf(self, *args) -> "void":
        """
        * Selects all neighboring elements by links of the given element.

        :param theElement:
        :type theElement: BRepMesh_Triangle &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursByEdgeOf(self, *args)


    def NeighboursOf(self, *args) -> "void":
        """
        * Selects all neighboring elements of the given node.

        :param theNode:
        :type theNode: BRepMesh_Vertex &
        :rtype: None

        * Selects all neighboring elements of the given link.

        :param theLink:
        :type theLink: BRepMesh_Edge &
        :rtype: None

        * Selects all neighboring elements of the given element.

        :param theElement:
        :type theElement: BRepMesh_Triangle &
        :rtype: None

        * Adds a level of neighbours by edge to the selector.

        :param &:
        :type &: BRepMesh_SelectorOfDataStructureOfDelaun
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOf(self, *args)


    def AddNeighbours(self, *args) -> "void":
        """
        * Adds a level of neighbours by edge the selector.

        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_AddNeighbours(self, *args)


    def Nodes(self, *args) -> "BRepMesh::MapOfInteger const &":
        """
        * Returns selected nodes.

        :rtype: inline  BRepMesh::MapOfInteger

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Nodes(self, *args)


    def Links(self, *args) -> "BRepMesh::MapOfInteger const &":
        """
        * Returns selected links.

        :rtype: inline  BRepMesh::MapOfInteger

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Links(self, *args)


    def Elements(self, *args) -> "BRepMesh::MapOfInteger const &":
        """
        * Returns selected elements.

        :rtype: inline  BRepMesh::MapOfInteger

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Elements(self, *args)


    def FrontierLinks(self, *args) -> "BRepMesh::MapOfInteger const &":
        """
        * Gives the list of incices of frontier links.

        :rtype: inline  BRepMesh::MapOfInteger

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_FrontierLinks(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_SelectorOfDataStructureOfDelaun
BRepMesh_SelectorOfDataStructureOfDelaun.Initialize = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Initialize, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.NeighboursOfNode = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOfNode, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.NeighboursOfLink = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOfLink, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.NeighboursOfElement = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOfElement, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.NeighboursByEdgeOf = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursByEdgeOf, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.NeighboursOf = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOf, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.AddNeighbours = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_AddNeighbours, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.Nodes = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Nodes, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.Links = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Links, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.Elements = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Elements, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun.FrontierLinks = new_instancemethod(_BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_FrontierLinks, None, BRepMesh_SelectorOfDataStructureOfDelaun)
BRepMesh_SelectorOfDataStructureOfDelaun_swigregister = _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_swigregister
BRepMesh_SelectorOfDataStructureOfDelaun_swigregister(BRepMesh_SelectorOfDataStructureOfDelaun)

class BRepMesh_ShapeTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MaxFaceTolerance(*args) -> "Standard_Real":
        """
        * Returns maximum tolerance of the given face. Considers tolerances of edges and vertices contained in the given face.

        :param theFace:
        :type theFace: TopoDS_Face &
        :rtype: float

        """
        return _BRepMesh.BRepMesh_ShapeTool_MaxFaceTolerance(*args)

    MaxFaceTolerance = staticmethod(MaxFaceTolerance)

    def BoxMaxDimension(*args) -> "Standard_Real &":
        """
        * Gets the maximum dimension of the given bounding box. If the given bounding box is void leaves the resulting value unchanged. @param theBox bounding box to be processed. @param theMaxDimension maximum dimension of the given box.

        :param theBox:
        :type theBox: Bnd_Box &
        :param theMaxDimension:
        :type theMaxDimension: float &
        :rtype: void

        """
        return _BRepMesh.BRepMesh_ShapeTool_BoxMaxDimension(*args)

    BoxMaxDimension = staticmethod(BoxMaxDimension)

    def RelativeEdgeDeflection(*args) -> "Standard_Real &":
        """
        * Returns relative deflection for edge with respect to shape size. @param theEdge edge for which relative deflection should be computed. @param theDeflection absolute deflection. @param theMaxShapeSize maximum size of a shape. @param theAdjustmentCoefficient coefficient of adjustment between maximum size of shape and calculated relative deflection. returns relative deflection for the edge.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theDeflection:
        :type theDeflection: float
        :param theMaxShapeSize:
        :type theMaxShapeSize: float
        :param theAdjustmentCoefficient:
        :type theAdjustmentCoefficient: float &
        :rtype: float

        """
        return _BRepMesh.BRepMesh_ShapeTool_RelativeEdgeDeflection(*args)

    RelativeEdgeDeflection = staticmethod(RelativeEdgeDeflection)

    def FindUV(*args) -> "gp_XY":
        """
        * Checks 2d representations of 3d point with the given index for equality to avoid duplications. @param theIndexOfPnt3d index of 3d point with which 2d representation should be associated. @param thePnt2d 2d representation of the point with the given index. @param theVertex vertex corresponded to 3d point with the given index. Used to extract vertex tolerance in 3d space. @param theMinDistance minimum distance between vertices regarding which they could be treated as distinct ones. This value is defined by mesher using parameters given by user in connection with shape metrics. @param theFaceAttribute attributes contining data calculated according to face geomtry and define limits of face in parametric space. If defined, will be used instead of surface parameter. @param theLocation2dMap map of 2d representations of 3d points. returns given 2d point in case if 3d poind does not alredy have the similar representation, otherwice 2d point corresponding to existing representation will be returned.

        :param theIndexOfPnt3d:
        :type theIndexOfPnt3d: int
        :param thePnt2d:
        :type thePnt2d: gp_Pnt2d
        :param theVertex:
        :type theVertex: TopoDS_Vertex &
        :param theMinDistance:
        :type theMinDistance: float
        :param theFaceAttribute:
        :type theFaceAttribute: Handle_BRepMesh_FaceAttribute &
        :rtype: gp_XY

        """
        return _BRepMesh.BRepMesh_ShapeTool_FindUV(*args)

    FindUV = staticmethod(FindUV)

    def AddInFace(*args) -> "void":
        """
        * Stores the given triangulation into the given face. @param theFace face to be updated by triangulation. @param theTriangulation triangulation to be stored into the face.

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theTriangulation:
        :type theTriangulation: Handle_Poly_Triangulation &
        :rtype: void

        """
        return _BRepMesh.BRepMesh_ShapeTool_AddInFace(*args)

    AddInFace = staticmethod(AddInFace)

    def NullifyFace(*args) -> "void":
        """
        * Nullifies triangulation stored in the face. @param theFace face to be updated by null triangulation.

        :param theFace:
        :type theFace: TopoDS_Face &
        :rtype: void

        """
        return _BRepMesh.BRepMesh_ShapeTool_NullifyFace(*args)

    NullifyFace = staticmethod(NullifyFace)

    def NullifyEdge(*args) -> "void":
        """
        * Nullifies polygon on triangulation stored in the edge. @param theEdge edge to be updated by null polygon. @param theTriangulation triangulation the given edge is associated to. @param theLocation face location.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theTriangulation:
        :type theTriangulation: Handle_Poly_Triangulation &
        :param theLocation:
        :type theLocation: TopLoc_Location &
        :rtype: void

        """
        return _BRepMesh.BRepMesh_ShapeTool_NullifyEdge(*args)

    NullifyEdge = staticmethod(NullifyEdge)

    def UpdateEdge(*args) -> "void":
        """
        * Updates the given edge by the given tessellated representation. @param theEdge edge to be updated. @param thePolygon tessellated representation of the edge to be stored. @param theTriangulation triangulation the given edge is associated to. @param theLocation face location.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param thePolygon:
        :type thePolygon: Handle_Poly_PolygonOnTriangulation &
        :param theTriangulation:
        :type theTriangulation: Handle_Poly_Triangulation &
        :param theLocation:
        :type theLocation: TopLoc_Location &
        :rtype: void

        * Updates the given seam edge by the given tessellated representations. @param theEdge edge to be updated. @param thePolygon1 tessellated representation corresponding to forward direction of the seam edge. @param thePolygon2 tessellated representation corresponding to reversed direction of the seam edge. @param theTriangulation triangulation the given edge is associated to. @param theLocation face location.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param thePolygon1:
        :type thePolygon1: Handle_Poly_PolygonOnTriangulation &
        :param thePolygon2:
        :type thePolygon2: Handle_Poly_PolygonOnTriangulation &
        :param theTriangulation:
        :type theTriangulation: Handle_Poly_Triangulation &
        :param theLocation:
        :type theLocation: TopLoc_Location &
        :rtype: void

        """
        return _BRepMesh.BRepMesh_ShapeTool_UpdateEdge(*args)

    UpdateEdge = staticmethod(UpdateEdge)

    def UseLocation(*args) -> "gp_Pnt":
        """
        * Applies location to the given point and return result. @param thePnt point to be transformed. @param theLoc location to be applied.

        :param thePnt:
        :type thePnt: gp_Pnt
        :param theLoc:
        :type theLoc: TopLoc_Location &
        :rtype: gp_Pnt

        """
        return _BRepMesh.BRepMesh_ShapeTool_UseLocation(*args)

    UseLocation = staticmethod(UseLocation)

    def IsDegenerated(*args) -> "Standard_Boolean":
        """
        * Checks is the given edge degenerated. Checks geometrical parameters in case if IsDegenerated flag is not set. @param theEdge edge to be checked. @param theFace face within which parametric space edge will be checked for geometrical degenerativity.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theFace:
        :type theFace: TopoDS_Face &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_ShapeTool_IsDegenerated(*args)

    IsDegenerated = staticmethod(IsDegenerated)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepMesh.BRepMesh_ShapeTool_swiginit(self, _BRepMesh.new_BRepMesh_ShapeTool())
    __swig_destroy__ = _BRepMesh.delete_BRepMesh_ShapeTool
BRepMesh_ShapeTool_swigregister = _BRepMesh.BRepMesh_ShapeTool_swigregister
BRepMesh_ShapeTool_swigregister(BRepMesh_ShapeTool)

def BRepMesh_ShapeTool_MaxFaceTolerance(*args) -> "Standard_Real":
    """
    * Returns maximum tolerance of the given face. Considers tolerances of edges and vertices contained in the given face.

    :param theFace:
    :type theFace: TopoDS_Face &
    :rtype: float

    """
    return _BRepMesh.BRepMesh_ShapeTool_MaxFaceTolerance(*args)

def BRepMesh_ShapeTool_BoxMaxDimension(*args) -> "Standard_Real &":
    """
    * Gets the maximum dimension of the given bounding box. If the given bounding box is void leaves the resulting value unchanged. @param theBox bounding box to be processed. @param theMaxDimension maximum dimension of the given box.

    :param theBox:
    :type theBox: Bnd_Box &
    :param theMaxDimension:
    :type theMaxDimension: float &
    :rtype: void

    """
    return _BRepMesh.BRepMesh_ShapeTool_BoxMaxDimension(*args)

def BRepMesh_ShapeTool_RelativeEdgeDeflection(*args) -> "Standard_Real &":
    """
    * Returns relative deflection for edge with respect to shape size. @param theEdge edge for which relative deflection should be computed. @param theDeflection absolute deflection. @param theMaxShapeSize maximum size of a shape. @param theAdjustmentCoefficient coefficient of adjustment between maximum size of shape and calculated relative deflection. returns relative deflection for the edge.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theDeflection:
    :type theDeflection: float
    :param theMaxShapeSize:
    :type theMaxShapeSize: float
    :param theAdjustmentCoefficient:
    :type theAdjustmentCoefficient: float &
    :rtype: float

    """
    return _BRepMesh.BRepMesh_ShapeTool_RelativeEdgeDeflection(*args)

def BRepMesh_ShapeTool_FindUV(*args) -> "gp_XY":
    """
    * Checks 2d representations of 3d point with the given index for equality to avoid duplications. @param theIndexOfPnt3d index of 3d point with which 2d representation should be associated. @param thePnt2d 2d representation of the point with the given index. @param theVertex vertex corresponded to 3d point with the given index. Used to extract vertex tolerance in 3d space. @param theMinDistance minimum distance between vertices regarding which they could be treated as distinct ones. This value is defined by mesher using parameters given by user in connection with shape metrics. @param theFaceAttribute attributes contining data calculated according to face geomtry and define limits of face in parametric space. If defined, will be used instead of surface parameter. @param theLocation2dMap map of 2d representations of 3d points. returns given 2d point in case if 3d poind does not alredy have the similar representation, otherwice 2d point corresponding to existing representation will be returned.

    :param theIndexOfPnt3d:
    :type theIndexOfPnt3d: int
    :param thePnt2d:
    :type thePnt2d: gp_Pnt2d
    :param theVertex:
    :type theVertex: TopoDS_Vertex &
    :param theMinDistance:
    :type theMinDistance: float
    :param theFaceAttribute:
    :type theFaceAttribute: Handle_BRepMesh_FaceAttribute &
    :rtype: gp_XY

    """
    return _BRepMesh.BRepMesh_ShapeTool_FindUV(*args)

def BRepMesh_ShapeTool_AddInFace(*args) -> "void":
    """
    * Stores the given triangulation into the given face. @param theFace face to be updated by triangulation. @param theTriangulation triangulation to be stored into the face.

    :param theFace:
    :type theFace: TopoDS_Face &
    :param theTriangulation:
    :type theTriangulation: Handle_Poly_Triangulation &
    :rtype: void

    """
    return _BRepMesh.BRepMesh_ShapeTool_AddInFace(*args)

def BRepMesh_ShapeTool_NullifyFace(*args) -> "void":
    """
    * Nullifies triangulation stored in the face. @param theFace face to be updated by null triangulation.

    :param theFace:
    :type theFace: TopoDS_Face &
    :rtype: void

    """
    return _BRepMesh.BRepMesh_ShapeTool_NullifyFace(*args)

def BRepMesh_ShapeTool_NullifyEdge(*args) -> "void":
    """
    * Nullifies polygon on triangulation stored in the edge. @param theEdge edge to be updated by null polygon. @param theTriangulation triangulation the given edge is associated to. @param theLocation face location.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theTriangulation:
    :type theTriangulation: Handle_Poly_Triangulation &
    :param theLocation:
    :type theLocation: TopLoc_Location &
    :rtype: void

    """
    return _BRepMesh.BRepMesh_ShapeTool_NullifyEdge(*args)

def BRepMesh_ShapeTool_UpdateEdge(*args) -> "void":
    """
    * Updates the given edge by the given tessellated representation. @param theEdge edge to be updated. @param thePolygon tessellated representation of the edge to be stored. @param theTriangulation triangulation the given edge is associated to. @param theLocation face location.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param thePolygon:
    :type thePolygon: Handle_Poly_PolygonOnTriangulation &
    :param theTriangulation:
    :type theTriangulation: Handle_Poly_Triangulation &
    :param theLocation:
    :type theLocation: TopLoc_Location &
    :rtype: void

    * Updates the given seam edge by the given tessellated representations. @param theEdge edge to be updated. @param thePolygon1 tessellated representation corresponding to forward direction of the seam edge. @param thePolygon2 tessellated representation corresponding to reversed direction of the seam edge. @param theTriangulation triangulation the given edge is associated to. @param theLocation face location.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param thePolygon1:
    :type thePolygon1: Handle_Poly_PolygonOnTriangulation &
    :param thePolygon2:
    :type thePolygon2: Handle_Poly_PolygonOnTriangulation &
    :param theTriangulation:
    :type theTriangulation: Handle_Poly_Triangulation &
    :param theLocation:
    :type theLocation: TopLoc_Location &
    :rtype: void

    """
    return _BRepMesh.BRepMesh_ShapeTool_UpdateEdge(*args)

def BRepMesh_ShapeTool_UseLocation(*args) -> "gp_Pnt":
    """
    * Applies location to the given point and return result. @param thePnt point to be transformed. @param theLoc location to be applied.

    :param thePnt:
    :type thePnt: gp_Pnt
    :param theLoc:
    :type theLoc: TopLoc_Location &
    :rtype: gp_Pnt

    """
    return _BRepMesh.BRepMesh_ShapeTool_UseLocation(*args)

def BRepMesh_ShapeTool_IsDegenerated(*args) -> "Standard_Boolean":
    """
    * Checks is the given edge degenerated. Checks geometrical parameters in case if IsDegenerated flag is not set. @param theEdge edge to be checked. @param theFace face within which parametric space edge will be checked for geometrical degenerativity.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theFace:
    :type theFace: TopoDS_Face &
    :rtype: bool

    """
    return _BRepMesh.BRepMesh_ShapeTool_IsDegenerated(*args)

class BRepMesh_Triangle(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Default constructor.

        :rtype: None

        * Constructor. @param theEdges array of edges of triangle. @param theOrientations array of edge's orientations. @param theMovability movability of triangle.

        :param Standard_Integer(&theEdges):
        :type Standard_Integer(&theEdges): 
        :param Standard_Boolean(&theOrientations):
        :type Standard_Boolean(&theOrientations): 
        :param theMovability:
        :type theMovability: BRepMesh_DegreeOfFreedom
        :rtype: None

        """
        _BRepMesh.BRepMesh_Triangle_swiginit(self, _BRepMesh.new_BRepMesh_Triangle(*args))

    def Initialize(self, *args) -> "void":
        """
        * Initializes the triangle by the given parameters. @param theEdges array of edges of triangle. @param theOrientations array of edge's orientations. @param theMovability movability of triangle.

        :param Standard_Integer(&theEdges):
        :type Standard_Integer(&theEdges): 
        :param Standard_Boolean(&theOrientations):
        :type Standard_Boolean(&theOrientations): 
        :param theMovability:
        :type theMovability: BRepMesh_DegreeOfFreedom
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_Triangle_Initialize(self, *args)


    def Edges(self, *args) -> "void":
        """
        * Gets edges with orientations composing the triangle. @param[out] theEdges array edges are stored to. @param[out] theOrientations array orientations are stored to.

        :param :
        :type : int(&theEdges)
        :param :
        :type : bool(&theOrientations)
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_Triangle_Edges(self, *args)


    def Movability(self, *args) -> "BRepMesh_DegreeOfFreedom":
        """
        * Returns movability of the triangle.

        :rtype: inline BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Triangle_Movability(self, *args)


    def SetMovability(self, *args) -> "void":
        """
        * Sets movability of the triangle.

        :param theMovability:
        :type theMovability: BRepMesh_DegreeOfFreedom
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_Triangle_SetMovability(self, *args)


    def HashCode(self, *args) -> "Standard_Integer":
        """
        * Returns hash code for this triangle. @param theUpper upper index in the container. returns hash code.

        :param theUpper:
        :type theUpper: int
        :rtype: int

        """
        return _BRepMesh.BRepMesh_Triangle_HashCode(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Checks for equality with another triangle. @param theOther triangle to be checked against this one. returns True if equal, False if not.

        :param theOther:
        :type theOther: BRepMesh_Triangle &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_Triangle_IsEqual(self, *args)


    def __eq__(self,right):
        try:
            return self.__eq_wrapper__(right)
        except:
            return False


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Triangle
BRepMesh_Triangle.Initialize = new_instancemethod(_BRepMesh.BRepMesh_Triangle_Initialize, None, BRepMesh_Triangle)
BRepMesh_Triangle.Edges = new_instancemethod(_BRepMesh.BRepMesh_Triangle_Edges, None, BRepMesh_Triangle)
BRepMesh_Triangle.Movability = new_instancemethod(_BRepMesh.BRepMesh_Triangle_Movability, None, BRepMesh_Triangle)
BRepMesh_Triangle.SetMovability = new_instancemethod(_BRepMesh.BRepMesh_Triangle_SetMovability, None, BRepMesh_Triangle)
BRepMesh_Triangle.HashCode = new_instancemethod(_BRepMesh.BRepMesh_Triangle_HashCode, None, BRepMesh_Triangle)
BRepMesh_Triangle.__hash__ = new_instancemethod(_BRepMesh.BRepMesh_Triangle___hash__, None, BRepMesh_Triangle)
BRepMesh_Triangle.IsEqual = new_instancemethod(_BRepMesh.BRepMesh_Triangle_IsEqual, None, BRepMesh_Triangle)
BRepMesh_Triangle.__eq_wrapper__ = new_instancemethod(_BRepMesh.BRepMesh_Triangle___eq_wrapper__, None, BRepMesh_Triangle)
BRepMesh_Triangle_swigregister = _BRepMesh.BRepMesh_Triangle_swigregister
BRepMesh_Triangle_swigregister(BRepMesh_Triangle)

class BRepMesh_Vertex(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Default constructor

        :rtype: None

        * Creates vertex associated with point in 3d space. @param theUV position of vertex in parametric space. @param theLocation3d index of 3d point to be associated with vertex. @param theMovability movability of the vertex.

        :param theUV:
        :type theUV: gp_XY
        :param theLocation3d:
        :type theLocation3d: int
        :param theMovability:
        :type theMovability: BRepMesh_DegreeOfFreedom
        :rtype: None

        * Creates vertex without association with point in 3d space. @param theU U position of vertex in parametric space. @param theV V position of vertex in parametric space. @param theMovability movability of the vertex.

        :param theU:
        :type theU: float
        :param theV:
        :type theV: float
        :param theMovability:
        :type theMovability: BRepMesh_DegreeOfFreedom
        :rtype: None

        """
        _BRepMesh.BRepMesh_Vertex_swiginit(self, _BRepMesh.new_BRepMesh_Vertex(*args))

    def Initialize(self, *args) -> "void":
        """
        * Initializes vertex associated with point in 3d space. @param theUV position of vertex in parametric space. @param theLocation3d index of 3d point to be associated with vertex. @param theMovability movability of the vertex.

        :param theUV:
        :type theUV: gp_XY
        :param theLocation3d:
        :type theLocation3d: int
        :param theMovability:
        :type theMovability: BRepMesh_DegreeOfFreedom
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_Vertex_Initialize(self, *args)


    def Coord(self, *args) -> "gp_XY const":
        """
        * Returns position of the vertex in parametric space.

        :rtype: inline  gp_XY

        """
        return _BRepMesh.BRepMesh_Vertex_Coord(self, *args)


    def ChangeCoord(self, *args) -> "gp_XY":
        """
        * Returns position of the vertex in parametric space for modification.

        :rtype: inline gp_XY

        """
        return _BRepMesh.BRepMesh_Vertex_ChangeCoord(self, *args)


    def Location3d(self, *args) -> "Standard_Integer":
        """
        * Returns index of 3d point associated with the vertex.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_Vertex_Location3d(self, *args)


    def Movability(self, *args) -> "BRepMesh_DegreeOfFreedom":
        """
        * Returns movability of the vertex.

        :rtype: inline BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Vertex_Movability(self, *args)


    def SetMovability(self, *args) -> "void":
        """
        * Sets movability of the vertex.

        :param theMovability:
        :type theMovability: BRepMesh_DegreeOfFreedom
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_Vertex_SetMovability(self, *args)


    def HashCode(self, *args) -> "Standard_Integer":
        """
        * Returns hash code for this vertex. @param theUpper upper index in the container. returns hash code.

        :param Upper:
        :type Upper: int
        :rtype: int

        """
        return _BRepMesh.BRepMesh_Vertex_HashCode(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Checks for equality with another vertex. @param theOther vertex to be checked against this one. returns True if equal, False if not.

        :param theOther:
        :type theOther: BRepMesh_Vertex &
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_Vertex_IsEqual(self, *args)


    def __eq__(self,right):
        try:
            return self.__eq_wrapper__(right)
        except:
            return False


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Vertex
BRepMesh_Vertex.Initialize = new_instancemethod(_BRepMesh.BRepMesh_Vertex_Initialize, None, BRepMesh_Vertex)
BRepMesh_Vertex.Coord = new_instancemethod(_BRepMesh.BRepMesh_Vertex_Coord, None, BRepMesh_Vertex)
BRepMesh_Vertex.ChangeCoord = new_instancemethod(_BRepMesh.BRepMesh_Vertex_ChangeCoord, None, BRepMesh_Vertex)
BRepMesh_Vertex.Location3d = new_instancemethod(_BRepMesh.BRepMesh_Vertex_Location3d, None, BRepMesh_Vertex)
BRepMesh_Vertex.Movability = new_instancemethod(_BRepMesh.BRepMesh_Vertex_Movability, None, BRepMesh_Vertex)
BRepMesh_Vertex.SetMovability = new_instancemethod(_BRepMesh.BRepMesh_Vertex_SetMovability, None, BRepMesh_Vertex)
BRepMesh_Vertex.HashCode = new_instancemethod(_BRepMesh.BRepMesh_Vertex_HashCode, None, BRepMesh_Vertex)
BRepMesh_Vertex.__hash__ = new_instancemethod(_BRepMesh.BRepMesh_Vertex___hash__, None, BRepMesh_Vertex)
BRepMesh_Vertex.IsEqual = new_instancemethod(_BRepMesh.BRepMesh_Vertex_IsEqual, None, BRepMesh_Vertex)
BRepMesh_Vertex.__eq_wrapper__ = new_instancemethod(_BRepMesh.BRepMesh_Vertex___eq_wrapper__, None, BRepMesh_Vertex)
BRepMesh_Vertex_swigregister = _BRepMesh.BRepMesh_Vertex_swigregister
BRepMesh_Vertex_swigregister(BRepMesh_Vertex)

class BRepMesh_VertexInspector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. @param theReservedSize size to be reserved for vector of vertices. @param theAllocator memory allocator to be used by internal collections.

        :param theReservedSize:
        :type theReservedSize: int
        :param theAllocator:
        :type theAllocator: Handle_NCollection_IncAllocator &
        :rtype: None

        """
        _BRepMesh.BRepMesh_VertexInspector_swiginit(self, _BRepMesh.new_BRepMesh_VertexInspector(*args))

    def Add(self, *args) -> "Standard_Integer":
        """
        * Registers the given vertex. @param theVertex vertex to be registered.

        :param theVertex:
        :type theVertex: BRepMesh_Vertex &
        :rtype: int

        """
        return _BRepMesh.BRepMesh_VertexInspector_Add(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Sets the tolerance to be used for identification of coincident vertices equal for both dimensions.

        :param theTolerance:
        :type theTolerance: float
        :rtype: inline void

        * Sets the tolerance to be used for identification of coincident vertices. @param theToleranceX tolerance for X dimension. @param theToleranceY tolerance for Y dimension.

        :param theToleranceX:
        :type theToleranceX: float
        :param theToleranceY:
        :type theToleranceY: float
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_VertexInspector_SetTolerance(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clear inspector's internal data structures.

        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_VertexInspector_Clear(self, *args)


    def Delete(self, *args) -> "void":
        """
        * Deletes vertex with the given index. @param theIndex index of vertex to be removed.

        :param theIndex:
        :type theIndex: int
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_VertexInspector_Delete(self, *args)


    def NbVertices(self, *args) -> "Standard_Integer":
        """
        * Returns number of registered vertices.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_VertexInspector_NbVertices(self, *args)


    def GetVertex(self, *args) -> "BRepMesh_Vertex &":
        """
        * Returns vertex with the given index.

        :param theIndex:
        :type theIndex: int
        :rtype: inline BRepMesh_Vertex

        """
        return _BRepMesh.BRepMesh_VertexInspector_GetVertex(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        * Set reference point to be checked.

        :param thePoint:
        :type thePoint: gp_XY
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_VertexInspector_SetPoint(self, *args)


    def GetCoincidentPoint(self, *args) -> "Standard_Integer":
        """
        * Returns index of point coinciding with regerence one.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_VertexInspector_GetCoincidentPoint(self, *args)


    def GetListOfDelPoints(self, *args) -> "BRepMesh::ListOfInteger const &":
        """
        * Returns list with indexes of vertices that have movability attribute equal to BRepMesh_Deleted and can be replaced with another node.

        :rtype: inline  BRepMesh::ListOfInteger

        """
        return _BRepMesh.BRepMesh_VertexInspector_GetListOfDelPoints(self, *args)


    def Vertices(self, *args) -> "BRepMesh::HVectorOfVertex const &":
        """
        * Returns set of mesh vertices.

        :rtype: inline  BRepMesh::HVectorOfVertex

        """
        return _BRepMesh.BRepMesh_VertexInspector_Vertices(self, *args)


    def ChangeVertices(self, *args) -> "BRepMesh::HVectorOfVertex &":
        """
        * Returns set of mesh vertices for modification.

        :rtype: inline BRepMesh::HVectorOfVertex

        """
        return _BRepMesh.BRepMesh_VertexInspector_ChangeVertices(self, *args)


    def Inspect(self, *args) -> "NCollection_CellFilter_Action":
        """
        * Performs inspection of a point with the given index. @param theTargetIndex index of a circle to be checked. returns status of the check.

        :param theTargetIndex:
        :type theTargetIndex: int
        :rtype: NCollection_CellFilter_Action

        """
        return _BRepMesh.BRepMesh_VertexInspector_Inspect(self, *args)


    def IsEqual(*args) -> "Standard_Boolean":
        """
        * Checks indices for equlity.

        :param theIndex:
        :type theIndex: int
        :param theTargetIndex:
        :type theTargetIndex: int
        :rtype: bool

        """
        return _BRepMesh.BRepMesh_VertexInspector_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_VertexInspector
BRepMesh_VertexInspector.Add = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_Add, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.SetTolerance = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_SetTolerance, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.Clear = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_Clear, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.Delete = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_Delete, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.NbVertices = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_NbVertices, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.GetVertex = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_GetVertex, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.SetPoint = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_SetPoint, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.GetCoincidentPoint = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_GetCoincidentPoint, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.GetListOfDelPoints = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_GetListOfDelPoints, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.Vertices = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_Vertices, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.ChangeVertices = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_ChangeVertices, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector.Inspect = new_instancemethod(_BRepMesh.BRepMesh_VertexInspector_Inspect, None, BRepMesh_VertexInspector)
BRepMesh_VertexInspector_swigregister = _BRepMesh.BRepMesh_VertexInspector_swigregister
BRepMesh_VertexInspector_swigregister(BRepMesh_VertexInspector)

def BRepMesh_VertexInspector_IsEqual(*args) -> "Standard_Boolean":
    """
    * Checks indices for equlity.

    :param theIndex:
    :type theIndex: int
    :param theTargetIndex:
    :type theTargetIndex: int
    :rtype: bool

    """
    return _BRepMesh.BRepMesh_VertexInspector_IsEqual(*args)

class BRepMesh_VertexTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. @param theReservedSize size to be reserved for vector of vertices. @param theAllocator memory allocator to be used by internal collections.

        :param theReservedSize:
        :type theReservedSize: int
        :param theAllocator:
        :type theAllocator: Handle_NCollection_IncAllocator &
        :rtype: None

        """
        _BRepMesh.BRepMesh_VertexTool_swiginit(self, _BRepMesh.new_BRepMesh_VertexTool(*args))

    def SetCellSize(self, *args) -> "void":
        """
        * Sets new size of cell for cellfilter equal in both directions.

        :param theSize:
        :type theSize: float
        :rtype: None

        * Sets new size of cell for cellfilter. @param theSizeX size for X dimension. @param theSizeY size for Y dimension.

        :param theSizeX:
        :type theSizeX: float
        :param theSizeY:
        :type theSizeY: float
        :rtype: None

        """
        return _BRepMesh.BRepMesh_VertexTool_SetCellSize(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Sets the tolerance to be used for identification of coincident vertices equal for both dimensions.

        :param theTolerance:
        :type theTolerance: float
        :rtype: None

        * Sets the tolerance to be used for identification of coincident vertices. @param theToleranceX tolerance for X dimension. @param theToleranceY tolerance for Y dimension.

        :param theToleranceX:
        :type theToleranceX: float
        :param theToleranceY:
        :type theToleranceY: float
        :rtype: None

        """
        return _BRepMesh.BRepMesh_VertexTool_SetTolerance(self, *args)


    def Add(self, *args) -> "Standard_Integer":
        """
        * Adds vertex with empty data to the tool. @param theVertex node to be added to the mesh. @param isForceAdd adds the given node to structure without checking on coincidence with other nodes. returns index of the node in the structure.

        :param theVertex:
        :type theVertex: BRepMesh_Vertex &
        :param isForceAdd:
        :type isForceAdd: bool
        :rtype: int

        """
        return _BRepMesh.BRepMesh_VertexTool_Add(self, *args)


    def Delete(self, *args) -> "void":
        """
        * Deletes vertex with the given index from the tool.

        :param theIndex:
        :type theIndex: int
        :rtype: None

        """
        return _BRepMesh.BRepMesh_VertexTool_Delete(self, *args)


    def Vertices(self, *args) -> "BRepMesh::HVectorOfVertex const &":
        """
        * Returns set of mesh vertices.

        :rtype: inline  BRepMesh::HVectorOfVertex

        """
        return _BRepMesh.BRepMesh_VertexTool_Vertices(self, *args)


    def ChangeVertices(self, *args) -> "BRepMesh::HVectorOfVertex &":
        """
        * Returns set of mesh vertices.

        :rtype: inline BRepMesh::HVectorOfVertex

        """
        return _BRepMesh.BRepMesh_VertexTool_ChangeVertices(self, *args)


    def FindKey(self, *args) -> "BRepMesh_Vertex const &":
        """
        * Returns vertex by the given index.

        :param theIndex:
        :type theIndex: int
        :rtype: inline  BRepMesh_Vertex

        """
        return _BRepMesh.BRepMesh_VertexTool_FindKey(self, *args)


    def FindIndex(self, *args) -> "Standard_Integer":
        """
        * Returns index of the given vertex.

        :param theVertex:
        :type theVertex: BRepMesh_Vertex &
        :rtype: int

        """
        return _BRepMesh.BRepMesh_VertexTool_FindIndex(self, *args)


    def Extent(self, *args) -> "Standard_Integer":
        """
        * Returns a number of vertices.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_VertexTool_Extent(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns True when the map contains no keys.

        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_VertexTool_IsEmpty(self, *args)


    def Substitute(self, *args) -> "void":
        """
        * Substitutes vertex with the given by the given vertex with attributes. @param theIndex index of vertex to be substituted. @param theVertex replacement vertex.

        :param theIndex:
        :type theIndex: int
        :param theVertex:
        :type theVertex: BRepMesh_Vertex &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_VertexTool_Substitute(self, *args)


    def RemoveLast(self, *args) -> "void":
        """
        * Remove last node from the structure.

        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_VertexTool_RemoveLast(self, *args)


    def GetListOfDelNodes(self, *args) -> "BRepMesh::ListOfInteger const &":
        """
        * Returns the list with indexes of vertices that have movability attribute equal to BRepMesh_Deleted and can be replaced with another node.

        :rtype: inline  BRepMesh::ListOfInteger

        """
        return _BRepMesh.BRepMesh_VertexTool_GetListOfDelNodes(self, *args)


    def StatisticsToString(self) -> "std::string":
        """StatisticsToString(BRepMesh_VertexTool self) -> std::string"""
        return _BRepMesh.BRepMesh_VertexTool_StatisticsToString(self)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_VertexTool
BRepMesh_VertexTool.SetCellSize = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_SetCellSize, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.SetTolerance = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_SetTolerance, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.Add = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_Add, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.Delete = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_Delete, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.Vertices = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_Vertices, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.ChangeVertices = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_ChangeVertices, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.FindKey = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_FindKey, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.FindIndex = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_FindIndex, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.Extent = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_Extent, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.IsEmpty = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_IsEmpty, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.Substitute = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_Substitute, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.RemoveLast = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_RemoveLast, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.GetListOfDelNodes = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_GetListOfDelNodes, None, BRepMesh_VertexTool)
BRepMesh_VertexTool.StatisticsToString = new_instancemethod(_BRepMesh.BRepMesh_VertexTool_StatisticsToString, None, BRepMesh_VertexTool)
BRepMesh_VertexTool_swigregister = _BRepMesh.BRepMesh_VertexTool_swigregister
BRepMesh_VertexTool_swigregister(BRepMesh_VertexTool)

class BRepMesh_WireChecker(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. @param theFace Face to be checked. @param theTolUV Tolerance to be used for calculations in parametric space. @param theEdges Map of edges with associated polygon on triangulation. @param theVertexMap Map of face vertices. @param theStructure Discretized representation of face in parametric space. @param theUmin Lower U boundary of the face in parametric space. @param theUmax Upper U boundary of the face in parametric space. @param theVmin Lower V boundary of the face in parametric space. @param theVmax Upper V boundary of the face in parametric space.

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theTolUV:
        :type theTolUV: float
        :param theEdges:
        :type theEdges: BRepMesh::HDMapOfShapePairOfPolygon &
        :param theVertexMap:
        :type theVertexMap: BRepMesh::HIMapOfInteger &
        :param theStructure:
        :type theStructure: Handle_BRepMesh_DataStructureOfDelaun &
        :param theUmin:
        :type theUmin: float
        :param theUmax:
        :type theUmax: float
        :param theVmin:
        :type theVmin: float
        :param theVmax:
        :type theVmax: float
        :param isInParallel:
        :type isInParallel: bool
        :rtype: None

        """
        _BRepMesh.BRepMesh_WireChecker_swiginit(self, _BRepMesh.new_BRepMesh_WireChecker(*args))

    def ReCompute(self, *args) -> "void":
        """
        * Recompute data using parameters passed in constructor. @param[out] theClassifier Classifier to be updated using calculated data.

        :param theClassifier:
        :type theClassifier: BRepMesh::HClassifier &
        :rtype: None

        """
        return _BRepMesh.BRepMesh_WireChecker_ReCompute(self, *args)


    def Status(self, *args) -> "BRepMesh_Status":
        """
        * Returns status of the check.

        :rtype: inline BRepMesh_Status

        """
        return _BRepMesh.BRepMesh_WireChecker_Status(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_WireChecker
BRepMesh_WireChecker.ReCompute = new_instancemethod(_BRepMesh.BRepMesh_WireChecker_ReCompute, None, BRepMesh_WireChecker)
BRepMesh_WireChecker.Status = new_instancemethod(_BRepMesh.BRepMesh_WireChecker_Status, None, BRepMesh_WireChecker)
BRepMesh_WireChecker_swigregister = _BRepMesh.BRepMesh_WireChecker_swigregister
BRepMesh_WireChecker_swigregister(BRepMesh_WireChecker)

class BRepMesh_Edge(BRepMesh_OrientedEdge):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Default constructor.

        :rtype: None

        * Constructs a link between two vertices.

        :param theFirstNode:
        :type theFirstNode: int
        :param theLastNode:
        :type theLastNode: int
        :param theMovability:
        :type theMovability: BRepMesh_DegreeOfFreedom
        :rtype: None

        """
        _BRepMesh.BRepMesh_Edge_swiginit(self, _BRepMesh.new_BRepMesh_Edge(*args))

    def Movability(self, *args) -> "BRepMesh_DegreeOfFreedom":
        """
        * Returns movability flag of the Link.

        :rtype: inline BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Edge_Movability(self, *args)


    def SetMovability(self, *args) -> "void":
        """
        * Sets movability flag of the Link. @param theMovability flag to be set.

        :param theMovability:
        :type theMovability: BRepMesh_DegreeOfFreedom
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_Edge_SetMovability(self, *args)


    def IsSameOrientation(self, *args) -> "Standard_Boolean":
        """
        * Checks if the given edge and this one have the same orientation. @param theOther edge to be checked against this one. etrun True if edges have the same orientation, False if not.

        :param theOther:
        :type theOther: BRepMesh_Edge &
        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_Edge_IsSameOrientation(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Checks for equality with another edge. @param theOther edge to be checked against this one. returns True if equal, False if not.

        :param theOther:
        :type theOther: BRepMesh_Edge &
        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_Edge_IsEqual(self, *args)


    def __eq__(self,right):
        try:
            return self.__eq_wrapper__(right)
        except:
            return False


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Edge
BRepMesh_Edge.Movability = new_instancemethod(_BRepMesh.BRepMesh_Edge_Movability, None, BRepMesh_Edge)
BRepMesh_Edge.SetMovability = new_instancemethod(_BRepMesh.BRepMesh_Edge_SetMovability, None, BRepMesh_Edge)
BRepMesh_Edge.IsSameOrientation = new_instancemethod(_BRepMesh.BRepMesh_Edge_IsSameOrientation, None, BRepMesh_Edge)
BRepMesh_Edge.IsEqual = new_instancemethod(_BRepMesh.BRepMesh_Edge_IsEqual, None, BRepMesh_Edge)
BRepMesh_Edge.__eq_wrapper__ = new_instancemethod(_BRepMesh.BRepMesh_Edge___eq_wrapper__, None, BRepMesh_Edge)
BRepMesh_Edge_swigregister = _BRepMesh.BRepMesh_Edge_swigregister
BRepMesh_Edge_swigregister(BRepMesh_Edge)

class BRepMesh_IncrementalMesh(BRepMesh_DiscretRoot):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * @name mesher API Default constructor

        :rtype: None

        * Constructor. Automatically calls method Perform. @param theShape shape to be meshed. @param theLinDeflection linear deflection. @param isRelative if True deflection used for discretization of each edge will be <theLinDeflection> * <size of edge>. Deflection used for the faces will be the maximum deflection of their edges. @param theAngDeflection angular deflection. @param isInParallel if True shape will be meshed in parallel.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theLinDeflection:
        :type theLinDeflection: float
        :param isRelative: default value is Standard_False
        :type isRelative: bool
        :param theAngDeflection: default value is 0.5
        :type theAngDeflection: float
        :param isInParallel: default value is Standard_False
        :type isInParallel: bool
        :rtype: None

        """
        _BRepMesh.BRepMesh_IncrementalMesh_swiginit(self, _BRepMesh.new_BRepMesh_IncrementalMesh(*args))

    def SetRelative(self, *args) -> "void":
        """
        * @name accessing to parameters. Enables using relative deflection. @param isRelative if True deflection used for discretization of each edge will be <theLinDeflection> * <size of edge>. Deflection used for the faces will be the maximum deflection of their edges.

        :param isRelative:
        :type isRelative: bool
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_SetRelative(self, *args)


    def IsRelative(self, *args) -> "Standard_Boolean":
        """
        * Returns relative deflection flag.

        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_IsRelative(self, *args)


    def IsModified(self, *args) -> "Standard_Boolean":
        """
        * Returns modified flag.

        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_IsModified(self, *args)


    def GetStatusFlags(self, *args) -> "Standard_Integer":
        """
        * Returns accumulated status flags faced during meshing.

        :rtype: inline int

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_GetStatusFlags(self, *args)


    def SetParallel(self, *args) -> "void":
        """
        * Request algorithm to launch in multiple threads to improve performance.

        :param isInParallel:
        :type isInParallel: bool
        :rtype: inline void

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_SetParallel(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * Returns the multi-threading usage flag.

        :rtype: inline bool

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_IsParallel(self, *args)


    def Discret(*args) -> "Standard_Integer":
        """
        * @name plugin API Plugin interface for the Mesh Factories. Initializes meshing algorithm with the given parameters. @param theShape shape to be meshed. @param theLinDeflection linear deflection. @param theAngDeflection angular deflection. @param[out] theAlgo pointer to initialized algorithm.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theLinDeflection:
        :type theLinDeflection: float
        :param theAngDeflection:
        :type theAngDeflection: float
        :param theAlgo:
        :type theAlgo: BRepMesh_DiscretRoot * &
        :rtype: int

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_Discret(*args)

    Discret = staticmethod(Discret)

    def IsParallelDefault(*args) -> "Standard_Boolean":
        """
        * Returns multi-threading usage flag set by default in Discret() static method (thus applied only to Mesh Factories).

        :rtype: bool

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_IsParallelDefault(*args)

    IsParallelDefault = staticmethod(IsParallelDefault)

    def SetParallelDefault(*args) -> "void":
        """
        * Setup multi-threading usage flag set by default in Discret() static method (thus applied only to Mesh Factories).

        :param isInParallel:
        :type isInParallel: bool
        :rtype: void

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_SetParallelDefault(*args)

    SetParallelDefault = staticmethod(SetParallelDefault)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepMesh_IncrementalMesh(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_IncrementalMesh
BRepMesh_IncrementalMesh.SetRelative = new_instancemethod(_BRepMesh.BRepMesh_IncrementalMesh_SetRelative, None, BRepMesh_IncrementalMesh)
BRepMesh_IncrementalMesh.IsRelative = new_instancemethod(_BRepMesh.BRepMesh_IncrementalMesh_IsRelative, None, BRepMesh_IncrementalMesh)
BRepMesh_IncrementalMesh.IsModified = new_instancemethod(_BRepMesh.BRepMesh_IncrementalMesh_IsModified, None, BRepMesh_IncrementalMesh)
BRepMesh_IncrementalMesh.GetStatusFlags = new_instancemethod(_BRepMesh.BRepMesh_IncrementalMesh_GetStatusFlags, None, BRepMesh_IncrementalMesh)
BRepMesh_IncrementalMesh.SetParallel = new_instancemethod(_BRepMesh.BRepMesh_IncrementalMesh_SetParallel, None, BRepMesh_IncrementalMesh)
BRepMesh_IncrementalMesh.IsParallel = new_instancemethod(_BRepMesh.BRepMesh_IncrementalMesh_IsParallel, None, BRepMesh_IncrementalMesh)
BRepMesh_IncrementalMesh_swigregister = _BRepMesh.BRepMesh_IncrementalMesh_swigregister
BRepMesh_IncrementalMesh_swigregister(BRepMesh_IncrementalMesh)

def BRepMesh_IncrementalMesh_Discret(*args) -> "Standard_Integer":
    """
    * @name plugin API Plugin interface for the Mesh Factories. Initializes meshing algorithm with the given parameters. @param theShape shape to be meshed. @param theLinDeflection linear deflection. @param theAngDeflection angular deflection. @param[out] theAlgo pointer to initialized algorithm.

    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theLinDeflection:
    :type theLinDeflection: float
    :param theAngDeflection:
    :type theAngDeflection: float
    :param theAlgo:
    :type theAlgo: BRepMesh_DiscretRoot * &
    :rtype: int

    """
    return _BRepMesh.BRepMesh_IncrementalMesh_Discret(*args)

def BRepMesh_IncrementalMesh_IsParallelDefault(*args) -> "Standard_Boolean":
    """
    * Returns multi-threading usage flag set by default in Discret() static method (thus applied only to Mesh Factories).

    :rtype: bool

    """
    return _BRepMesh.BRepMesh_IncrementalMesh_IsParallelDefault(*args)

def BRepMesh_IncrementalMesh_SetParallelDefault(*args) -> "void":
    """
    * Setup multi-threading usage flag set by default in Discret() static method (thus applied only to Mesh Factories).

    :param isInParallel:
    :type isInParallel: bool
    :rtype: void

    """
    return _BRepMesh.BRepMesh_IncrementalMesh_SetParallelDefault(*args)

class Handle_BRepMesh_IncrementalMesh(Handle_BRepMesh_DiscretRoot):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _BRepMesh.Handle_BRepMesh_IncrementalMesh_swiginit(self, _BRepMesh.new_Handle_BRepMesh_IncrementalMesh(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_IncrementalMesh_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_IncrementalMesh
Handle_BRepMesh_IncrementalMesh.Nullify = new_instancemethod(_BRepMesh.Handle_BRepMesh_IncrementalMesh_Nullify, None, Handle_BRepMesh_IncrementalMesh)
Handle_BRepMesh_IncrementalMesh.IsNull = new_instancemethod(_BRepMesh.Handle_BRepMesh_IncrementalMesh_IsNull, None, Handle_BRepMesh_IncrementalMesh)
Handle_BRepMesh_IncrementalMesh._get_reference = new_instancemethod(_BRepMesh.Handle_BRepMesh_IncrementalMesh__get_reference, None, Handle_BRepMesh_IncrementalMesh)
Handle_BRepMesh_IncrementalMesh_swigregister = _BRepMesh.Handle_BRepMesh_IncrementalMesh_swigregister
Handle_BRepMesh_IncrementalMesh_swigregister(Handle_BRepMesh_IncrementalMesh)

def Handle_BRepMesh_IncrementalMesh_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_BRepMesh_IncrementalMesh const":
    return _BRepMesh.Handle_BRepMesh_IncrementalMesh_DownCast(AnObject)
Handle_BRepMesh_IncrementalMesh_DownCast = _BRepMesh.Handle_BRepMesh_IncrementalMesh_DownCast



