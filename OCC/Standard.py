# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Standard.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Standard')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Standard')
    _Standard = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Standard', [dirname(__file__)])
        except ImportError:
            import _Standard
            return _Standard
        try:
            _mod = imp.load_module('_Standard', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Standard = swig_import_helper()
    del swig_import_helper
else:
    import _Standard
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Standard.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Standard.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Standard.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Standard.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Standard.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Standard.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Standard.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Standard.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Standard.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Standard.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Standard.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Standard.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Standard.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Standard.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Standard.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Standard.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Standard.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Standard.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string


def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

Standard_HandlerVoid = _Standard.Standard_HandlerVoid
Standard_HandlerJumped = _Standard.Standard_HandlerJumped
Standard_HandlerProcessed = _Standard.Standard_HandlerProcessed
Standard_Void = _Standard.Standard_Void
Standard_Char = _Standard.Standard_Char
Standard_ExtChar = _Standard.Standard_ExtChar
Standard_LongInt = _Standard.Standard_LongInt
Standard_Bool = _Standard.Standard_Bool
Standard_Float = _Standard.Standard_Float
Standard_LongDouble = _Standard.Standard_LongDouble
Standard_String = _Standard.Standard_String
Standard_EString = _Standard.Standard_EString
Standard_EntryAddress = _Standard.Standard_EntryAddress
Standard_DataAddress = _Standard.Standard_DataAddress
Standard_EngineHandle = _Standard.Standard_EngineHandle
Standard_Long64 = _Standard.Standard_Long64
Standard_Array = _Standard.Standard_Array
Standard_IsUnKnown = _Standard.Standard_IsUnKnown
Standard_IsClass = _Standard.Standard_IsClass
Standard_IsEnumeration = _Standard.Standard_IsEnumeration
Standard_IsPrimitive = _Standard.Standard_IsPrimitive
Standard_IsImported = _Standard.Standard_IsImported
Standard_IsPackage = _Standard.Standard_IsPackage
Standard_IsNothing = _Standard.Standard_IsNothing
Standard_IsAddress = _Standard.Standard_IsAddress
Standard_IsTransient = _Standard.Standard_IsTransient
Standard_IsPersistent = _Standard.Standard_IsPersistent
Standard_IsNotLoaded = _Standard.Standard_IsNotLoaded
class standard(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Allocate(*args) -> "Standard_Address":
        """
        * Allocates memory blocks aSize - bytes to allocate

        :param aSize:
        :type aSize: Standard_Size
        :rtype: Standard_Address

        """
        return _Standard.standard_Allocate(*args)

    Allocate = staticmethod(Allocate)

    def Reallocate(*args) -> "Standard_Address":
        """
        * Reallocates memory blocks aStorage - previously allocated memory block aNewSize - new size in bytes

        :param aStorage:
        :type aStorage: Standard_Address
        :param aNewSize:
        :type aNewSize: Standard_Size
        :rtype: Standard_Address

        """
        return _Standard.standard_Reallocate(*args)

    Reallocate = staticmethod(Reallocate)

    def AllocateAligned(*args) -> "Standard_Address":
        """
        * Allocates aligned memory blocks. Should be used with CPU instructions which require specific alignment. For example: SSE requires 16 bytes, AVX requires 32 bytes. @param theSize bytes to allocate @param theAlign alignment in bytes

        :param theSize:
        :type theSize: Standard_Size
        :param theAlign:
        :type theAlign: Standard_Size
        :rtype: Standard_Address

        """
        return _Standard.standard_AllocateAligned(*args)

    AllocateAligned = staticmethod(AllocateAligned)

    def Purge(*args) -> "Standard_Integer":
        """
        * Deallocates the storage retained on the free list and clears the list. Returns non-zero if some memory has been actually freed.

        :rtype: int

        """
        return _Standard.standard_Purge(*args)

    Purge = staticmethod(Purge)

    __repr__ = _dumps_object


    def __init__(self):
        _Standard.standard_swiginit(self, _Standard.new_standard())
    __swig_destroy__ = _Standard.delete_standard
standard_swigregister = _Standard.standard_swigregister
standard_swigregister(standard)

def standard_Allocate(*args) -> "Standard_Address":
    """
    * Allocates memory blocks aSize - bytes to allocate

    :param aSize:
    :type aSize: Standard_Size
    :rtype: Standard_Address

    """
    return _Standard.standard_Allocate(*args)

def standard_Reallocate(*args) -> "Standard_Address":
    """
    * Reallocates memory blocks aStorage - previously allocated memory block aNewSize - new size in bytes

    :param aStorage:
    :type aStorage: Standard_Address
    :param aNewSize:
    :type aNewSize: Standard_Size
    :rtype: Standard_Address

    """
    return _Standard.standard_Reallocate(*args)

def standard_AllocateAligned(*args) -> "Standard_Address":
    """
    * Allocates aligned memory blocks. Should be used with CPU instructions which require specific alignment. For example: SSE requires 16 bytes, AVX requires 32 bytes. @param theSize bytes to allocate @param theAlign alignment in bytes

    :param theSize:
    :type theSize: Standard_Size
    :param theAlign:
    :type theAlign: Standard_Size
    :rtype: Standard_Address

    """
    return _Standard.standard_AllocateAligned(*args)

def standard_Purge(*args) -> "Standard_Integer":
    """
    * Deallocates the storage retained on the free list and clears the list. Returns non-zero if some memory has been actually freed.

    :rtype: int

    """
    return _Standard.standard_Purge(*args)

class Standard_ErrorHandler(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Create a ErrorHandler (to be used with try{}catch(){}). It uses the 'setjmp' and 'longjmp' routines.

        :rtype: None

        """
        _Standard.Standard_ErrorHandler_swiginit(self, _Standard.new_Standard_ErrorHandler(*args))

    def Destroy(self, *args) -> "void":
        """
        * Unlinks and checks if there is a raised exception.

        :rtype: None

        """
        return _Standard.Standard_ErrorHandler_Destroy(self, *args)


    def Unlink(self, *args) -> "void":
        """
        * Removes handler from the handlers list

        :rtype: None

        """
        return _Standard.Standard_ErrorHandler_Unlink(self, *args)


    def Catches(self, *args) -> "Standard_Boolean":
        """
        * Returns 'True' if the caught exception has the same type or inherits from 'aType'

        :param aType:
        :type aType: Handle_Standard_Type &
        :rtype: bool

        """
        return _Standard.Standard_ErrorHandler_Catches(self, *args)


    def Label(self, *args) -> "Standard_JmpBuf &":
        """
        * Returns label for jump

        :rtype: Standard_JmpBuf

        """
        return _Standard.Standard_ErrorHandler_Label(self, *args)


    def Error(self, *args) -> "Handle_Standard_Failure":
        """
        * Returns the current Error.

        :rtype: Handle_Standard_Failure

        """
        return _Standard.Standard_ErrorHandler_Error(self, *args)


    def LastCaughtError(*args) -> "Handle_Standard_Failure":
        """
        * Returns the caught exception.

        :rtype: Handle_Standard_Failure

        """
        return _Standard.Standard_ErrorHandler_LastCaughtError(*args)

    LastCaughtError = staticmethod(LastCaughtError)

    def IsInTryBlock(*args) -> "Standard_Boolean":
        """
        * Test if the code is currently running in a try block

        :rtype: bool

        """
        return _Standard.Standard_ErrorHandler_IsInTryBlock(*args)

    IsInTryBlock = staticmethod(IsInTryBlock)

    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_ErrorHandler
Standard_ErrorHandler.Destroy = new_instancemethod(_Standard.Standard_ErrorHandler_Destroy, None, Standard_ErrorHandler)
Standard_ErrorHandler.Unlink = new_instancemethod(_Standard.Standard_ErrorHandler_Unlink, None, Standard_ErrorHandler)
Standard_ErrorHandler.Catches = new_instancemethod(_Standard.Standard_ErrorHandler_Catches, None, Standard_ErrorHandler)
Standard_ErrorHandler.Label = new_instancemethod(_Standard.Standard_ErrorHandler_Label, None, Standard_ErrorHandler)
Standard_ErrorHandler.Error = new_instancemethod(_Standard.Standard_ErrorHandler_Error, None, Standard_ErrorHandler)
Standard_ErrorHandler_swigregister = _Standard.Standard_ErrorHandler_swigregister
Standard_ErrorHandler_swigregister(Standard_ErrorHandler)

def Standard_ErrorHandler_LastCaughtError(*args) -> "Handle_Standard_Failure":
    """
    * Returns the caught exception.

    :rtype: Handle_Standard_Failure

    """
    return _Standard.Standard_ErrorHandler_LastCaughtError(*args)

def Standard_ErrorHandler_IsInTryBlock(*args) -> "Standard_Boolean":
    """
    * Test if the code is currently running in a try block

    :rtype: bool

    """
    return _Standard.Standard_ErrorHandler_IsInTryBlock(*args)

class Standard_ErrorHandlerCallback(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def DestroyCallback(self, *args) -> "void":
        """
        * The callback function to perform necessary callback action. Called by the exception handler when it is being destroyed but still has this callback registered.

        :rtype: void

        """
        return _Standard.Standard_ErrorHandlerCallback_DestroyCallback(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_ErrorHandlerCallback
Standard_ErrorHandlerCallback.DestroyCallback = new_instancemethod(_Standard.Standard_ErrorHandlerCallback_DestroyCallback, None, Standard_ErrorHandlerCallback)
Standard_ErrorHandlerCallback_swigregister = _Standard.Standard_ErrorHandlerCallback_swigregister
Standard_ErrorHandlerCallback_swigregister(Standard_ErrorHandlerCallback)

class Standard_GUID(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        * build a GUID from an ascii string with the following format: Length : 36 char '00000000-0000-0000-0000-000000000000'

        :param aGuid:
        :type aGuid: char *
        :rtype: None

        * build a GUID from an unicode string with the following format: //! '00000000-0000-0000-0000-000000000000'

        :param aGuid:
        :type aGuid: Standard_ExtString
        :rtype: None

        :param a32b:
        :type a32b: int
        :param a16b1:
        :type a16b1: Standard_ExtCharacter
        :param a16b2:
        :type a16b2: Standard_ExtCharacter
        :param a16b3:
        :type a16b3: Standard_ExtCharacter
        :param a8b1:
        :type a8b1: Standard_Byte
        :param a8b2:
        :type a8b2: Standard_Byte
        :param a8b3:
        :type a8b3: Standard_Byte
        :param a8b4:
        :type a8b4: Standard_Byte
        :param a8b5:
        :type a8b5: Standard_Byte
        :param a8b6:
        :type a8b6: Standard_Byte
        :rtype: None

        :param aGuid:
        :type aGuid: Standard_UUID &
        :rtype: None

        :param aGuid:
        :type aGuid: Standard_GUID &
        :rtype: None

        """
        _Standard.Standard_GUID_swiginit(self, _Standard.new_Standard_GUID(*args))

    def ToUUID(self, *args) -> "Standard_UUID":
        """
        :rtype: Standard_UUID

        """
        return _Standard.Standard_GUID_ToUUID(self, *args)


    def ToCString(self, *args) -> "void":
        """
        * translate the GUID into ascii string the aStrGuid is allocated by user. the guid have the following format: //! '00000000-0000-0000-0000-000000000000'

        :param aStrGuid:
        :type aStrGuid: Standard_PCharacter
        :rtype: None

        """
        return _Standard.Standard_GUID_ToCString(self, *args)


    def ToExtString(self, *args) -> "void":
        """
        * translate the GUID into unicode string the aStrGuid is allocated by user. the guid have the following format: //! '00000000-0000-0000-0000-000000000000'

        :param aStrGuid:
        :type aStrGuid: Standard_PExtCharacter
        :rtype: None

        """
        return _Standard.Standard_GUID_ToExtString(self, *args)


    def IsSame(self, *args) -> "Standard_Boolean":
        """
        :param uid:
        :type uid: Standard_GUID &
        :rtype: bool

        """
        return _Standard.Standard_GUID_IsSame(self, *args)


    def __eq__(self,right):
        try:
            return self.__eq_wrapper__(right)
        except:
            return False


    def IsNotSame(self, *args) -> "Standard_Boolean":
        """
        :param uid:
        :type uid: Standard_GUID &
        :rtype: bool

        """
        return _Standard.Standard_GUID_IsNotSame(self, *args)


    def __ne__(self,right):
        try:
            return self.__ne_wrapper__(right)
        except:
            return True


    def Assign(self, *args) -> "void":
        """
        :param uid:
        :type uid: Standard_GUID &
        :rtype: None

        :param uid:
        :type uid: Standard_UUID &
        :rtype: None

        """
        return _Standard.Standard_GUID_Assign(self, *args)


    def Set(self, *args) -> "void":
        """
        :param uid:
        :type uid: Standard_GUID &
        :rtype: None

        :param uid:
        :type uid: Standard_UUID &
        :rtype: None

        """
        return _Standard.Standard_GUID_Set(self, *args)


    def ShallowDumpToString(self) -> "std::string":
        """ShallowDumpToString(Standard_GUID self) -> std::string"""
        return _Standard.Standard_GUID_ShallowDumpToString(self)


    def CheckGUIDFormat(*args) -> "Standard_Boolean":
        """
        * Check the format of a GUID string. It checks the size, the position of the '-' and the correct size of fields.

        :param aGuid:
        :type aGuid: char *
        :rtype: bool

        """
        return _Standard.Standard_GUID_CheckGUIDFormat(*args)

    CheckGUIDFormat = staticmethod(CheckGUIDFormat)

    def Hash(self, *args) -> "Standard_Integer":
        """
        * Hash function for GUID.

        :param Upper:
        :type Upper: int
        :rtype: int

        """
        return _Standard.Standard_GUID_Hash(self, *args)


    def HashCode(*args) -> "Standard_Integer":
        """
        * H method used by collections.

        :param aguid:
        :type aguid: Standard_GUID &
        :param Upper:
        :type Upper: int
        :rtype: int

        """
        return _Standard.Standard_GUID_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        * Returns True when the two GUID are the same.

        :param string1:
        :type string1: Standard_GUID &
        :param string2:
        :type string2: Standard_GUID &
        :rtype: bool

        """
        return _Standard.Standard_GUID_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def _CSFDB_GetStandard_GUIDmy32b(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy32b(self, *args)


    def _CSFDB_SetStandard_GUIDmy32b(self, *args) -> "void":
        """
        :param p:
        :type p: int
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy32b(self, *args)


    def _CSFDB_GetStandard_GUIDmy16b1(self, *args) -> "Standard_ExtCharacter":
        """
        :rtype: Standard_ExtCharacter

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy16b1(self, *args)


    def _CSFDB_SetStandard_GUIDmy16b1(self, *args) -> "void":
        """
        :param p:
        :type p: Standard_ExtCharacter
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy16b1(self, *args)


    def _CSFDB_GetStandard_GUIDmy16b2(self, *args) -> "Standard_ExtCharacter":
        """
        :rtype: Standard_ExtCharacter

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy16b2(self, *args)


    def _CSFDB_SetStandard_GUIDmy16b2(self, *args) -> "void":
        """
        :param p:
        :type p: Standard_ExtCharacter
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy16b2(self, *args)


    def _CSFDB_GetStandard_GUIDmy16b3(self, *args) -> "Standard_ExtCharacter":
        """
        :rtype: Standard_ExtCharacter

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy16b3(self, *args)


    def _CSFDB_SetStandard_GUIDmy16b3(self, *args) -> "void":
        """
        :param p:
        :type p: Standard_ExtCharacter
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy16b3(self, *args)


    def _CSFDB_GetStandard_GUIDmy8b1(self, *args) -> "Standard_Byte":
        """
        :rtype: Standard_Byte

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b1(self, *args)


    def _CSFDB_SetStandard_GUIDmy8b1(self, *args) -> "void":
        """
        :param p:
        :type p: Standard_Byte
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b1(self, *args)


    def _CSFDB_GetStandard_GUIDmy8b2(self, *args) -> "Standard_Byte":
        """
        :rtype: Standard_Byte

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b2(self, *args)


    def _CSFDB_SetStandard_GUIDmy8b2(self, *args) -> "void":
        """
        :param p:
        :type p: Standard_Byte
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b2(self, *args)


    def _CSFDB_GetStandard_GUIDmy8b3(self, *args) -> "Standard_Byte":
        """
        :rtype: Standard_Byte

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b3(self, *args)


    def _CSFDB_SetStandard_GUIDmy8b3(self, *args) -> "void":
        """
        :param p:
        :type p: Standard_Byte
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b3(self, *args)


    def _CSFDB_GetStandard_GUIDmy8b4(self, *args) -> "Standard_Byte":
        """
        :rtype: Standard_Byte

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b4(self, *args)


    def _CSFDB_SetStandard_GUIDmy8b4(self, *args) -> "void":
        """
        :param p:
        :type p: Standard_Byte
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b4(self, *args)


    def _CSFDB_GetStandard_GUIDmy8b5(self, *args) -> "Standard_Byte":
        """
        :rtype: Standard_Byte

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b5(self, *args)


    def _CSFDB_SetStandard_GUIDmy8b5(self, *args) -> "void":
        """
        :param p:
        :type p: Standard_Byte
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b5(self, *args)


    def _CSFDB_GetStandard_GUIDmy8b6(self, *args) -> "Standard_Byte":
        """
        :rtype: Standard_Byte

        """
        return _Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b6(self, *args)


    def _CSFDB_SetStandard_GUIDmy8b6(self, *args) -> "void":
        """
        :param p:
        :type p: Standard_Byte
        :rtype: None

        """
        return _Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b6(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_GUID
Standard_GUID.ToUUID = new_instancemethod(_Standard.Standard_GUID_ToUUID, None, Standard_GUID)
Standard_GUID.ToCString = new_instancemethod(_Standard.Standard_GUID_ToCString, None, Standard_GUID)
Standard_GUID.ToExtString = new_instancemethod(_Standard.Standard_GUID_ToExtString, None, Standard_GUID)
Standard_GUID.IsSame = new_instancemethod(_Standard.Standard_GUID_IsSame, None, Standard_GUID)
Standard_GUID.__eq_wrapper__ = new_instancemethod(_Standard.Standard_GUID___eq_wrapper__, None, Standard_GUID)
Standard_GUID.IsNotSame = new_instancemethod(_Standard.Standard_GUID_IsNotSame, None, Standard_GUID)
Standard_GUID.__ne_wrapper__ = new_instancemethod(_Standard.Standard_GUID___ne_wrapper__, None, Standard_GUID)
Standard_GUID.Assign = new_instancemethod(_Standard.Standard_GUID_Assign, None, Standard_GUID)
Standard_GUID.Set = new_instancemethod(_Standard.Standard_GUID_Set, None, Standard_GUID)
Standard_GUID.ShallowDumpToString = new_instancemethod(_Standard.Standard_GUID_ShallowDumpToString, None, Standard_GUID)
Standard_GUID.Hash = new_instancemethod(_Standard.Standard_GUID_Hash, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy32b = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy32b, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy32b = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy32b, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy16b1 = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy16b1, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy16b1 = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy16b1, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy16b2 = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy16b2, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy16b2 = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy16b2, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy16b3 = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy16b3, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy16b3 = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy16b3, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy8b1 = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b1, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy8b1 = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b1, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy8b2 = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b2, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy8b2 = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b2, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy8b3 = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b3, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy8b3 = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b3, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy8b4 = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b4, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy8b4 = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b4, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy8b5 = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b5, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy8b5 = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b5, None, Standard_GUID)
Standard_GUID._CSFDB_GetStandard_GUIDmy8b6 = new_instancemethod(_Standard.Standard_GUID__CSFDB_GetStandard_GUIDmy8b6, None, Standard_GUID)
Standard_GUID._CSFDB_SetStandard_GUIDmy8b6 = new_instancemethod(_Standard.Standard_GUID__CSFDB_SetStandard_GUIDmy8b6, None, Standard_GUID)
Standard_GUID_swigregister = _Standard.Standard_GUID_swigregister
Standard_GUID_swigregister(Standard_GUID)

def Standard_GUID_CheckGUIDFormat(*args) -> "Standard_Boolean":
    """
    * Check the format of a GUID string. It checks the size, the position of the '-' and the correct size of fields.

    :param aGuid:
    :type aGuid: char *
    :rtype: bool

    """
    return _Standard.Standard_GUID_CheckGUIDFormat(*args)

def Standard_GUID_HashCode(*args) -> "Standard_Integer":
    """
    * H method used by collections.

    :param aguid:
    :type aguid: Standard_GUID &
    :param Upper:
    :type Upper: int
    :rtype: int

    """
    return _Standard.Standard_GUID_HashCode(*args)

def Standard_GUID_IsEqual(*args) -> "Standard_Boolean":
    """
    * Returns True when the two GUID are the same.

    :param string1:
    :type string1: Standard_GUID &
    :param string2:
    :type string2: Standard_GUID &
    :rtype: bool

    """
    return _Standard.Standard_GUID_IsEqual(*args)

class Standard_MMgrRoot(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Allocate(self, *args) -> "Standard_Address":
        """
        * Allocate specified number of bytes. The actually allocated space should be rounded up to double word size (4 bytes), as this is expected by implementation of some classes in OCC (e.g. TCollection_AsciiString)

        :param theSize:
        :type theSize: Standard_Size
        :rtype: Standard_Address

        """
        return _Standard.Standard_MMgrRoot_Allocate(self, *args)


    def Reallocate(self, *args) -> "Standard_Address":
        """
        * Reallocate previously allocated memory to contain at least theSize bytes. In case of success, new pointer is returned.

        :param thePtr:
        :type thePtr: Standard_Address
        :param theSize:
        :type theSize: Standard_Size
        :rtype: Standard_Address

        """
        return _Standard.Standard_MMgrRoot_Reallocate(self, *args)


    def Free(self, *args) -> "void":
        """
        * Frees previously allocated memory at specified address.

        :param thePtr:
        :type thePtr: Standard_Address
        :rtype: void

        """
        return _Standard.Standard_MMgrRoot_Free(self, *args)


    def Purge(self, *args) -> "Standard_Integer":
        """
        * Purge internally cached unused memory blocks (if any) by releasing them to the operating system. Must return non-zero if some memory has been actually released, or zero otherwise. If option isDestroyed is True, this means that memory manager is not expected to be used any more; note however that in general case it is still possible to have calls to that instance of memory manager after this (e.g. to free memory of static objects in OCC). Thus this option should command the memory manager to release any cached memory to the system and not cache any more, but still remain operable... //! Default implementation does nothing and returns 0.

        :param isDestroyed: default value is Standard_False
        :type isDestroyed: bool
        :rtype: int

        """
        return _Standard.Standard_MMgrRoot_Purge(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_MMgrRoot
Standard_MMgrRoot.Allocate = new_instancemethod(_Standard.Standard_MMgrRoot_Allocate, None, Standard_MMgrRoot)
Standard_MMgrRoot.Reallocate = new_instancemethod(_Standard.Standard_MMgrRoot_Reallocate, None, Standard_MMgrRoot)
Standard_MMgrRoot.Free = new_instancemethod(_Standard.Standard_MMgrRoot_Free, None, Standard_MMgrRoot)
Standard_MMgrRoot.Purge = new_instancemethod(_Standard.Standard_MMgrRoot_Purge, None, Standard_MMgrRoot)
Standard_MMgrRoot_swigregister = _Standard.Standard_MMgrRoot_swigregister
Standard_MMgrRoot_swigregister(Standard_MMgrRoot)

class Standard_Storable(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Delete(self, *args) -> "void":
        """
        :rtype: void

        """
        return _Standard.Standard_Storable_Delete(self, *args)


    def HashCode(self, *args) -> "Standard_Integer":
        """
        * Returns a hashed value denoting <self>. This value is in the range 1..<Upper>.

        :param Upper:
        :type Upper: int
        :rtype: int

        """
        return _Standard.Standard_Storable_HashCode(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the direct contents of <self> and <Other> are memberwise equal.

        :param Other:
        :type Other: Standard_Storable &
        :rtype: bool

        """
        return _Standard.Standard_Storable_IsEqual(self, *args)


    def __eq__(self,right):
        try:
            return self.__eq_wrapper__(right)
        except:
            return False


    def IsSimilar(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the Deep contents of <self> and <Other> are memberwise equal.

        :param Other:
        :type Other: Standard_Storable &
        :rtype: bool

        """
        return _Standard.Standard_Storable_IsSimilar(self, *args)


    __repr__ = _dumps_object


    def __init__(self):
        _Standard.Standard_Storable_swiginit(self, _Standard.new_Standard_Storable())
    __swig_destroy__ = _Standard.delete_Standard_Storable
Standard_Storable.Delete = new_instancemethod(_Standard.Standard_Storable_Delete, None, Standard_Storable)
Standard_Storable.HashCode = new_instancemethod(_Standard.Standard_Storable_HashCode, None, Standard_Storable)
Standard_Storable.__hash__ = new_instancemethod(_Standard.Standard_Storable___hash__, None, Standard_Storable)
Standard_Storable.IsEqual = new_instancemethod(_Standard.Standard_Storable_IsEqual, None, Standard_Storable)
Standard_Storable.__eq_wrapper__ = new_instancemethod(_Standard.Standard_Storable___eq_wrapper__, None, Standard_Storable)
Standard_Storable.IsSimilar = new_instancemethod(_Standard.Standard_Storable_IsSimilar, None, Standard_Storable)
Standard_Storable_swigregister = _Standard.Standard_Storable_swigregister
Standard_Storable_swigregister(Standard_Storable)

class Standard_Transient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty constructor

        :rtype: None

        * Copy constructor -- does nothing

        :param &:
        :type &: Standard_Transient
        :rtype: None

        """
        _Standard.Standard_Transient_swiginit(self, _Standard.new_Standard_Transient(*args))

    def Set(self, *args) -> "Standard_Transient &":
        """
        * Assignment operator, needed to avoid copying reference counter

        :param &:
        :type &: Standard_Transient
        :rtype: Standard_Transient

        """
        return _Standard.Standard_Transient_Set(self, *args)


    def Delete(self, *args) -> "void":
        """
        * Memory deallocator for transient classes

        :rtype: void

        """
        return _Standard.Standard_Transient_Delete(self, *args)


    def DynamicType(self, *args) -> "Handle_Standard_Type":
        """
        * Returns a type information object about this object.

        :rtype: Handle_Standard_Type

        """
        return _Standard.Standard_Transient_DynamicType(self, *args)


    def IsInstance(self, *args) -> "Standard_Boolean":
        """
        * Returns a true value if this is an instance of Type.

        :param theType:
        :type theType: Handle_Standard_Type &
        :rtype: bool

        * Returns a true value if this is an instance of TypeName.

        :param theTypeName:
        :type theTypeName: char *
        :rtype: bool

        """
        return _Standard.Standard_Transient_IsInstance(self, *args)


    def IsKind(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this is an instance of Type or an instance of any class that inherits from Type. Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :param theType:
        :type theType: Handle_Standard_Type &
        :rtype: bool

        * Returns true if this is an instance of TypeName or an instance of any class that inherits from TypeName. Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :param theTypeName:
        :type theTypeName: char *
        :rtype: bool

        """
        return _Standard.Standard_Transient_IsKind(self, *args)


    def This(self, *args) -> "Handle_Standard_Transient":
        """
        * Returns a Handle which references this object. Must never be called to objects created in stack.

        :rtype: Handle_Standard_Transient

        """
        return _Standard.Standard_Transient_This(self, *args)


    def GetRefCount(self, *args) -> "Standard_Integer":
        """
        * Get the reference counter of this object.

        :rtype: int

        """
        return _Standard.Standard_Transient_GetRefCount(self, *args)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Standard_Transient(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_Transient
Standard_Transient.Set = new_instancemethod(_Standard.Standard_Transient_Set, None, Standard_Transient)
Standard_Transient.Delete = new_instancemethod(_Standard.Standard_Transient_Delete, None, Standard_Transient)
Standard_Transient.DynamicType = new_instancemethod(_Standard.Standard_Transient_DynamicType, None, Standard_Transient)
Standard_Transient.IsInstance = new_instancemethod(_Standard.Standard_Transient_IsInstance, None, Standard_Transient)
Standard_Transient.IsKind = new_instancemethod(_Standard.Standard_Transient_IsKind, None, Standard_Transient)
Standard_Transient.This = new_instancemethod(_Standard.Standard_Transient_This, None, Standard_Transient)
Standard_Transient.GetRefCount = new_instancemethod(_Standard.Standard_Transient_GetRefCount, None, Standard_Transient)
Standard_Transient_swigregister = _Standard.Standard_Transient_swigregister
Standard_Transient_swigregister(Standard_Transient)

class Handle_Standard_Transient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Standard.Handle_Standard_Transient_swiginit(self, _Standard.new_Handle_Standard_Transient(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Standard.Handle_Standard_Transient_DownCast)

    def __eq__(self,right):
        try:
            return self.__eq_wrapper__(right)
        except:
            return False


    def __ne__(self,right):
        try:
            return self.__ne_wrapper__(right)
        except:
            return True


    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _Standard.delete_Handle_Standard_Transient
Handle_Standard_Transient.Nullify = new_instancemethod(_Standard.Handle_Standard_Transient_Nullify, None, Handle_Standard_Transient)
Handle_Standard_Transient.IsNull = new_instancemethod(_Standard.Handle_Standard_Transient_IsNull, None, Handle_Standard_Transient)
Handle_Standard_Transient.__eq_wrapper__ = new_instancemethod(_Standard.Handle_Standard_Transient___eq_wrapper__, None, Handle_Standard_Transient)
Handle_Standard_Transient.__ne_wrapper__ = new_instancemethod(_Standard.Handle_Standard_Transient___ne_wrapper__, None, Handle_Standard_Transient)
Handle_Standard_Transient.DumpToString = new_instancemethod(_Standard.Handle_Standard_Transient_DumpToString, None, Handle_Standard_Transient)
Handle_Standard_Transient._get_reference = new_instancemethod(_Standard.Handle_Standard_Transient__get_reference, None, Handle_Standard_Transient)
Handle_Standard_Transient_swigregister = _Standard.Handle_Standard_Transient_swigregister
Handle_Standard_Transient_swigregister(Handle_Standard_Transient)

def Handle_Standard_Transient_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_Standard_Transient const":
    return _Standard.Handle_Standard_Transient_DownCast(AnObject)
Handle_Standard_Transient_DownCast = _Standard.Handle_Standard_Transient_DownCast

class Standard_Failure(Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a status object of type 'Failure'.

        :rtype: None

        :param f:
        :type f: Standard_Failure &
        :rtype: None

        * Creates a status object of type 'Failure'.

        :param aString:
        :type aString: char *
        :rtype: None

        """
        _Standard.Standard_Failure_swiginit(self, _Standard.new_Standard_Failure(*args))

    def Destroy(self, *args) -> "void":
        """
        :rtype: None

        """
        return _Standard.Standard_Failure_Destroy(self, *args)


    def PrintToString(self) -> "std::string":
        """PrintToString(Standard_Failure self) -> std::string"""
        return _Standard.Standard_Failure_PrintToString(self)


    def GetMessageString(self, *args) -> "char const *":
        """
        * Returns error message

        :rtype: char *

        """
        return _Standard.Standard_Failure_GetMessageString(self, *args)


    def SetMessageString(self, *args) -> "void":
        """
        * Sets error message

        :param aMessage:
        :type aMessage: char *
        :rtype: None

        """
        return _Standard.Standard_Failure_SetMessageString(self, *args)


    def NewInstance(*args) -> "Handle_Standard_Failure":
        """
        * Used to construct an instance of the exception object as a handle. Shall be used to protect against possible construction of exception object in C stack -- that is dangerous since some of methods require that object was allocated dynamically.

        :param aMessage:
        :type aMessage: char *
        :rtype: Handle_Standard_Failure

        """
        return _Standard.Standard_Failure_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def Jump(self, *args) -> "void":
        """
        * Used to throw CASCADE exception from C signal handler. On platforms that do not allow throwing C++ exceptions from this handler (e.g. Linux), uses longjump to get to the current active signal handler, and only then is converted to C++ exception.

        :rtype: None

        """
        return _Standard.Standard_Failure_Jump(self, *args)


    def Caught(*args) -> "Handle_Standard_Failure":
        """
        * Returns the last caught exception. Needed when exceptions are emulated by C longjumps, in other cases is also provided for compatibility.

        :rtype: Handle_Standard_Failure

        """
        return _Standard.Standard_Failure_Caught(*args)

    Caught = staticmethod(Caught)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Standard_Failure(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_Failure
Standard_Failure.Destroy = new_instancemethod(_Standard.Standard_Failure_Destroy, None, Standard_Failure)
Standard_Failure.PrintToString = new_instancemethod(_Standard.Standard_Failure_PrintToString, None, Standard_Failure)
Standard_Failure.GetMessageString = new_instancemethod(_Standard.Standard_Failure_GetMessageString, None, Standard_Failure)
Standard_Failure.SetMessageString = new_instancemethod(_Standard.Standard_Failure_SetMessageString, None, Standard_Failure)
Standard_Failure.Jump = new_instancemethod(_Standard.Standard_Failure_Jump, None, Standard_Failure)
Standard_Failure_swigregister = _Standard.Standard_Failure_swigregister
Standard_Failure_swigregister(Standard_Failure)

def Standard_Failure_NewInstance(*args) -> "Handle_Standard_Failure":
    """
    * Used to construct an instance of the exception object as a handle. Shall be used to protect against possible construction of exception object in C stack -- that is dangerous since some of methods require that object was allocated dynamically.

    :param aMessage:
    :type aMessage: char *
    :rtype: Handle_Standard_Failure

    """
    return _Standard.Standard_Failure_NewInstance(*args)

def Standard_Failure_Caught(*args) -> "Handle_Standard_Failure":
    """
    * Returns the last caught exception. Needed when exceptions are emulated by C longjumps, in other cases is also provided for compatibility.

    :rtype: Handle_Standard_Failure

    """
    return _Standard.Standard_Failure_Caught(*args)

class Handle_Standard_Failure(Handle_Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Standard.Handle_Standard_Failure_swiginit(self, _Standard.new_Handle_Standard_Failure(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Standard.Handle_Standard_Failure_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _Standard.delete_Handle_Standard_Failure
Handle_Standard_Failure.Nullify = new_instancemethod(_Standard.Handle_Standard_Failure_Nullify, None, Handle_Standard_Failure)
Handle_Standard_Failure.IsNull = new_instancemethod(_Standard.Handle_Standard_Failure_IsNull, None, Handle_Standard_Failure)
Handle_Standard_Failure._get_reference = new_instancemethod(_Standard.Handle_Standard_Failure__get_reference, None, Handle_Standard_Failure)
Handle_Standard_Failure_swigregister = _Standard.Handle_Standard_Failure_swigregister
Handle_Standard_Failure_swigregister(Handle_Standard_Failure)

def Handle_Standard_Failure_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_Standard_Failure const":
    return _Standard.Handle_Standard_Failure_DownCast(AnObject)
Handle_Standard_Failure_DownCast = _Standard.Handle_Standard_Failure_DownCast

class Standard_MMgrOpt(Standard_MMgrRoot):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. If aClear is True, the allocated emmory will be nullified. For description of other parameters, see description of the class above.

        :param aClear: default value is Standard_True
        :type aClear: bool
        :param aMMap: default value is Standard_True
        :type aMMap: bool
        :param aCellSize: default value is 200
        :type aCellSize: Standard_Size
        :param aNbPages: default value is 10000
        :type aNbPages: int
        :param aThreshold: default value is 40000
        :type aThreshold: Standard_Size
        :rtype: None

        """
        _Standard.Standard_MMgrOpt_swiginit(self, _Standard.new_Standard_MMgrOpt(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_MMgrOpt
Standard_MMgrOpt_swigregister = _Standard.Standard_MMgrOpt_swigregister
Standard_MMgrOpt_swigregister(Standard_MMgrOpt)

class Standard_MMgrRaw(Standard_MMgrRoot):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor; if aClear is True, the memory will be nullified upon allocation.

        :param aClear: default value is Standard_False
        :type aClear: bool
        :rtype: None

        """
        _Standard.Standard_MMgrRaw_swiginit(self, _Standard.new_Standard_MMgrRaw(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_MMgrRaw
Standard_MMgrRaw_swigregister = _Standard.Standard_MMgrRaw_swigregister
Standard_MMgrRaw_swigregister(Standard_MMgrRaw)

class Standard_MMgrTBBalloc(Standard_MMgrRoot):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor; if aClear is True, the memory will be nullified upon allocation.

        :param aClear: default value is Standard_False
        :type aClear: bool
        :rtype: None

        """
        _Standard.Standard_MMgrTBBalloc_swiginit(self, _Standard.new_Standard_MMgrTBBalloc(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_MMgrTBBalloc
Standard_MMgrTBBalloc_swigregister = _Standard.Standard_MMgrTBBalloc_swigregister
Standard_MMgrTBBalloc_swigregister(Standard_MMgrTBBalloc)

class Standard_Mutex(Standard_ErrorHandlerCallback):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor: creates a mutex object and initializes it. It is strongly recommended that mutexes were created as static objects whenever possible.

        :rtype: None

        """
        _Standard.Standard_Mutex_swiginit(self, _Standard.new_Standard_Mutex(*args))

    def Lock(self, *args) -> "void":
        """
        * Method to lock the mutex; waits until the mutex is released by other threads, locks it and then returns

        :rtype: None

        """
        return _Standard.Standard_Mutex_Lock(self, *args)


    def TryLock(self, *args) -> "Standard_Boolean":
        """
        * Method to test the mutex; if the mutex is not hold by other thread, locks it and returns True; otherwise returns False without waiting mutex to be released.

        :rtype: bool

        """
        return _Standard.Standard_Mutex_TryLock(self, *args)


    def Unlock(self, *args) -> "void":
        """
        * Method to unlock the mutex; releases it to other users

        :rtype: None

        """
        return _Standard.Standard_Mutex_Unlock(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_Mutex
Standard_Mutex.Lock = new_instancemethod(_Standard.Standard_Mutex_Lock, None, Standard_Mutex)
Standard_Mutex.TryLock = new_instancemethod(_Standard.Standard_Mutex_TryLock, None, Standard_Mutex)
Standard_Mutex.Unlock = new_instancemethod(_Standard.Standard_Mutex_Unlock, None, Standard_Mutex)
Standard_Mutex_swigregister = _Standard.Standard_Mutex_swigregister
Standard_Mutex_swigregister(Standard_Mutex)

class Standard_Type(Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Name(self, *args) -> "char const *":
        """
        * Returns the type name of <self>.

        :rtype: char *

        """
        return _Standard.Standard_Type_Name(self, *args)


    def Size(self, *args) -> "Standard_Integer":
        """
        * Returns the size of <self> in bytes.

        :rtype: int

        """
        return _Standard.Standard_Type_Size(self, *args)


    def __init__(self, *args):
        """
        * The constructor for a imported type.

        :param aName:
        :type aName: char *
        :param aSize:
        :type aSize: int
        :rtype: None

        * The constructor for a primitive.

        :param aName:
        :type aName: char *
        :param aSize:
        :type aSize: int
        :param aNumberOfParent:
        :type aNumberOfParent: int
        :param aAncestors:
        :type aAncestors: Standard_Address
        :rtype: None

        * The constructor for an enumeration.

        :param aName:
        :type aName: char *
        :param aSize:
        :type aSize: int
        :param aNumberOfElement:
        :type aNumberOfElement: int
        :param aNumberOfParent:
        :type aNumberOfParent: int
        :param anAncestors:
        :type anAncestors: Standard_Address
        :param aElements:
        :type aElements: Standard_Address
        :rtype: None

        * The constructor for a class.

        :param aName:
        :type aName: char *
        :param aSize:
        :type aSize: int
        :param aNumberOfParent:
        :type aNumberOfParent: int
        :param anAncestors:
        :type anAncestors: Standard_Address
        :param aFields:
        :type aFields: Standard_Address
        :rtype: None

        """
        _Standard.Standard_Type_swiginit(self, _Standard.new_Standard_Type(*args))

    def SubType(self, *args) -> "Standard_Boolean":
        """
        * Returns 'True', if <self> is the same as <aOther>, or inherits from <aOther>. Note that multiple inheritance is not supported.

        :param aOther:
        :type aOther: Handle_Standard_Type &
        :rtype: bool

        * Returns 'True', if <self> or one of its ancestors has the name equal to theName. Note that multiple inheritance is not supported.

        :param theName:
        :type theName: char *
        :rtype: bool

        """
        return _Standard.Standard_Type_SubType(self, *args)


    def IsImported(self, *args) -> "Standard_Boolean":
        """
        * Returns 'True', if the type is imported.

        :rtype: bool

        """
        return _Standard.Standard_Type_IsImported(self, *args)


    def IsPrimitive(self, *args) -> "Standard_Boolean":
        """
        * Returns 'True', if the type is a primitive.

        :rtype: bool

        """
        return _Standard.Standard_Type_IsPrimitive(self, *args)


    def IsEnumeration(self, *args) -> "Standard_Boolean":
        """
        * Returns 'True', if the type is an 'Enumeration'.

        :rtype: bool

        """
        return _Standard.Standard_Type_IsEnumeration(self, *args)


    def IsClass(self, *args) -> "Standard_Boolean":
        """
        * Returns 'True', if the type is a 'Class'.

        :rtype: bool

        """
        return _Standard.Standard_Type_IsClass(self, *args)


    def NumberOfParent(self, *args) -> "Standard_Integer":
        """
        * Returns the number of direct parents of the class.

        :rtype: int

        """
        return _Standard.Standard_Type_NumberOfParent(self, *args)


    def NumberOfAncestor(self, *args) -> "Standard_Integer":
        """
        * Returns the number of ancestors of the class.

        :rtype: int

        """
        return _Standard.Standard_Type_NumberOfAncestor(self, *args)


    def PrintToString(self) -> "std::string":
        """PrintToString(Standard_Type self) -> std::string"""
        return _Standard.Standard_Type_PrintToString(self)


    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Standard_Type(self)
            self.thisown = False
            return self.thisHandle


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_Type
Standard_Type.Name = new_instancemethod(_Standard.Standard_Type_Name, None, Standard_Type)
Standard_Type.Size = new_instancemethod(_Standard.Standard_Type_Size, None, Standard_Type)
Standard_Type.SubType = new_instancemethod(_Standard.Standard_Type_SubType, None, Standard_Type)
Standard_Type.IsImported = new_instancemethod(_Standard.Standard_Type_IsImported, None, Standard_Type)
Standard_Type.IsPrimitive = new_instancemethod(_Standard.Standard_Type_IsPrimitive, None, Standard_Type)
Standard_Type.IsEnumeration = new_instancemethod(_Standard.Standard_Type_IsEnumeration, None, Standard_Type)
Standard_Type.IsClass = new_instancemethod(_Standard.Standard_Type_IsClass, None, Standard_Type)
Standard_Type.NumberOfParent = new_instancemethod(_Standard.Standard_Type_NumberOfParent, None, Standard_Type)
Standard_Type.NumberOfAncestor = new_instancemethod(_Standard.Standard_Type_NumberOfAncestor, None, Standard_Type)
Standard_Type.PrintToString = new_instancemethod(_Standard.Standard_Type_PrintToString, None, Standard_Type)
Standard_Type_swigregister = _Standard.Standard_Type_swigregister
Standard_Type_swigregister(Standard_Type)

class Handle_Standard_Type(Handle_Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Standard.Handle_Standard_Type_swiginit(self, _Standard.new_Handle_Standard_Type(*args))

            # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Standard.Handle_Standard_Type_DownCast)

    def GetObject(self):
        obj = self._get_reference()
        register_handle(self, obj)
        return obj

    __swig_destroy__ = _Standard.delete_Handle_Standard_Type
Handle_Standard_Type.Nullify = new_instancemethod(_Standard.Handle_Standard_Type_Nullify, None, Handle_Standard_Type)
Handle_Standard_Type.IsNull = new_instancemethod(_Standard.Handle_Standard_Type_IsNull, None, Handle_Standard_Type)
Handle_Standard_Type._get_reference = new_instancemethod(_Standard.Handle_Standard_Type__get_reference, None, Handle_Standard_Type)
Handle_Standard_Type_swigregister = _Standard.Handle_Standard_Type_swigregister
Handle_Standard_Type_swigregister(Handle_Standard_Type)

def Handle_Standard_Type_DownCast(AnObject: 'Handle_Standard_Transient') -> "Handle_Standard_Type const":
    return _Standard.Handle_Standard_Type_DownCast(AnObject)
Handle_Standard_Type_DownCast = _Standard.Handle_Standard_Type_DownCast



