# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _GeomLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GeomLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GeomLib')
    _GeomLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GeomLib', [dirname(__file__)])
        except ImportError:
            import _GeomLib
            return _GeomLib
        try:
            _mod = imp.load_module('_GeomLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GeomLib = swig_import_helper()
    del swig_import_helper
else:
    import _GeomLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomLib.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_GeomLib.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_GeomLib.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_GeomLib.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_GeomLib.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_GeomLib.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_GeomLib.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_GeomLib.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_GeomLib.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_GeomLib.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_GeomLib.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_GeomLib.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_GeomLib.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_GeomLib.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_GeomLib.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_GeomLib.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_GeomLib.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _GeomLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.gp
import OCC.Standard
import OCC.Geom2d
import OCC.MMgt
import OCC.GeomAbs
import OCC.TColgp
import OCC.TCollection
import OCC.TColStd
import OCC.Geom
import OCC.Adaptor3d
import OCC.Adaptor2d
import OCC.TopAbs
import OCC.math
import OCC.AdvApprox
import OCC.PLib

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

GeomLib_NoError = _GeomLib.GeomLib_NoError
GeomLib_NotEnoughtPoints = _GeomLib.GeomLib_NotEnoughtPoints
GeomLib_DegreeSmallerThan3 = _GeomLib.GeomLib_DegreeSmallerThan3
GeomLib_InversionProblem = _GeomLib.GeomLib_InversionProblem
class geomlib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def To3d(*args) -> "Handle_Geom_Curve":
        """
        * Computes the curve 3d from package Geom corresponding to curve 2d from package Geom2d, on the plan defined with the local coordinate system Position.

        :param Position:
        :type Position: gp_Ax2
        :param Curve2d:
        :type Curve2d: Handle_Geom2d_Curve &
        :rtype: Handle_Geom_Curve

        """
        return _GeomLib.geomlib_To3d(*args)

    To3d = staticmethod(To3d)

    def GTransform(*args) -> "Handle_Geom2d_Curve":
        """
        * Computes the curve 3d from package Geom corresponding to the curve 3d from package Geom, transformed with the transformation <GTrsf> WARNING : this method may return a null Handle if it's impossible to compute the transformation of a curve. It's not implemented when : 1) the curve is an infinite parabola or hyperbola 2) the curve is an offsetcurve

        :param Curve:
        :type Curve: Handle_Geom2d_Curve &
        :param GTrsf:
        :type GTrsf: gp_GTrsf2d
        :rtype: Handle_Geom2d_Curve

        """
        return _GeomLib.geomlib_GTransform(*args)

    GTransform = staticmethod(GTransform)

    def SameRange(*args) -> "void":
        """
        * Make the curve Curve2dPtr have the imposed range First to List the most economic way, that is if it can change the range without changing the nature of the curve it will try to do that. Otherwise it will produce a Bspline curve that has the required range

        :param Tolerance:
        :type Tolerance: float
        :param Curve2dPtr:
        :type Curve2dPtr: Handle_Geom2d_Curve &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param RequestedFirst:
        :type RequestedFirst: float
        :param RequestedLast:
        :type RequestedLast: float
        :param NewCurve2dPtr:
        :type NewCurve2dPtr: Handle_Geom2d_Curve &
        :rtype: void

        """
        return _GeomLib.geomlib_SameRange(*args)

    SameRange = staticmethod(SameRange)

    def BuildCurve3d(*args) -> "Standard_Real &, Standard_Real &":
        """
        :param Tolerance:
        :type Tolerance: float
        :param CurvePtr:
        :type CurvePtr: Adaptor3d_CurveOnSurface &
        :param FirstParameter:
        :type FirstParameter: float
        :param LastParameter:
        :type LastParameter: float
        :param NewCurvePtr:
        :type NewCurvePtr: Handle_Geom_Curve &
        :param MaxDeviation:
        :type MaxDeviation: float &
        :param AverageDeviation:
        :type AverageDeviation: float &
        :param Continuity: default value is GeomAbs_C1
        :type Continuity: GeomAbs_Shape
        :param MaxDegree: default value is 14
        :type MaxDegree: int
        :param MaxSegment: default value is 30
        :type MaxSegment: int
        :rtype: void

        """
        return _GeomLib.geomlib_BuildCurve3d(*args)

    BuildCurve3d = staticmethod(BuildCurve3d)

    def AdjustExtremity(*args) -> "void":
        """
        :param Curve:
        :type Curve: Handle_Geom_BoundedCurve &
        :param P1:
        :type P1: gp_Pnt
        :param P2:
        :type P2: gp_Pnt
        :param T1:
        :type T1: gp_Vec
        :param T2:
        :type T2: gp_Vec
        :rtype: void

        """
        return _GeomLib.geomlib_AdjustExtremity(*args)

    AdjustExtremity = staticmethod(AdjustExtremity)

    def ExtendCurveToPoint(*args) -> "void":
        """
        * Extends the bounded curve Curve to the point Point. The extension is built: - at the end of the curve if After equals true, or - at the beginning of the curve if After equals false. The extension is performed according to a degree of continuity equal to Cont, which in its turn must be equal to 1, 2 or 3. This function converts the bounded curve Curve into a BSpline curve. Warning - Nothing is done, and Curve is not modified if Cont is not equal to 1, 2 or 3. - It is recommended that the extension should not be too large with respect to the size of the bounded curve Curve: Point must not be located too far from one of the extremities of Curve.

        :param Curve:
        :type Curve: Handle_Geom_BoundedCurve &
        :param Point:
        :type Point: gp_Pnt
        :param Cont:
        :type Cont: int
        :param After:
        :type After: bool
        :rtype: void

        """
        return _GeomLib.geomlib_ExtendCurveToPoint(*args)

    ExtendCurveToPoint = staticmethod(ExtendCurveToPoint)

    def ExtendSurfByLength(*args) -> "void":
        """
        * Extends the bounded surface Surf along one of its boundaries. The chord length of the extension is equal to Length. The direction of the extension is given as: - the u parametric direction of Surf, if InU equals true, or - the v parametric direction of Surf, if InU equals false. In this parametric direction, the extension is built on the side of: - the last parameter of Surf, if After equals true, or - the first parameter of Surf, if After equals false. The extension is performed according to a degree of continuity equal to Cont, which in its turn must be equal to 1, 2 or 3. This function converts the bounded surface Surf into a BSpline surface. Warning - Nothing is done, and Surf is not modified if Cont is not equal to 1, 2 or 3. - It is recommended that Length, the size of the extension should not be too large with respect to the size of the bounded surface Surf. - Surf must not be a periodic BSpline surface in the parametric direction corresponding to the direction of extension.

        :param Surf:
        :type Surf: Handle_Geom_BoundedSurface &
        :param Length:
        :type Length: float
        :param Cont:
        :type Cont: int
        :param InU:
        :type InU: bool
        :param After:
        :type After: bool
        :rtype: void

        """
        return _GeomLib.geomlib_ExtendSurfByLength(*args)

    ExtendSurfByLength = staticmethod(ExtendSurfByLength)

    def AxeOfInertia(*args) -> "Standard_Boolean &":
        """
        * Compute axes of inertia, of some points -- -- -- <Axe>.Location() is the BaryCentre -- -- -- -- -- <Axe>.XDirection is the axe of upper inertia -- -- -- -- <Axe>.Direction is the Normal to the average plane -- -- -- IsSingular is True if points are on line -- Tol is used to determine singular cases.

        :param Points:
        :type Points: TColgp_Array1OfPnt
        :param Axe:
        :type Axe: gp_Ax2
        :param IsSingular:
        :type IsSingular: bool
        :param Tol: default value is 1.0e-7
        :type Tol: float
        :rtype: void

        """
        return _GeomLib.geomlib_AxeOfInertia(*args)

    AxeOfInertia = staticmethod(AxeOfInertia)

    def Inertia(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        * Compute principale axes of inertia, and dispertion value of some points.

        :param Points:
        :type Points: TColgp_Array1OfPnt
        :param Bary:
        :type Bary: gp_Pnt
        :param XDir:
        :type XDir: gp_Dir
        :param YDir:
        :type YDir: gp_Dir
        :param Xgap:
        :type Xgap: float &
        :param YGap:
        :type YGap: float &
        :param ZGap:
        :type ZGap: float &
        :rtype: void

        """
        return _GeomLib.geomlib_Inertia(*args)

    Inertia = staticmethod(Inertia)

    def RemovePointsFromArray(*args) -> "void":
        """
        * Warning! This assume that the InParameter is an increasing sequence of real number and it will not check for that : Unpredictable result can happen if this is not satisfied. It is the caller responsability to check for that property. //! This method makes uniform NumPoints segments S1,...SNumPoints out of the segment defined by the first parameter and the last parameter ofthe InParameter ; keeps only one point of the InParameters set of parameter in each of the uniform segments taking care of the first and the last parameters. For the ith segment the element of the InParameter is the one that is the first to exceed the midpoint of the segment and to fall before the midpoint of the next segment There will be at the end at most NumPoints + 1 if NumPoints > 2 in the OutParameters Array

        :param NumPoints:
        :type NumPoints: int
        :param InParameters:
        :type InParameters: TColStd_Array1OfReal &
        :param OutParameters:
        :type OutParameters: Handle_TColStd_HArray1OfReal &
        :rtype: void

        """
        return _GeomLib.geomlib_RemovePointsFromArray(*args)

    RemovePointsFromArray = staticmethod(RemovePointsFromArray)

    def DensifyArray1OfReal(*args) -> "void":
        """
        * this makes sure that there is at least MinNumPoints in OutParameters taking into account the parameters in the InParameters array provided those are in order, that is the sequence of real in the InParameter is strictly non decreasing

        :param MinNumPoints:
        :type MinNumPoints: int
        :param InParameters:
        :type InParameters: TColStd_Array1OfReal &
        :param OutParameters:
        :type OutParameters: Handle_TColStd_HArray1OfReal &
        :rtype: void

        """
        return _GeomLib.geomlib_DensifyArray1OfReal(*args)

    DensifyArray1OfReal = staticmethod(DensifyArray1OfReal)

    def FuseIntervals(*args) -> "void":
        """
        :param Interval1:
        :type Interval1: TColStd_Array1OfReal &
        :param Interval2:
        :type Interval2: TColStd_Array1OfReal &
        :param Fusion:
        :type Fusion: TColStd_SequenceOfReal &
        :param Confusion: default value is 1.0e-9
        :type Confusion: float
        :rtype: void

        """
        return _GeomLib.geomlib_FuseIntervals(*args)

    FuseIntervals = staticmethod(FuseIntervals)

    def EvalMaxParametricDistance(*args) -> "Standard_Real &":
        """
        * this will compute the maximum distance at the parameters given in the Parameters array by evaluating each parameter the two curves and taking the maximum of the evaluated distance

        :param Curve:
        :type Curve: Adaptor3d_Curve &
        :param AReferenceCurve:
        :type AReferenceCurve: Adaptor3d_Curve &
        :param Tolerance:
        :type Tolerance: float
        :param Parameters:
        :type Parameters: TColStd_Array1OfReal &
        :param MaxDistance:
        :type MaxDistance: float &
        :rtype: void

        """
        return _GeomLib.geomlib_EvalMaxParametricDistance(*args)

    EvalMaxParametricDistance = staticmethod(EvalMaxParametricDistance)

    def EvalMaxDistanceAlongParameter(*args) -> "Standard_Real &":
        """
        * this will compute the maximum distancef at the parameters given in the Parameters array by projecting from the Curve to the reference curve and taking the minimum distance Than the maximum will be taken on those minimas.

        :param Curve:
        :type Curve: Adaptor3d_Curve &
        :param AReferenceCurve:
        :type AReferenceCurve: Adaptor3d_Curve &
        :param Tolerance:
        :type Tolerance: float
        :param Parameters:
        :type Parameters: TColStd_Array1OfReal &
        :param MaxDistance:
        :type MaxDistance: float &
        :rtype: void

        """
        return _GeomLib.geomlib_EvalMaxDistanceAlongParameter(*args)

    EvalMaxDistanceAlongParameter = staticmethod(EvalMaxDistanceAlongParameter)

    def CancelDenominatorDerivative(*args) -> "void":
        """
        * Cancel,on the boudaries,the denominator first derivative in the directions wished by the user and set its value to 1.

        :param BSurf:
        :type BSurf: Handle_Geom_BSplineSurface &
        :param UDirection:
        :type UDirection: bool
        :param VDirection:
        :type VDirection: bool
        :rtype: void

        """
        return _GeomLib.geomlib_CancelDenominatorDerivative(*args)

    CancelDenominatorDerivative = staticmethod(CancelDenominatorDerivative)

    def NormEstim(*args) -> "Standard_Integer":
        """
        :param S:
        :type S: Handle_Geom_Surface &
        :param UV:
        :type UV: gp_Pnt2d
        :param Tol:
        :type Tol: float
        :param N:
        :type N: gp_Dir
        :rtype: int

        """
        return _GeomLib.geomlib_NormEstim(*args)

    NormEstim = staticmethod(NormEstim)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomLib.geomlib_swiginit(self, _GeomLib.new_geomlib())
    __swig_destroy__ = _GeomLib.delete_geomlib
geomlib_swigregister = _GeomLib.geomlib_swigregister
geomlib_swigregister(geomlib)

def geomlib_To3d(*args) -> "Handle_Geom_Curve":
    """
    * Computes the curve 3d from package Geom corresponding to curve 2d from package Geom2d, on the plan defined with the local coordinate system Position.

    :param Position:
    :type Position: gp_Ax2
    :param Curve2d:
    :type Curve2d: Handle_Geom2d_Curve &
    :rtype: Handle_Geom_Curve

    """
    return _GeomLib.geomlib_To3d(*args)

def geomlib_GTransform(*args) -> "Handle_Geom2d_Curve":
    """
    * Computes the curve 3d from package Geom corresponding to the curve 3d from package Geom, transformed with the transformation <GTrsf> WARNING : this method may return a null Handle if it's impossible to compute the transformation of a curve. It's not implemented when : 1) the curve is an infinite parabola or hyperbola 2) the curve is an offsetcurve

    :param Curve:
    :type Curve: Handle_Geom2d_Curve &
    :param GTrsf:
    :type GTrsf: gp_GTrsf2d
    :rtype: Handle_Geom2d_Curve

    """
    return _GeomLib.geomlib_GTransform(*args)

def geomlib_SameRange(*args) -> "void":
    """
    * Make the curve Curve2dPtr have the imposed range First to List the most economic way, that is if it can change the range without changing the nature of the curve it will try to do that. Otherwise it will produce a Bspline curve that has the required range

    :param Tolerance:
    :type Tolerance: float
    :param Curve2dPtr:
    :type Curve2dPtr: Handle_Geom2d_Curve &
    :param First:
    :type First: float
    :param Last:
    :type Last: float
    :param RequestedFirst:
    :type RequestedFirst: float
    :param RequestedLast:
    :type RequestedLast: float
    :param NewCurve2dPtr:
    :type NewCurve2dPtr: Handle_Geom2d_Curve &
    :rtype: void

    """
    return _GeomLib.geomlib_SameRange(*args)

def geomlib_BuildCurve3d(*args) -> "Standard_Real &, Standard_Real &":
    """
    :param Tolerance:
    :type Tolerance: float
    :param CurvePtr:
    :type CurvePtr: Adaptor3d_CurveOnSurface &
    :param FirstParameter:
    :type FirstParameter: float
    :param LastParameter:
    :type LastParameter: float
    :param NewCurvePtr:
    :type NewCurvePtr: Handle_Geom_Curve &
    :param MaxDeviation:
    :type MaxDeviation: float &
    :param AverageDeviation:
    :type AverageDeviation: float &
    :param Continuity: default value is GeomAbs_C1
    :type Continuity: GeomAbs_Shape
    :param MaxDegree: default value is 14
    :type MaxDegree: int
    :param MaxSegment: default value is 30
    :type MaxSegment: int
    :rtype: void

    """
    return _GeomLib.geomlib_BuildCurve3d(*args)

def geomlib_AdjustExtremity(*args) -> "void":
    """
    :param Curve:
    :type Curve: Handle_Geom_BoundedCurve &
    :param P1:
    :type P1: gp_Pnt
    :param P2:
    :type P2: gp_Pnt
    :param T1:
    :type T1: gp_Vec
    :param T2:
    :type T2: gp_Vec
    :rtype: void

    """
    return _GeomLib.geomlib_AdjustExtremity(*args)

def geomlib_ExtendCurveToPoint(*args) -> "void":
    """
    * Extends the bounded curve Curve to the point Point. The extension is built: - at the end of the curve if After equals true, or - at the beginning of the curve if After equals false. The extension is performed according to a degree of continuity equal to Cont, which in its turn must be equal to 1, 2 or 3. This function converts the bounded curve Curve into a BSpline curve. Warning - Nothing is done, and Curve is not modified if Cont is not equal to 1, 2 or 3. - It is recommended that the extension should not be too large with respect to the size of the bounded curve Curve: Point must not be located too far from one of the extremities of Curve.

    :param Curve:
    :type Curve: Handle_Geom_BoundedCurve &
    :param Point:
    :type Point: gp_Pnt
    :param Cont:
    :type Cont: int
    :param After:
    :type After: bool
    :rtype: void

    """
    return _GeomLib.geomlib_ExtendCurveToPoint(*args)

def geomlib_ExtendSurfByLength(*args) -> "void":
    """
    * Extends the bounded surface Surf along one of its boundaries. The chord length of the extension is equal to Length. The direction of the extension is given as: - the u parametric direction of Surf, if InU equals true, or - the v parametric direction of Surf, if InU equals false. In this parametric direction, the extension is built on the side of: - the last parameter of Surf, if After equals true, or - the first parameter of Surf, if After equals false. The extension is performed according to a degree of continuity equal to Cont, which in its turn must be equal to 1, 2 or 3. This function converts the bounded surface Surf into a BSpline surface. Warning - Nothing is done, and Surf is not modified if Cont is not equal to 1, 2 or 3. - It is recommended that Length, the size of the extension should not be too large with respect to the size of the bounded surface Surf. - Surf must not be a periodic BSpline surface in the parametric direction corresponding to the direction of extension.

    :param Surf:
    :type Surf: Handle_Geom_BoundedSurface &
    :param Length:
    :type Length: float
    :param Cont:
    :type Cont: int
    :param InU:
    :type InU: bool
    :param After:
    :type After: bool
    :rtype: void

    """
    return _GeomLib.geomlib_ExtendSurfByLength(*args)

def geomlib_AxeOfInertia(*args) -> "Standard_Boolean &":
    """
    * Compute axes of inertia, of some points -- -- -- <Axe>.Location() is the BaryCentre -- -- -- -- -- <Axe>.XDirection is the axe of upper inertia -- -- -- -- <Axe>.Direction is the Normal to the average plane -- -- -- IsSingular is True if points are on line -- Tol is used to determine singular cases.

    :param Points:
    :type Points: TColgp_Array1OfPnt
    :param Axe:
    :type Axe: gp_Ax2
    :param IsSingular:
    :type IsSingular: bool
    :param Tol: default value is 1.0e-7
    :type Tol: float
    :rtype: void

    """
    return _GeomLib.geomlib_AxeOfInertia(*args)

def geomlib_Inertia(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    * Compute principale axes of inertia, and dispertion value of some points.

    :param Points:
    :type Points: TColgp_Array1OfPnt
    :param Bary:
    :type Bary: gp_Pnt
    :param XDir:
    :type XDir: gp_Dir
    :param YDir:
    :type YDir: gp_Dir
    :param Xgap:
    :type Xgap: float &
    :param YGap:
    :type YGap: float &
    :param ZGap:
    :type ZGap: float &
    :rtype: void

    """
    return _GeomLib.geomlib_Inertia(*args)

def geomlib_RemovePointsFromArray(*args) -> "void":
    """
    * Warning! This assume that the InParameter is an increasing sequence of real number and it will not check for that : Unpredictable result can happen if this is not satisfied. It is the caller responsability to check for that property. //! This method makes uniform NumPoints segments S1,...SNumPoints out of the segment defined by the first parameter and the last parameter ofthe InParameter ; keeps only one point of the InParameters set of parameter in each of the uniform segments taking care of the first and the last parameters. For the ith segment the element of the InParameter is the one that is the first to exceed the midpoint of the segment and to fall before the midpoint of the next segment There will be at the end at most NumPoints + 1 if NumPoints > 2 in the OutParameters Array

    :param NumPoints:
    :type NumPoints: int
    :param InParameters:
    :type InParameters: TColStd_Array1OfReal &
    :param OutParameters:
    :type OutParameters: Handle_TColStd_HArray1OfReal &
    :rtype: void

    """
    return _GeomLib.geomlib_RemovePointsFromArray(*args)

def geomlib_DensifyArray1OfReal(*args) -> "void":
    """
    * this makes sure that there is at least MinNumPoints in OutParameters taking into account the parameters in the InParameters array provided those are in order, that is the sequence of real in the InParameter is strictly non decreasing

    :param MinNumPoints:
    :type MinNumPoints: int
    :param InParameters:
    :type InParameters: TColStd_Array1OfReal &
    :param OutParameters:
    :type OutParameters: Handle_TColStd_HArray1OfReal &
    :rtype: void

    """
    return _GeomLib.geomlib_DensifyArray1OfReal(*args)

def geomlib_FuseIntervals(*args) -> "void":
    """
    :param Interval1:
    :type Interval1: TColStd_Array1OfReal &
    :param Interval2:
    :type Interval2: TColStd_Array1OfReal &
    :param Fusion:
    :type Fusion: TColStd_SequenceOfReal &
    :param Confusion: default value is 1.0e-9
    :type Confusion: float
    :rtype: void

    """
    return _GeomLib.geomlib_FuseIntervals(*args)

def geomlib_EvalMaxParametricDistance(*args) -> "Standard_Real &":
    """
    * this will compute the maximum distance at the parameters given in the Parameters array by evaluating each parameter the two curves and taking the maximum of the evaluated distance

    :param Curve:
    :type Curve: Adaptor3d_Curve &
    :param AReferenceCurve:
    :type AReferenceCurve: Adaptor3d_Curve &
    :param Tolerance:
    :type Tolerance: float
    :param Parameters:
    :type Parameters: TColStd_Array1OfReal &
    :param MaxDistance:
    :type MaxDistance: float &
    :rtype: void

    """
    return _GeomLib.geomlib_EvalMaxParametricDistance(*args)

def geomlib_EvalMaxDistanceAlongParameter(*args) -> "Standard_Real &":
    """
    * this will compute the maximum distancef at the parameters given in the Parameters array by projecting from the Curve to the reference curve and taking the minimum distance Than the maximum will be taken on those minimas.

    :param Curve:
    :type Curve: Adaptor3d_Curve &
    :param AReferenceCurve:
    :type AReferenceCurve: Adaptor3d_Curve &
    :param Tolerance:
    :type Tolerance: float
    :param Parameters:
    :type Parameters: TColStd_Array1OfReal &
    :param MaxDistance:
    :type MaxDistance: float &
    :rtype: void

    """
    return _GeomLib.geomlib_EvalMaxDistanceAlongParameter(*args)

def geomlib_CancelDenominatorDerivative(*args) -> "void":
    """
    * Cancel,on the boudaries,the denominator first derivative in the directions wished by the user and set its value to 1.

    :param BSurf:
    :type BSurf: Handle_Geom_BSplineSurface &
    :param UDirection:
    :type UDirection: bool
    :param VDirection:
    :type VDirection: bool
    :rtype: void

    """
    return _GeomLib.geomlib_CancelDenominatorDerivative(*args)

def geomlib_NormEstim(*args) -> "Standard_Integer":
    """
    :param S:
    :type S: Handle_Geom_Surface &
    :param UV:
    :type UV: gp_Pnt2d
    :param Tol:
    :type Tol: float
    :param N:
    :type N: gp_Dir
    :rtype: int

    """
    return _GeomLib.geomlib_NormEstim(*args)

class GeomLib_Array1OfMat(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        :param Item:
        :type Item: gp_Mat
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        """
        _GeomLib.GeomLib_Array1OfMat_swiginit(self, _GeomLib.new_GeomLib_Array1OfMat(*args))

    def Init(self, *args) -> "void":
        """
        :param V:
        :type V: gp_Mat
        :rtype: None

        """
        return _GeomLib.GeomLib_Array1OfMat_Init(self, *args)


    def Destroy(self, *args) -> "void":
        """
        :rtype: None

        """
        return _GeomLib.GeomLib_Array1OfMat_Destroy(self, *args)


    def IsAllocated(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _GeomLib.GeomLib_Array1OfMat_IsAllocated(self, *args)


    def Assign(self, *args) -> "GeomLib_Array1OfMat const &":
        """
        :param Other:
        :type Other: GeomLib_Array1OfMat &
        :rtype: GeomLib_Array1OfMat

        """
        return _GeomLib.GeomLib_Array1OfMat_Assign(self, *args)


    def Set(self, *args) -> "GeomLib_Array1OfMat const &":
        """
        :param Other:
        :type Other: GeomLib_Array1OfMat &
        :rtype: GeomLib_Array1OfMat

        """
        return _GeomLib.GeomLib_Array1OfMat_Set(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _GeomLib.GeomLib_Array1OfMat_Length(self, *args)


    def Lower(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _GeomLib.GeomLib_Array1OfMat_Lower(self, *args)


    def Upper(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _GeomLib.GeomLib_Array1OfMat_Upper(self, *args)


    def SetValue(self, *args) -> "void":
        """
        :param Index:
        :type Index: int
        :param Value:
        :type Value: gp_Mat
        :rtype: None

        """
        return _GeomLib.GeomLib_Array1OfMat_SetValue(self, *args)


    def Value(self, *args) -> "gp_Mat const":
        """
        :param Index:
        :type Index: int
        :rtype: gp_Mat

        """
        return _GeomLib.GeomLib_Array1OfMat_Value(self, *args)


    def ChangeValue(self, *args) -> "gp_Mat":
        """
        :param Index:
        :type Index: int
        :rtype: gp_Mat

        """
        return _GeomLib.GeomLib_Array1OfMat_ChangeValue(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_Array1OfMat
GeomLib_Array1OfMat.Init = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_Init, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.Destroy = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_Destroy, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.IsAllocated = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_IsAllocated, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.Assign = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_Assign, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.Set = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_Set, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.Length = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_Length, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.Lower = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_Lower, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.Upper = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_Upper, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.SetValue = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_SetValue, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.Value = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_Value, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat.ChangeValue = new_instancemethod(_GeomLib.GeomLib_Array1OfMat_ChangeValue, None, GeomLib_Array1OfMat)
GeomLib_Array1OfMat_swigregister = _GeomLib.GeomLib_Array1OfMat_swigregister
GeomLib_Array1OfMat_swigregister(GeomLib_Array1OfMat)

class GeomLib_Check2dBSplineCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Curve:
        :type Curve: Handle_Geom2d_BSplineCurve &
        :param Tolerance:
        :type Tolerance: float
        :param AngularTolerance:
        :type AngularTolerance: float
        :rtype: None

        """
        _GeomLib.GeomLib_Check2dBSplineCurve_swiginit(self, _GeomLib.new_GeomLib_Check2dBSplineCurve(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_IsDone(self, *args)


    def NeedTangentFix(self, *args) -> "void":
        """
        :param FirstFlag:
        :type FirstFlag: bool
        :param SecondFlag:
        :type SecondFlag: bool
        :rtype: None

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_NeedTangentFix(self, *args)


    def FixTangent(self, *args) -> "void":
        """
        :param FirstFlag:
        :type FirstFlag: bool
        :param LastFlag:
        :type LastFlag: bool
        :rtype: None

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_FixTangent(self, *args)


    def FixedTangent(self, *args) -> "Handle_Geom2d_BSplineCurve":
        """
        * modifies the curve by fixing the first or the last tangencies //! if Index3D not in the Range [1,Nb3dSpaces] if the Approx is not Done

        :param FirstFlag:
        :type FirstFlag: bool
        :param LastFlag:
        :type LastFlag: bool
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_FixedTangent(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_Check2dBSplineCurve
GeomLib_Check2dBSplineCurve.IsDone = new_instancemethod(_GeomLib.GeomLib_Check2dBSplineCurve_IsDone, None, GeomLib_Check2dBSplineCurve)
GeomLib_Check2dBSplineCurve.NeedTangentFix = new_instancemethod(_GeomLib.GeomLib_Check2dBSplineCurve_NeedTangentFix, None, GeomLib_Check2dBSplineCurve)
GeomLib_Check2dBSplineCurve.FixTangent = new_instancemethod(_GeomLib.GeomLib_Check2dBSplineCurve_FixTangent, None, GeomLib_Check2dBSplineCurve)
GeomLib_Check2dBSplineCurve.FixedTangent = new_instancemethod(_GeomLib.GeomLib_Check2dBSplineCurve_FixedTangent, None, GeomLib_Check2dBSplineCurve)
GeomLib_Check2dBSplineCurve_swigregister = _GeomLib.GeomLib_Check2dBSplineCurve_swigregister
GeomLib_Check2dBSplineCurve_swigregister(GeomLib_Check2dBSplineCurve)

class GeomLib_CheckBSplineCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Curve:
        :type Curve: Handle_Geom_BSplineCurve &
        :param Tolerance:
        :type Tolerance: float
        :param AngularTolerance:
        :type AngularTolerance: float
        :rtype: None

        """
        _GeomLib.GeomLib_CheckBSplineCurve_swiginit(self, _GeomLib.new_GeomLib_CheckBSplineCurve(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_IsDone(self, *args)


    def NeedTangentFix(self, *args) -> "void":
        """
        :param FirstFlag:
        :type FirstFlag: bool
        :param SecondFlag:
        :type SecondFlag: bool
        :rtype: None

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_NeedTangentFix(self, *args)


    def FixTangent(self, *args) -> "void":
        """
        :param FirstFlag:
        :type FirstFlag: bool
        :param LastFlag:
        :type LastFlag: bool
        :rtype: None

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_FixTangent(self, *args)


    def FixedTangent(self, *args) -> "Handle_Geom_BSplineCurve":
        """
        * modifies the curve by fixing the first or the last tangencies //! if Index3D not in the Range [1,Nb3dSpaces] if the Approx is not Done

        :param FirstFlag:
        :type FirstFlag: bool
        :param LastFlag:
        :type LastFlag: bool
        :rtype: Handle_Geom_BSplineCurve

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_FixedTangent(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_CheckBSplineCurve
GeomLib_CheckBSplineCurve.IsDone = new_instancemethod(_GeomLib.GeomLib_CheckBSplineCurve_IsDone, None, GeomLib_CheckBSplineCurve)
GeomLib_CheckBSplineCurve.NeedTangentFix = new_instancemethod(_GeomLib.GeomLib_CheckBSplineCurve_NeedTangentFix, None, GeomLib_CheckBSplineCurve)
GeomLib_CheckBSplineCurve.FixTangent = new_instancemethod(_GeomLib.GeomLib_CheckBSplineCurve_FixTangent, None, GeomLib_CheckBSplineCurve)
GeomLib_CheckBSplineCurve.FixedTangent = new_instancemethod(_GeomLib.GeomLib_CheckBSplineCurve_FixedTangent, None, GeomLib_CheckBSplineCurve)
GeomLib_CheckBSplineCurve_swigregister = _GeomLib.GeomLib_CheckBSplineCurve_swigregister
GeomLib_CheckBSplineCurve_swigregister(GeomLib_CheckBSplineCurve)

class GeomLib_DenominatorMultiplier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * if the surface is rational this will define the evaluator of a real function of 2 variables a(u,v) such that if we define a new surface by : a(u,v) * N(u,v) NewF(u,v) = ---------------- a(u,v) * D(u,v)

        :param Surface:
        :type Surface: Handle_Geom_BSplineSurface &
        :param KnotVector:
        :type KnotVector: TColStd_Array1OfReal &
        :rtype: None

        """
        _GeomLib.GeomLib_DenominatorMultiplier_swiginit(self, _GeomLib.new_GeomLib_DenominatorMultiplier(*args))

    def Value(self, *args) -> "Standard_Real":
        """
        * Returns the value of a(UParameter,VParameter)= //! H0(UParameter)/Denominator(Umin,Vparameter) //! D Denominator(Umin,Vparameter) - ------------------------------[H1(u)]/(Denominator(Umin,Vparameter)^2) D U //! + H3(UParameter)/Denominator(Umax,Vparameter) //! D Denominator(Umax,Vparameter) - ------------------------------[H2(u)]/(Denominator(Umax,Vparameter)^2) D U

        :param UParameter:
        :type UParameter: float
        :param VParameter:
        :type VParameter: float
        :rtype: float

        """
        return _GeomLib.GeomLib_DenominatorMultiplier_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_DenominatorMultiplier
GeomLib_DenominatorMultiplier.Value = new_instancemethod(_GeomLib.GeomLib_DenominatorMultiplier_Value, None, GeomLib_DenominatorMultiplier)
GeomLib_DenominatorMultiplier_swigregister = _GeomLib.GeomLib_DenominatorMultiplier_swigregister
GeomLib_DenominatorMultiplier_swigregister(GeomLib_DenominatorMultiplier)

class GeomLib_Interpolate(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Degree:
        :type Degree: int
        :param NumPoints:
        :type NumPoints: int
        :param Points:
        :type Points: TColgp_Array1OfPnt
        :param Parameters:
        :type Parameters: TColStd_Array1OfReal &
        :rtype: None

        """
        _GeomLib.GeomLib_Interpolate_swiginit(self, _GeomLib.new_GeomLib_Interpolate(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns if everything went OK

        :rtype: bool

        """
        return _GeomLib.GeomLib_Interpolate_IsDone(self, *args)


    def Error(self, *args) -> "GeomLib_InterpolationErrors":
        """
        * returns the error type if any

        :rtype: GeomLib_InterpolationErrors

        """
        return _GeomLib.GeomLib_Interpolate_Error(self, *args)


    def Curve(self, *args) -> "Handle_Geom_BSplineCurve":
        """
        * returns the interpolated curve of the requested degree

        :rtype: Handle_Geom_BSplineCurve

        """
        return _GeomLib.GeomLib_Interpolate_Curve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_Interpolate
GeomLib_Interpolate.IsDone = new_instancemethod(_GeomLib.GeomLib_Interpolate_IsDone, None, GeomLib_Interpolate)
GeomLib_Interpolate.Error = new_instancemethod(_GeomLib.GeomLib_Interpolate_Error, None, GeomLib_Interpolate)
GeomLib_Interpolate.Curve = new_instancemethod(_GeomLib.GeomLib_Interpolate_Curve, None, GeomLib_Interpolate)
GeomLib_Interpolate_swigregister = _GeomLib.GeomLib_Interpolate_swigregister
GeomLib_Interpolate_swigregister(GeomLib_Interpolate)

class GeomLib_IsPlanarSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param S:
        :type S: Handle_Geom_Surface &
        :param Tol: default value is 1.0e-7
        :type Tol: float
        :rtype: None

        """
        _GeomLib.GeomLib_IsPlanarSurface_swiginit(self, _GeomLib.new_GeomLib_IsPlanarSurface(*args))

    def IsPlanar(self, *args) -> "Standard_Boolean":
        """
        * Return if the Surface is a plan

        :rtype: bool

        """
        return _GeomLib.GeomLib_IsPlanarSurface_IsPlanar(self, *args)


    def Plan(self, *args) -> "gp_Pln const":
        """
        * Return the plan definition

        :rtype: gp_Pln

        """
        return _GeomLib.GeomLib_IsPlanarSurface_Plan(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_IsPlanarSurface
GeomLib_IsPlanarSurface.IsPlanar = new_instancemethod(_GeomLib.GeomLib_IsPlanarSurface_IsPlanar, None, GeomLib_IsPlanarSurface)
GeomLib_IsPlanarSurface.Plan = new_instancemethod(_GeomLib.GeomLib_IsPlanarSurface_Plan, None, GeomLib_IsPlanarSurface)
GeomLib_IsPlanarSurface_swigregister = _GeomLib.GeomLib_IsPlanarSurface_swigregister
GeomLib_IsPlanarSurface_swigregister(GeomLib_IsPlanarSurface)

class GeomLib_LogSample(OCC.math.math_FunctionSample):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param A:
        :type A: float
        :param B:
        :type B: float
        :param N:
        :type N: int
        :rtype: None

        """
        _GeomLib.GeomLib_LogSample_swiginit(self, _GeomLib.new_GeomLib_LogSample(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_LogSample
GeomLib_LogSample_swigregister = _GeomLib.GeomLib_LogSample_swigregister
GeomLib_LogSample_swigregister(GeomLib_LogSample)

class GeomLib_MakeCurvefromApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Approx:
        :type Approx: AdvApprox_ApproxAFunction &
        :rtype: None

        """
        _GeomLib.GeomLib_MakeCurvefromApprox_swiginit(self, _GeomLib.new_GeomLib_MakeCurvefromApprox(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_IsDone(self, *args)


    def Nb1DSpaces(self, *args) -> "Standard_Integer":
        """
        * returns the number of 1D spaces of the Approx

        :rtype: int

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Nb1DSpaces(self, *args)


    def Nb2DSpaces(self, *args) -> "Standard_Integer":
        """
        * returns the number of 3D spaces of the Approx

        :rtype: int

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Nb2DSpaces(self, *args)


    def Nb3DSpaces(self, *args) -> "Standard_Integer":
        """
        * returns the number of 3D spaces of the Approx

        :rtype: int

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Nb3DSpaces(self, *args)


    def Curve2dFromTwo1d(self, *args) -> "Handle_Geom2d_BSplineCurve":
        """
        * returns a 2D curve building it from the 1D curve in x at Index1d and y at Index2d amongst the 1D curves if Index1d not in the Range [1,Nb1dSpaces] if Index2d not in the Range [1,Nb1dSpaces] if the Approx is not Done

        :param Index1d:
        :type Index1d: int
        :param Index2d:
        :type Index2d: int
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Curve2dFromTwo1d(self, *args)


    def Curve2d(self, *args) -> "Handle_Geom2d_BSplineCurve":
        """
        * returns a polynomial curve whose poles correspond to the Index2d 2D space if Index2d not in the Range [1,Nb2dSpaces] if the Approx is not Done

        :param Index2d:
        :type Index2d: int
        :rtype: Handle_Geom2d_BSplineCurve

        * returns a rational curve whose poles correspond to the index2d of the 2D space and whose weights correspond to one dimensional space of index 1d if Index1d not in the Range [1,Nb1dSpaces] if Index2d not in the Range [1,Nb2dSpaces] if the Approx is not Done

        :param Index1d:
        :type Index1d: int
        :param Index2d:
        :type Index2d: int
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Curve2d(self, *args)


    def Curve(self, *args) -> "Handle_Geom_BSplineCurve":
        """
        * returns a polynomial curve whose poles correspond to the Index3D 3D space if Index3D not in the Range [1,Nb3dSpaces] if the Approx is not Done

        :param Index3d:
        :type Index3d: int
        :rtype: Handle_Geom_BSplineCurve

        * returns a rational curve whose poles correspond to the index3D of the 3D space and whose weights correspond to the index1d 1D space. if Index1D not in the Range [1,Nb1dSpaces] if Index3D not in the Range [1,Nb3dSpaces] if the Approx is not Done

        :param Index1D:
        :type Index1D: int
        :param Index3D:
        :type Index3D: int
        :rtype: Handle_Geom_BSplineCurve

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Curve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_MakeCurvefromApprox
GeomLib_MakeCurvefromApprox.IsDone = new_instancemethod(_GeomLib.GeomLib_MakeCurvefromApprox_IsDone, None, GeomLib_MakeCurvefromApprox)
GeomLib_MakeCurvefromApprox.Nb1DSpaces = new_instancemethod(_GeomLib.GeomLib_MakeCurvefromApprox_Nb1DSpaces, None, GeomLib_MakeCurvefromApprox)
GeomLib_MakeCurvefromApprox.Nb2DSpaces = new_instancemethod(_GeomLib.GeomLib_MakeCurvefromApprox_Nb2DSpaces, None, GeomLib_MakeCurvefromApprox)
GeomLib_MakeCurvefromApprox.Nb3DSpaces = new_instancemethod(_GeomLib.GeomLib_MakeCurvefromApprox_Nb3DSpaces, None, GeomLib_MakeCurvefromApprox)
GeomLib_MakeCurvefromApprox.Curve2dFromTwo1d = new_instancemethod(_GeomLib.GeomLib_MakeCurvefromApprox_Curve2dFromTwo1d, None, GeomLib_MakeCurvefromApprox)
GeomLib_MakeCurvefromApprox.Curve2d = new_instancemethod(_GeomLib.GeomLib_MakeCurvefromApprox_Curve2d, None, GeomLib_MakeCurvefromApprox)
GeomLib_MakeCurvefromApprox.Curve = new_instancemethod(_GeomLib.GeomLib_MakeCurvefromApprox_Curve, None, GeomLib_MakeCurvefromApprox)
GeomLib_MakeCurvefromApprox_swigregister = _GeomLib.GeomLib_MakeCurvefromApprox_swigregister
GeomLib_MakeCurvefromApprox_swigregister(GeomLib_MakeCurvefromApprox)

class GeomLib_PolyFunc(OCC.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Coeffs:
        :type Coeffs: math_Vector &
        :rtype: None

        """
        _GeomLib.GeomLib_PolyFunc_swiginit(self, _GeomLib.new_GeomLib_PolyFunc(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_PolyFunc
GeomLib_PolyFunc_swigregister = _GeomLib.GeomLib_PolyFunc_swigregister
GeomLib_PolyFunc_swigregister(GeomLib_PolyFunc)

class GeomLib_Tool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Parameters(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Extracts the parameter of a 3D point lying on a surface or at a distance less than the tolerance value.

        :param Surface:
        :type Surface: Handle_Geom_Surface &
        :param Point:
        :type Point: gp_Pnt
        :param Tolerance:
        :type Tolerance: float
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: bool

        """
        return _GeomLib.GeomLib_Tool_Parameters(*args)

    Parameters = staticmethod(Parameters)

    def Parameter(*args) -> "Standard_Real &":
        """
        * Extracts the parameter of a 3D point lying on a 3D curve or at a distance less than the tolerance value.

        :param Curve:
        :type Curve: Handle_Geom_Curve &
        :param Point:
        :type Point: gp_Pnt
        :param Tolerance:
        :type Tolerance: float
        :param U:
        :type U: float &
        :rtype: bool

        * Extracts the parameter of a 2D point lying on a 2D curve or at a distance less than the tolerance value.

        :param Curve:
        :type Curve: Handle_Geom2d_Curve &
        :param Point:
        :type Point: gp_Pnt2d
        :param Tolerance:
        :type Tolerance: float
        :param U:
        :type U: float &
        :rtype: bool

        """
        return _GeomLib.GeomLib_Tool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomLib.GeomLib_Tool_swiginit(self, _GeomLib.new_GeomLib_Tool())
    __swig_destroy__ = _GeomLib.delete_GeomLib_Tool
GeomLib_Tool_swigregister = _GeomLib.GeomLib_Tool_swigregister
GeomLib_Tool_swigregister(GeomLib_Tool)

def GeomLib_Tool_Parameters(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Extracts the parameter of a 3D point lying on a surface or at a distance less than the tolerance value.

    :param Surface:
    :type Surface: Handle_Geom_Surface &
    :param Point:
    :type Point: gp_Pnt
    :param Tolerance:
    :type Tolerance: float
    :param U:
    :type U: float &
    :param V:
    :type V: float &
    :rtype: bool

    """
    return _GeomLib.GeomLib_Tool_Parameters(*args)

def GeomLib_Tool_Parameter(*args) -> "Standard_Real &":
    """
    * Extracts the parameter of a 3D point lying on a 3D curve or at a distance less than the tolerance value.

    :param Curve:
    :type Curve: Handle_Geom_Curve &
    :param Point:
    :type Point: gp_Pnt
    :param Tolerance:
    :type Tolerance: float
    :param U:
    :type U: float &
    :rtype: bool

    * Extracts the parameter of a 2D point lying on a 2D curve or at a distance less than the tolerance value.

    :param Curve:
    :type Curve: Handle_Geom2d_Curve &
    :param Point:
    :type Point: gp_Pnt2d
    :param Tolerance:
    :type Tolerance: float
    :param U:
    :type U: float &
    :rtype: bool

    """
    return _GeomLib.GeomLib_Tool_Parameter(*args)



