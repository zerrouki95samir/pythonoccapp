# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BOPTools.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BOPTools')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BOPTools')
    _BOPTools = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BOPTools', [dirname(__file__)])
        except ImportError:
            import _BOPTools
            return _BOPTools
        try:
            _mod = imp.load_module('_BOPTools', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BOPTools = swig_import_helper()
    del swig_import_helper
else:
    import _BOPTools
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BOPTools.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BOPTools.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BOPTools.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BOPTools.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BOPTools.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BOPTools.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BOPTools.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BOPTools.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BOPTools.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BOPTools.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BOPTools.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BOPTools.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BOPTools.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BOPTools.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BOPTools.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BOPTools.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BOPTools.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BOPTools.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Improve string output for any oce object.
    By default, __repr__ method returns something like:
    <OCC.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    class<'gp_Pnt'>
    or
    class<'TopoDS_Shape'; Type:Solid; Id:59391729>
    """
    klass_name = str(klass.__class__).split(".")[2].split("'")[0]
    repr_string = "class<'" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        st = klass.ShapeType()
        types = {OCC.TopAbs.TopAbs_VERTEX:"Vertex",
                 OCC.TopAbs.TopAbs_SOLID:"Solid",
                 OCC.TopAbs.TopAbs_EDGE:"Edge",
                 OCC.TopAbs.TopAbs_FACE:"Face",
                 OCC.TopAbs.TopAbs_SHELL:"Shell",
                 OCC.TopAbs.TopAbs_WIRE:"Wire",
                 OCC.TopAbs.TopAbs_COMPOUND:"Compound",
                 OCC.TopAbs.TopAbs_COMPSOLID:"Compsolid."}
        repr_string += "; Type:%s" % types[st]        
# for each class that has an HashCode method define,
# print the id
    if hasattr(klass, "HashCode"):
        klass_id = hash(klass)
        repr_string += "; id:%s" % klass_id
    repr_string += ">"
    return repr_string

import OCC.TopoDS
import OCC.MMgt
import OCC.Standard
import OCC.TCollection
import OCC.TopLoc
import OCC.gp
import OCC.TopAbs
import OCC.BOPCol
import OCC.Bnd
import OCC.TColStd
import OCC.IntTools
import OCC.Geom
import OCC.GeomAbs
import OCC.TColgp
import OCC.BRepAdaptor
import OCC.Adaptor3d
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.math
import OCC.GeomAdaptor
import OCC.Geom2dAdaptor
import OCC.GeomAPI
import OCC.Quantity
import OCC.Extrema
import OCC.Approx
import OCC.AppCont
import OCC.AppParCurves
import OCC.BRepClass3d
import OCC.IntCurveSurface
import OCC.Intf
import OCC.IntSurf
import OCC.IntCurvesFace
import OCC.Geom2dHatch
import OCC.IntRes2d
import OCC.HatchGen
import OCC.Geom2dInt
import OCC.IntCurve
import OCC.ProjLib
import OCC.NCollection

def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

class boptools(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MapShapes(*args) -> "void":
        """
        :param S:
        :type S: TopoDS_Shape &
        :param M:
        :type M: BOPCol_MapOfShape &
        :rtype: void

        :param S:
        :type S: TopoDS_Shape &
        :param M:
        :type M: BOPCol_IndexedMapOfShape &
        :rtype: void

        :param S:
        :type S: TopoDS_Shape &
        :param T:
        :type T: TopAbs_ShapeEnum
        :param M:
        :type M: BOPCol_IndexedMapOfShape &
        :rtype: void

        """
        return _BOPTools.boptools_MapShapes(*args)

    MapShapes = staticmethod(MapShapes)

    def MapShapesAndAncestors(*args) -> "void":
        """
        :param S:
        :type S: TopoDS_Shape &
        :param TS:
        :type TS: TopAbs_ShapeEnum
        :param TA:
        :type TA: TopAbs_ShapeEnum
        :param M:
        :type M: BOPCol_IndexedDataMapOfShapeListOfShape &
        :rtype: void

        """
        return _BOPTools.boptools_MapShapesAndAncestors(*args)

    MapShapesAndAncestors = staticmethod(MapShapesAndAncestors)

    __repr__ = _dumps_object


    def __init__(self):
        _BOPTools.boptools_swiginit(self, _BOPTools.new_boptools())
    __swig_destroy__ = _BOPTools.delete_boptools
boptools_swigregister = _BOPTools.boptools_swigregister
boptools_swigregister(boptools)

def boptools_MapShapes(*args) -> "void":
    """
    :param S:
    :type S: TopoDS_Shape &
    :param M:
    :type M: BOPCol_MapOfShape &
    :rtype: void

    :param S:
    :type S: TopoDS_Shape &
    :param M:
    :type M: BOPCol_IndexedMapOfShape &
    :rtype: void

    :param S:
    :type S: TopoDS_Shape &
    :param T:
    :type T: TopAbs_ShapeEnum
    :param M:
    :type M: BOPCol_IndexedMapOfShape &
    :rtype: void

    """
    return _BOPTools.boptools_MapShapes(*args)

def boptools_MapShapesAndAncestors(*args) -> "void":
    """
    :param S:
    :type S: TopoDS_Shape &
    :param TS:
    :type TS: TopAbs_ShapeEnum
    :param TA:
    :type TA: TopAbs_ShapeEnum
    :param M:
    :type M: BOPCol_IndexedDataMapOfShapeListOfShape &
    :rtype: void

    """
    return _BOPTools.boptools_MapShapesAndAncestors(*args)

class BOPTools_AlgoTools(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ComputeVV(*args) -> "Standard_Integer":
        """
        :param aV1:
        :type aV1: TopoDS_Vertex &
        :param aP2:
        :type aP2: gp_Pnt
        :param aTolP2:
        :type aTolP2: float
        :rtype: int

        :param aV1:
        :type aV1: TopoDS_Vertex &
        :param aV2:
        :type aV2: TopoDS_Vertex &
        :rtype: int

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeVV(*args)

    ComputeVV = staticmethod(ComputeVV)

    def MakeVertex(*args) -> "void":
        """
        :param aLV:
        :type aLV: BOPCol_ListOfShape &
        :param aV:
        :type aV: TopoDS_Vertex &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_MakeVertex(*args)

    MakeVertex = staticmethod(MakeVertex)

    def MakeEdge(*args) -> "void":
        """
        :param theCurve:
        :type theCurve: IntTools_Curve &
        :param theV1:
        :type theV1: TopoDS_Vertex &
        :param theT1:
        :type theT1: float
        :param theV2:
        :type theV2: TopoDS_Vertex &
        :param theT2:
        :type theT2: float
        :param theTolR3D:
        :type theTolR3D: float
        :param theE:
        :type theE: TopoDS_Edge &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_MakeEdge(*args)

    MakeEdge = staticmethod(MakeEdge)

    def MakePCurve(*args) -> "void":
        """
        :param theE:
        :type theE: TopoDS_Edge &
        :param theF1:
        :type theF1: TopoDS_Face &
        :param theF2:
        :type theF2: TopoDS_Face &
        :param theCurve:
        :type theCurve: IntTools_Curve &
        :param thePC1:
        :type thePC1: bool
        :param thePC2:
        :type thePC2: bool
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_MakePCurve(*args)

    MakePCurve = staticmethod(MakePCurve)

    def MakeContainer(*args) -> "void":
        """
        :param theType:
        :type theType: TopAbs_ShapeEnum
        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_MakeContainer(*args)

    MakeContainer = staticmethod(MakeContainer)

    def IsHole(*args) -> "Standard_Boolean":
        """
        :param aW:
        :type aW: TopoDS_Shape &
        :param aF:
        :type aF: TopoDS_Shape &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsHole(*args)

    IsHole = staticmethod(IsHole)

    def IsSplitToReverse(*args) -> "Standard_Boolean":
        """
        * Returns True if the shape theSplit has opposite direction than theShape theContext - cashed geometrical tools

        :param theSplit:
        :type theSplit: TopoDS_Shape &
        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: bool

        * Returns True if normal direction of the face theShape is not the same as for the face theSplit theContext - cashed geometrical tools

        :param theSplit:
        :type theSplit: TopoDS_Face &
        :param theShape:
        :type theShape: TopoDS_Face &
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: bool

        :param aE1:
        :type aE1: TopoDS_Edge &
        :param aE2:
        :type aE2: TopoDS_Edge &
        :param aContext:
        :type aContext: Handle_IntTools_Context &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsSplitToReverse(*args)

    IsSplitToReverse = staticmethod(IsSplitToReverse)

    def AreFacesSameDomain(*args) -> "Standard_Boolean":
        """
        :param theF1:
        :type theF1: TopoDS_Face &
        :param theF2:
        :type theF2: TopoDS_Face &
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_AreFacesSameDomain(*args)

    AreFacesSameDomain = staticmethod(AreFacesSameDomain)

    def CheckSameGeom(*args) -> "Standard_Boolean":
        """
        :param theF1:
        :type theF1: TopoDS_Face &
        :param theF2:
        :type theF2: TopoDS_Face &
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_CheckSameGeom(*args)

    CheckSameGeom = staticmethod(CheckSameGeom)

    def Sense(*args) -> "Standard_Integer":
        """
        :param theF1:
        :type theF1: TopoDS_Face &
        :param theF2:
        :type theF2: TopoDS_Face &
        :rtype: int

        """
        return _BOPTools.BOPTools_AlgoTools_Sense(*args)

    Sense = staticmethod(Sense)

    def GetEdgeOff(*args) -> "Standard_Boolean":
        """
        * Returns True if the face theFace contains the edge theEdge but with opposite orientation. If the method returns True theEdgeOff is the edge founded

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theFace:
        :type theFace: TopoDS_Face &
        :param theEdgeOff:
        :type theEdgeOff: TopoDS_Edge &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_GetEdgeOff(*args)

    GetEdgeOff = staticmethod(GetEdgeOff)

    def GetFaceOff(*args) -> "Standard_Boolean":
        """
        * For the face theFace and its edge theEdge finds the face suitable to produce shell. theLCEF - set of faces to search. All faces from theLCEF must share edge theEdge

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theFace:
        :type theFace: TopoDS_Face &
        :param theLCEF:
        :type theLCEF: BOPTools_ListOfCoupleOfShape &
        :param theFaceOff:
        :type theFaceOff: TopoDS_Face &
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_GetFaceOff(*args)

    GetFaceOff = staticmethod(GetFaceOff)

    def IsInternalFace(*args) -> "Standard_Integer":
        """
        * Returns True if the face theFace is inside of the couple of faces theFace1, theFace2. The faces theFace, theFace1, theFace2 must share the edge theEdge

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theFace1:
        :type theFace1: TopoDS_Face &
        :param theFace2:
        :type theFace2: TopoDS_Face &
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: int

        * Returns True if the face theFace is inside of the appropriate couple of faces (from the set theLF) . The faces of the set theLF and theFace must share the edge theEdge

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theLF:
        :type theLF: BOPCol_ListOfShape &
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: int

        * Returns True if the face theFace is inside the solid theSolid. theMEF - Map Edge/Faces for theSolid theTol - value of precision of computation theContext- cahed geometrical tools

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theSolid:
        :type theSolid: TopoDS_Solid &
        :param theMEF:
        :type theMEF: BOPCol_IndexedDataMapOfShapeListOfShape &
        :param theTol:
        :type theTol: float
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: int

        """
        return _BOPTools.BOPTools_AlgoTools_IsInternalFace(*args)

    IsInternalFace = staticmethod(IsInternalFace)

    def GetEdgeOnFace(*args) -> "Standard_Boolean":
        """
        * For the face theFace gets the edge theEdgeOnF that is the same as theEdge Returns True if such edge exists Returns False if there is no such edge

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theFace:
        :type theFace: TopoDS_Face &
        :param theEdgeOnF:
        :type theEdgeOnF: TopoDS_Edge &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_GetEdgeOnFace(*args)

    GetEdgeOnFace = staticmethod(GetEdgeOnFace)

    def ComputeState(*args) -> "TopAbs_State":
        """
        * Computes the 3-D state of the point thePoint toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.

        :param thePoint:
        :type thePoint: gp_Pnt
        :param theSolid:
        :type theSolid: TopoDS_Solid &
        :param theTol:
        :type theTol: float
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: TopAbs_State

        * Computes the 3-D state of the vertex theVertex toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.

        :param theVertex:
        :type theVertex: TopoDS_Vertex &
        :param theSolid:
        :type theSolid: TopoDS_Solid &
        :param theTol:
        :type theTol: float
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: TopAbs_State

        * Computes the 3-D state of the edge theEdge toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theSolid:
        :type theSolid: TopoDS_Solid &
        :param theTol:
        :type theTol: float
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: TopAbs_State

        * Computes the 3-D state of the face theFace toward solid theSolid. theTol - value of precision of computation theBounds - set of edges of theFace to avoid theContext- cahed geometrical tools Returns 3-D state.

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theSolid:
        :type theSolid: TopoDS_Solid &
        :param theTol:
        :type theTol: float
        :param theBounds:
        :type theBounds: BOPCol_IndexedMapOfShape &
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: TopAbs_State

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeState(*args)

    ComputeState = staticmethod(ComputeState)

    def ComputeStateByOnePoint(*args) -> "TopAbs_State":
        """
        * Computes the 3-D state of the shape theShape toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theSolid:
        :type theSolid: TopoDS_Solid &
        :param theTol:
        :type theTol: float
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: TopAbs_State

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeStateByOnePoint(*args)

    ComputeStateByOnePoint = staticmethod(ComputeStateByOnePoint)

    def MakeConnexityBlock(*args) -> "void":
        """
        * For the list of faces theLS build block theLSCB in terms of connexity by edges theMapAvoid - set of edges to avoid for the treatment

        :param theLS:
        :type theLS: BOPCol_ListOfShape &
        :param theMapAvoid:
        :type theMapAvoid: BOPCol_IndexedMapOfShape &
        :param theLSCB:
        :type theLSCB: BOPCol_ListOfShape &
        :param theAllocator:
        :type theAllocator: BOPCol_BaseAllocator &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlock(*args)

    MakeConnexityBlock = staticmethod(MakeConnexityBlock)

    def MakeConnexityBlocks(*args) -> "void":
        """
        * For the compound theS build the blocks theLCB (as list of compounds) in terms of connexity by the shapes of theType

        :param theS:
        :type theS: TopoDS_Shape &
        :param theType1:
        :type theType1: TopAbs_ShapeEnum
        :param theType2:
        :type theType2: TopAbs_ShapeEnum
        :param theLCB:
        :type theLCB: BOPCol_ListOfShape &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlocks(*args)

    MakeConnexityBlocks = staticmethod(MakeConnexityBlocks)

    def OrientFacesOnShell(*args) -> "void":
        """
        :param theS:
        :type theS: TopoDS_Shape &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_OrientFacesOnShell(*args)

    OrientFacesOnShell = staticmethod(OrientFacesOnShell)

    def CorrectTolerances(*args) -> "void":
        """
        * Provides valid values of tolerances for the shape <theS> <theTolMax> is max value of the tolerance that can be accepted for correction. If real value of the tolerance will be greater than <aTolMax>, the correction does not perform.

        :param theS:
        :type theS: TopoDS_Shape &
        :param theTolMax: default value is 0.0001
        :type theTolMax: float
        :param theRunParallel: default value is Standard_False
        :type theRunParallel: bool
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectTolerances(*args)

    CorrectTolerances = staticmethod(CorrectTolerances)

    def CorrectCurveOnSurface(*args) -> "void":
        """
        * Provides valid values of tolerances for the shape <theS> in terms of BRepCheck_InvalidCurveOnSurface.

        :param theS:
        :type theS: TopoDS_Shape &
        :param theTolMax: default value is 0.0001
        :type theTolMax: float
        :param theRunParallel: default value is Standard_False
        :type theRunParallel: bool
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectCurveOnSurface(*args)

    CorrectCurveOnSurface = staticmethod(CorrectCurveOnSurface)

    def CorrectPointOnCurve(*args) -> "void":
        """
        * Provides valid values of tolerances for the shape <theS> in terms of BRepCheck_InvalidPointOnCurve.

        :param theS:
        :type theS: TopoDS_Shape &
        :param theTolMax: default value is 0.0001
        :type theTolMax: float
        :param theRunParallel: default value is Standard_False
        :type theRunParallel: bool
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectPointOnCurve(*args)

    CorrectPointOnCurve = staticmethod(CorrectPointOnCurve)

    def MakeNewVertex(*args) -> "void":
        """
        * Make a vertex using 3D-point <aP1> and 3D-tolerance value <aTol>

        :param aP1:
        :type aP1: gp_Pnt
        :param aTol:
        :type aTol: float
        :param aNewVertex:
        :type aNewVertex: TopoDS_Vertex &
        :rtype: void

        * Make a vertex using couple of vertices <aV1, aV2>

        :param aV1:
        :type aV1: TopoDS_Vertex &
        :param aV2:
        :type aV2: TopoDS_Vertex &
        :param aNewVertex:
        :type aNewVertex: TopoDS_Vertex &
        :rtype: void

        * Make a vertex in place of intersection between two edges <aE1, aE2> with parameters <aP1, aP2>

        :param aE1:
        :type aE1: TopoDS_Edge &
        :param aP1:
        :type aP1: float
        :param aE2:
        :type aE2: TopoDS_Edge &
        :param aP2:
        :type aP2: float
        :param aNewVertex:
        :type aNewVertex: TopoDS_Vertex &
        :rtype: void

        * Make a vertex in place of intersection between the edge <aE1> with parameter <aP1> and the face <aF2>

        :param aE1:
        :type aE1: TopoDS_Edge &
        :param aP1:
        :type aP1: float
        :param aF2:
        :type aF2: TopoDS_Face &
        :param aNewVertex:
        :type aNewVertex: TopoDS_Vertex &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_MakeNewVertex(*args)

    MakeNewVertex = staticmethod(MakeNewVertex)

    def PointOnEdge(*args) -> "void":
        """
        * Compute a 3D-point on the edge <aEdge> at parameter <aPrm>

        :param aEdge:
        :type aEdge: TopoDS_Edge &
        :param aPrm:
        :type aPrm: float
        :param aP:
        :type aP: gp_Pnt
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_PointOnEdge(*args)

    PointOnEdge = staticmethod(PointOnEdge)

    def MakeSplitEdge(*args) -> "void":
        """
        * Make the edge from base edge <aE1> and two vertices <aV1,aV2> at parameters <aP1,aP2>

        :param aE1:
        :type aE1: TopoDS_Edge &
        :param aV1:
        :type aV1: TopoDS_Vertex &
        :param aP1:
        :type aP1: float
        :param aV2:
        :type aV2: TopoDS_Vertex &
        :param aP2:
        :type aP2: float
        :param aNewEdge:
        :type aNewEdge: TopoDS_Edge &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_MakeSplitEdge(*args)

    MakeSplitEdge = staticmethod(MakeSplitEdge)

    def MakeSectEdge(*args) -> "void":
        """
        * Make the edge from 3D-Curve <aIC> and two vertices <aV1,aV2> at parameters <aP1,aP2>

        :param aIC:
        :type aIC: IntTools_Curve &
        :param aV1:
        :type aV1: TopoDS_Vertex &
        :param aP1:
        :type aP1: float
        :param aV2:
        :type aV2: TopoDS_Vertex &
        :param aP2:
        :type aP2: float
        :param aNewEdge:
        :type aNewEdge: TopoDS_Edge &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_MakeSectEdge(*args)

    MakeSectEdge = staticmethod(MakeSectEdge)

    def UpdateVertex(*args) -> "void":
        """
        * Update the tolerance value for vertex <aV> taking into account the fact that <aV> lays on the curve <aIC>

        :param aIC:
        :type aIC: IntTools_Curve &
        :param aT:
        :type aT: float
        :param aV:
        :type aV: TopoDS_Vertex &
        :rtype: void

        * Update the tolerance value for vertex <aV> taking into account the fact that <aV> lays on the edge <aE>

        :param aE:
        :type aE: TopoDS_Edge &
        :param aT:
        :type aT: float
        :param aV:
        :type aV: TopoDS_Vertex &
        :rtype: void

        * Update the tolerance value for vertex <aVN> taking into account the fact that <aVN> should cover tolerance zone of <aVF>

        :param aVF:
        :type aVF: TopoDS_Vertex &
        :param aVN:
        :type aVN: TopoDS_Vertex &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_UpdateVertex(*args)

    UpdateVertex = staticmethod(UpdateVertex)

    def CorrectRange(*args) -> "void":
        """
        * Correct shrunk range <aSR> taking into account 3D-curve resolution and corresp. tolerances' values of <aE1>, <aE2>

        :param aE1:
        :type aE1: TopoDS_Edge &
        :param aE2:
        :type aE2: TopoDS_Edge &
        :param aSR:
        :type aSR: IntTools_Range &
        :param aNewSR:
        :type aNewSR: IntTools_Range &
        :rtype: void

        * Correct shrunk range <aSR> taking into account 3D-curve resolution and corresp. tolerances' values of <aE>, <aF>

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aSR:
        :type aSR: IntTools_Range &
        :param aNewSR:
        :type aNewSR: IntTools_Range &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectRange(*args)

    CorrectRange = staticmethod(CorrectRange)

    def IsBlockInOnFace(*args) -> "Standard_Boolean":
        """
        * Returns True if PaveBlock <aPB> lays on the face <aF>, i.e the <PB> is IN or ON in 2D of <aF>

        :param aShR:
        :type aShR: IntTools_Range &
        :param aF:
        :type aF: TopoDS_Face &
        :param aE:
        :type aE: TopoDS_Edge &
        :param aContext:
        :type aContext: Handle_IntTools_Context &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsBlockInOnFace(*args)

    IsBlockInOnFace = staticmethod(IsBlockInOnFace)

    def IsMicroEdge(*args) -> "Standard_Boolean":
        """
        * Checks if it is possible to compute shrunk range for the edge <aE>.

        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsMicroEdge(*args)

    IsMicroEdge = staticmethod(IsMicroEdge)

    def CorrectShapeTolerances(*args) -> "void":
        """
        * Corrects tolerance values of the sub-shapes of the shape <theS> if needed.

        :param theS:
        :type theS: TopoDS_Shape &
        :param theRunParallel: default value is Standard_False
        :type theRunParallel: bool
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectShapeTolerances(*args)

    CorrectShapeTolerances = staticmethod(CorrectShapeTolerances)

    def Dimension(*args) -> "Standard_Integer":
        """
        * Retutns dimension of the shape <theS>.

        :param theS:
        :type theS: TopoDS_Shape &
        :rtype: int

        """
        return _BOPTools.BOPTools_AlgoTools_Dimension(*args)

    Dimension = staticmethod(Dimension)

    def IsOpenShell(*args) -> "Standard_Boolean":
        """
        * Returns true if the shell <theShell> is open

        :param theShell:
        :type theShell: TopoDS_Shell &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsOpenShell(*args)

    IsOpenShell = staticmethod(IsOpenShell)

    def IsInvertedSolid(*args) -> "Standard_Boolean":
        """
        * Returns true if the solid <theSolid> is inverted

        :param theSolid:
        :type theSolid: TopoDS_Solid &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsInvertedSolid(*args)

    IsInvertedSolid = staticmethod(IsInvertedSolid)

    def ComputeTolerance(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Computes the max distance between points taken from 3D and 2D curves by the same parameter

        :param theCurve3D:
        :type theCurve3D: Handle_Geom_Curve &
        :param theCurve2D:
        :type theCurve2D: Handle_Geom2d_Curve &
        :param theSurf:
        :type theSurf: Handle_Geom_Surface &
        :param theMaxDist:
        :type theMaxDist: float &
        :param theMaxPar:
        :type theMaxPar: float &
        :rtype: bool

        * Computes the necessary value of the tolerance for the edge

        :param theFace:
        :type theFace: TopoDS_Face &
        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :param theMaxDist:
        :type theMaxDist: float &
        :param theMaxPar:
        :type theMaxPar: float &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeTolerance(*args)

    ComputeTolerance = staticmethod(ComputeTolerance)

    __repr__ = _dumps_object


    def __init__(self):
        _BOPTools.BOPTools_AlgoTools_swiginit(self, _BOPTools.new_BOPTools_AlgoTools())
    __swig_destroy__ = _BOPTools.delete_BOPTools_AlgoTools
BOPTools_AlgoTools_swigregister = _BOPTools.BOPTools_AlgoTools_swigregister
BOPTools_AlgoTools_swigregister(BOPTools_AlgoTools)

def BOPTools_AlgoTools_ComputeVV(*args) -> "Standard_Integer":
    """
    :param aV1:
    :type aV1: TopoDS_Vertex &
    :param aP2:
    :type aP2: gp_Pnt
    :param aTolP2:
    :type aTolP2: float
    :rtype: int

    :param aV1:
    :type aV1: TopoDS_Vertex &
    :param aV2:
    :type aV2: TopoDS_Vertex &
    :rtype: int

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeVV(*args)

def BOPTools_AlgoTools_MakeVertex(*args) -> "void":
    """
    :param aLV:
    :type aLV: BOPCol_ListOfShape &
    :param aV:
    :type aV: TopoDS_Vertex &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_MakeVertex(*args)

def BOPTools_AlgoTools_MakeEdge(*args) -> "void":
    """
    :param theCurve:
    :type theCurve: IntTools_Curve &
    :param theV1:
    :type theV1: TopoDS_Vertex &
    :param theT1:
    :type theT1: float
    :param theV2:
    :type theV2: TopoDS_Vertex &
    :param theT2:
    :type theT2: float
    :param theTolR3D:
    :type theTolR3D: float
    :param theE:
    :type theE: TopoDS_Edge &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_MakeEdge(*args)

def BOPTools_AlgoTools_MakePCurve(*args) -> "void":
    """
    :param theE:
    :type theE: TopoDS_Edge &
    :param theF1:
    :type theF1: TopoDS_Face &
    :param theF2:
    :type theF2: TopoDS_Face &
    :param theCurve:
    :type theCurve: IntTools_Curve &
    :param thePC1:
    :type thePC1: bool
    :param thePC2:
    :type thePC2: bool
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_MakePCurve(*args)

def BOPTools_AlgoTools_MakeContainer(*args) -> "void":
    """
    :param theType:
    :type theType: TopAbs_ShapeEnum
    :param theShape:
    :type theShape: TopoDS_Shape &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_MakeContainer(*args)

def BOPTools_AlgoTools_IsHole(*args) -> "Standard_Boolean":
    """
    :param aW:
    :type aW: TopoDS_Shape &
    :param aF:
    :type aF: TopoDS_Shape &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsHole(*args)

def BOPTools_AlgoTools_IsSplitToReverse(*args) -> "Standard_Boolean":
    """
    * Returns True if the shape theSplit has opposite direction than theShape theContext - cashed geometrical tools

    :param theSplit:
    :type theSplit: TopoDS_Shape &
    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: bool

    * Returns True if normal direction of the face theShape is not the same as for the face theSplit theContext - cashed geometrical tools

    :param theSplit:
    :type theSplit: TopoDS_Face &
    :param theShape:
    :type theShape: TopoDS_Face &
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: bool

    :param aE1:
    :type aE1: TopoDS_Edge &
    :param aE2:
    :type aE2: TopoDS_Edge &
    :param aContext:
    :type aContext: Handle_IntTools_Context &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsSplitToReverse(*args)

def BOPTools_AlgoTools_AreFacesSameDomain(*args) -> "Standard_Boolean":
    """
    :param theF1:
    :type theF1: TopoDS_Face &
    :param theF2:
    :type theF2: TopoDS_Face &
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_AreFacesSameDomain(*args)

def BOPTools_AlgoTools_CheckSameGeom(*args) -> "Standard_Boolean":
    """
    :param theF1:
    :type theF1: TopoDS_Face &
    :param theF2:
    :type theF2: TopoDS_Face &
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_CheckSameGeom(*args)

def BOPTools_AlgoTools_Sense(*args) -> "Standard_Integer":
    """
    :param theF1:
    :type theF1: TopoDS_Face &
    :param theF2:
    :type theF2: TopoDS_Face &
    :rtype: int

    """
    return _BOPTools.BOPTools_AlgoTools_Sense(*args)

def BOPTools_AlgoTools_GetEdgeOff(*args) -> "Standard_Boolean":
    """
    * Returns True if the face theFace contains the edge theEdge but with opposite orientation. If the method returns True theEdgeOff is the edge founded

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theFace:
    :type theFace: TopoDS_Face &
    :param theEdgeOff:
    :type theEdgeOff: TopoDS_Edge &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_GetEdgeOff(*args)

def BOPTools_AlgoTools_GetFaceOff(*args) -> "Standard_Boolean":
    """
    * For the face theFace and its edge theEdge finds the face suitable to produce shell. theLCEF - set of faces to search. All faces from theLCEF must share edge theEdge

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theFace:
    :type theFace: TopoDS_Face &
    :param theLCEF:
    :type theLCEF: BOPTools_ListOfCoupleOfShape &
    :param theFaceOff:
    :type theFaceOff: TopoDS_Face &
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_GetFaceOff(*args)

def BOPTools_AlgoTools_IsInternalFace(*args) -> "Standard_Integer":
    """
    * Returns True if the face theFace is inside of the couple of faces theFace1, theFace2. The faces theFace, theFace1, theFace2 must share the edge theEdge

    :param theFace:
    :type theFace: TopoDS_Face &
    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theFace1:
    :type theFace1: TopoDS_Face &
    :param theFace2:
    :type theFace2: TopoDS_Face &
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: int

    * Returns True if the face theFace is inside of the appropriate couple of faces (from the set theLF) . The faces of the set theLF and theFace must share the edge theEdge

    :param theFace:
    :type theFace: TopoDS_Face &
    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theLF:
    :type theLF: BOPCol_ListOfShape &
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: int

    * Returns True if the face theFace is inside the solid theSolid. theMEF - Map Edge/Faces for theSolid theTol - value of precision of computation theContext- cahed geometrical tools

    :param theFace:
    :type theFace: TopoDS_Face &
    :param theSolid:
    :type theSolid: TopoDS_Solid &
    :param theMEF:
    :type theMEF: BOPCol_IndexedDataMapOfShapeListOfShape &
    :param theTol:
    :type theTol: float
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: int

    """
    return _BOPTools.BOPTools_AlgoTools_IsInternalFace(*args)

def BOPTools_AlgoTools_GetEdgeOnFace(*args) -> "Standard_Boolean":
    """
    * For the face theFace gets the edge theEdgeOnF that is the same as theEdge Returns True if such edge exists Returns False if there is no such edge

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theFace:
    :type theFace: TopoDS_Face &
    :param theEdgeOnF:
    :type theEdgeOnF: TopoDS_Edge &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_GetEdgeOnFace(*args)

def BOPTools_AlgoTools_ComputeState(*args) -> "TopAbs_State":
    """
    * Computes the 3-D state of the point thePoint toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.

    :param thePoint:
    :type thePoint: gp_Pnt
    :param theSolid:
    :type theSolid: TopoDS_Solid &
    :param theTol:
    :type theTol: float
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: TopAbs_State

    * Computes the 3-D state of the vertex theVertex toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.

    :param theVertex:
    :type theVertex: TopoDS_Vertex &
    :param theSolid:
    :type theSolid: TopoDS_Solid &
    :param theTol:
    :type theTol: float
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: TopAbs_State

    * Computes the 3-D state of the edge theEdge toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theSolid:
    :type theSolid: TopoDS_Solid &
    :param theTol:
    :type theTol: float
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: TopAbs_State

    * Computes the 3-D state of the face theFace toward solid theSolid. theTol - value of precision of computation theBounds - set of edges of theFace to avoid theContext- cahed geometrical tools Returns 3-D state.

    :param theFace:
    :type theFace: TopoDS_Face &
    :param theSolid:
    :type theSolid: TopoDS_Solid &
    :param theTol:
    :type theTol: float
    :param theBounds:
    :type theBounds: BOPCol_IndexedMapOfShape &
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: TopAbs_State

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeState(*args)

def BOPTools_AlgoTools_ComputeStateByOnePoint(*args) -> "TopAbs_State":
    """
    * Computes the 3-D state of the shape theShape toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.

    :param theShape:
    :type theShape: TopoDS_Shape &
    :param theSolid:
    :type theSolid: TopoDS_Solid &
    :param theTol:
    :type theTol: float
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: TopAbs_State

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeStateByOnePoint(*args)

def BOPTools_AlgoTools_MakeConnexityBlock(*args) -> "void":
    """
    * For the list of faces theLS build block theLSCB in terms of connexity by edges theMapAvoid - set of edges to avoid for the treatment

    :param theLS:
    :type theLS: BOPCol_ListOfShape &
    :param theMapAvoid:
    :type theMapAvoid: BOPCol_IndexedMapOfShape &
    :param theLSCB:
    :type theLSCB: BOPCol_ListOfShape &
    :param theAllocator:
    :type theAllocator: BOPCol_BaseAllocator &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlock(*args)

def BOPTools_AlgoTools_MakeConnexityBlocks(*args) -> "void":
    """
    * For the compound theS build the blocks theLCB (as list of compounds) in terms of connexity by the shapes of theType

    :param theS:
    :type theS: TopoDS_Shape &
    :param theType1:
    :type theType1: TopAbs_ShapeEnum
    :param theType2:
    :type theType2: TopAbs_ShapeEnum
    :param theLCB:
    :type theLCB: BOPCol_ListOfShape &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlocks(*args)

def BOPTools_AlgoTools_OrientFacesOnShell(*args) -> "void":
    """
    :param theS:
    :type theS: TopoDS_Shape &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_OrientFacesOnShell(*args)

def BOPTools_AlgoTools_CorrectTolerances(*args) -> "void":
    """
    * Provides valid values of tolerances for the shape <theS> <theTolMax> is max value of the tolerance that can be accepted for correction. If real value of the tolerance will be greater than <aTolMax>, the correction does not perform.

    :param theS:
    :type theS: TopoDS_Shape &
    :param theTolMax: default value is 0.0001
    :type theTolMax: float
    :param theRunParallel: default value is Standard_False
    :type theRunParallel: bool
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectTolerances(*args)

def BOPTools_AlgoTools_CorrectCurveOnSurface(*args) -> "void":
    """
    * Provides valid values of tolerances for the shape <theS> in terms of BRepCheck_InvalidCurveOnSurface.

    :param theS:
    :type theS: TopoDS_Shape &
    :param theTolMax: default value is 0.0001
    :type theTolMax: float
    :param theRunParallel: default value is Standard_False
    :type theRunParallel: bool
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectCurveOnSurface(*args)

def BOPTools_AlgoTools_CorrectPointOnCurve(*args) -> "void":
    """
    * Provides valid values of tolerances for the shape <theS> in terms of BRepCheck_InvalidPointOnCurve.

    :param theS:
    :type theS: TopoDS_Shape &
    :param theTolMax: default value is 0.0001
    :type theTolMax: float
    :param theRunParallel: default value is Standard_False
    :type theRunParallel: bool
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectPointOnCurve(*args)

def BOPTools_AlgoTools_MakeNewVertex(*args) -> "void":
    """
    * Make a vertex using 3D-point <aP1> and 3D-tolerance value <aTol>

    :param aP1:
    :type aP1: gp_Pnt
    :param aTol:
    :type aTol: float
    :param aNewVertex:
    :type aNewVertex: TopoDS_Vertex &
    :rtype: void

    * Make a vertex using couple of vertices <aV1, aV2>

    :param aV1:
    :type aV1: TopoDS_Vertex &
    :param aV2:
    :type aV2: TopoDS_Vertex &
    :param aNewVertex:
    :type aNewVertex: TopoDS_Vertex &
    :rtype: void

    * Make a vertex in place of intersection between two edges <aE1, aE2> with parameters <aP1, aP2>

    :param aE1:
    :type aE1: TopoDS_Edge &
    :param aP1:
    :type aP1: float
    :param aE2:
    :type aE2: TopoDS_Edge &
    :param aP2:
    :type aP2: float
    :param aNewVertex:
    :type aNewVertex: TopoDS_Vertex &
    :rtype: void

    * Make a vertex in place of intersection between the edge <aE1> with parameter <aP1> and the face <aF2>

    :param aE1:
    :type aE1: TopoDS_Edge &
    :param aP1:
    :type aP1: float
    :param aF2:
    :type aF2: TopoDS_Face &
    :param aNewVertex:
    :type aNewVertex: TopoDS_Vertex &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_MakeNewVertex(*args)

def BOPTools_AlgoTools_PointOnEdge(*args) -> "void":
    """
    * Compute a 3D-point on the edge <aEdge> at parameter <aPrm>

    :param aEdge:
    :type aEdge: TopoDS_Edge &
    :param aPrm:
    :type aPrm: float
    :param aP:
    :type aP: gp_Pnt
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_PointOnEdge(*args)

def BOPTools_AlgoTools_MakeSplitEdge(*args) -> "void":
    """
    * Make the edge from base edge <aE1> and two vertices <aV1,aV2> at parameters <aP1,aP2>

    :param aE1:
    :type aE1: TopoDS_Edge &
    :param aV1:
    :type aV1: TopoDS_Vertex &
    :param aP1:
    :type aP1: float
    :param aV2:
    :type aV2: TopoDS_Vertex &
    :param aP2:
    :type aP2: float
    :param aNewEdge:
    :type aNewEdge: TopoDS_Edge &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_MakeSplitEdge(*args)

def BOPTools_AlgoTools_MakeSectEdge(*args) -> "void":
    """
    * Make the edge from 3D-Curve <aIC> and two vertices <aV1,aV2> at parameters <aP1,aP2>

    :param aIC:
    :type aIC: IntTools_Curve &
    :param aV1:
    :type aV1: TopoDS_Vertex &
    :param aP1:
    :type aP1: float
    :param aV2:
    :type aV2: TopoDS_Vertex &
    :param aP2:
    :type aP2: float
    :param aNewEdge:
    :type aNewEdge: TopoDS_Edge &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_MakeSectEdge(*args)

def BOPTools_AlgoTools_UpdateVertex(*args) -> "void":
    """
    * Update the tolerance value for vertex <aV> taking into account the fact that <aV> lays on the curve <aIC>

    :param aIC:
    :type aIC: IntTools_Curve &
    :param aT:
    :type aT: float
    :param aV:
    :type aV: TopoDS_Vertex &
    :rtype: void

    * Update the tolerance value for vertex <aV> taking into account the fact that <aV> lays on the edge <aE>

    :param aE:
    :type aE: TopoDS_Edge &
    :param aT:
    :type aT: float
    :param aV:
    :type aV: TopoDS_Vertex &
    :rtype: void

    * Update the tolerance value for vertex <aVN> taking into account the fact that <aVN> should cover tolerance zone of <aVF>

    :param aVF:
    :type aVF: TopoDS_Vertex &
    :param aVN:
    :type aVN: TopoDS_Vertex &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_UpdateVertex(*args)

def BOPTools_AlgoTools_CorrectRange(*args) -> "void":
    """
    * Correct shrunk range <aSR> taking into account 3D-curve resolution and corresp. tolerances' values of <aE1>, <aE2>

    :param aE1:
    :type aE1: TopoDS_Edge &
    :param aE2:
    :type aE2: TopoDS_Edge &
    :param aSR:
    :type aSR: IntTools_Range &
    :param aNewSR:
    :type aNewSR: IntTools_Range &
    :rtype: void

    * Correct shrunk range <aSR> taking into account 3D-curve resolution and corresp. tolerances' values of <aE>, <aF>

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aSR:
    :type aSR: IntTools_Range &
    :param aNewSR:
    :type aNewSR: IntTools_Range &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectRange(*args)

def BOPTools_AlgoTools_IsBlockInOnFace(*args) -> "Standard_Boolean":
    """
    * Returns True if PaveBlock <aPB> lays on the face <aF>, i.e the <PB> is IN or ON in 2D of <aF>

    :param aShR:
    :type aShR: IntTools_Range &
    :param aF:
    :type aF: TopoDS_Face &
    :param aE:
    :type aE: TopoDS_Edge &
    :param aContext:
    :type aContext: Handle_IntTools_Context &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsBlockInOnFace(*args)

def BOPTools_AlgoTools_IsMicroEdge(*args) -> "Standard_Boolean":
    """
    * Checks if it is possible to compute shrunk range for the edge <aE>.

    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsMicroEdge(*args)

def BOPTools_AlgoTools_CorrectShapeTolerances(*args) -> "void":
    """
    * Corrects tolerance values of the sub-shapes of the shape <theS> if needed.

    :param theS:
    :type theS: TopoDS_Shape &
    :param theRunParallel: default value is Standard_False
    :type theRunParallel: bool
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectShapeTolerances(*args)

def BOPTools_AlgoTools_Dimension(*args) -> "Standard_Integer":
    """
    * Retutns dimension of the shape <theS>.

    :param theS:
    :type theS: TopoDS_Shape &
    :rtype: int

    """
    return _BOPTools.BOPTools_AlgoTools_Dimension(*args)

def BOPTools_AlgoTools_IsOpenShell(*args) -> "Standard_Boolean":
    """
    * Returns true if the shell <theShell> is open

    :param theShell:
    :type theShell: TopoDS_Shell &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsOpenShell(*args)

def BOPTools_AlgoTools_IsInvertedSolid(*args) -> "Standard_Boolean":
    """
    * Returns true if the solid <theSolid> is inverted

    :param theSolid:
    :type theSolid: TopoDS_Solid &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsInvertedSolid(*args)

def BOPTools_AlgoTools_ComputeTolerance(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Computes the max distance between points taken from 3D and 2D curves by the same parameter

    :param theCurve3D:
    :type theCurve3D: Handle_Geom_Curve &
    :param theCurve2D:
    :type theCurve2D: Handle_Geom2d_Curve &
    :param theSurf:
    :type theSurf: Handle_Geom_Surface &
    :param theMaxDist:
    :type theMaxDist: float &
    :param theMaxPar:
    :type theMaxPar: float &
    :rtype: bool

    * Computes the necessary value of the tolerance for the edge

    :param theFace:
    :type theFace: TopoDS_Face &
    :param theEdge:
    :type theEdge: TopoDS_Edge &
    :param theMaxDist:
    :type theMaxDist: float &
    :param theMaxPar:
    :type theMaxPar: float &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeTolerance(*args)

class BOPTools_AlgoTools2D(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BuildPCurveForEdgeOnFace(*args) -> "void":
        """
        * Compute P-Curve for the edge <aE> on the face <aF>

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(*args)

    BuildPCurveForEdgeOnFace = staticmethod(BuildPCurveForEdgeOnFace)

    def EdgeTangent(*args) -> "Standard_Boolean":
        """
        * Compute tangent for the edge <aE> [in 3D] at parameter <aT>

        :param anE:
        :type anE: TopoDS_Edge &
        :param aT:
        :type aT: float
        :param Tau:
        :type Tau: gp_Vec
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools2D_EdgeTangent(*args)

    EdgeTangent = staticmethod(EdgeTangent)

    def PointOnSurface(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Compute surface parameters <U,V> of the face <aF> for the point from the edge <aE> at parameter <aT>.

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aT:
        :type aT: float
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools2D_PointOnSurface(*args)

    PointOnSurface = staticmethod(PointOnSurface)

    def HasCurveOnSurface(*args) -> "Standard_Boolean":
        """
        * Returns True if the edge <aE> has P-Curve <aC> on surface <aF> . [aFirst, aLast] - range of the P-Curve [aToler] - reached tolerance If the P-Curve does not exist, aC.IsNull()=True.

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aC:
        :type aC: Handle_Geom2d_Curve &
        :param aFirst:
        :type aFirst: float &
        :param aLast:
        :type aLast: float &
        :param aToler:
        :type aToler: float &
        :rtype: bool

        * Returns True if the edge <aE> has P-Curve <aC> on surface <aF> . If the P-Curve does not exist, aC.IsNull()=True.

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools2D_HasCurveOnSurface(*args)

    HasCurveOnSurface = staticmethod(HasCurveOnSurface)

    def AdjustPCurveOnFace(*args) -> "void":
        """
        * Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> .

        :param aF:
        :type aF: TopoDS_Face &
        :param C3D:
        :type C3D: Handle_Geom_Curve &
        :param aC2D:
        :type aC2D: Handle_Geom2d_Curve &
        :param aC2DA:
        :type aC2DA: Handle_Geom2d_Curve &
        :rtype: void

        * Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> . [aT1, aT2] - range to adjust

        :param aF:
        :type aF: TopoDS_Face &
        :param aT1:
        :type aT1: float
        :param aT2:
        :type aT2: float
        :param aC2D:
        :type aC2D: Handle_Geom2d_Curve &
        :param aC2DA:
        :type aC2DA: Handle_Geom2d_Curve &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnFace(*args)

    AdjustPCurveOnFace = staticmethod(AdjustPCurveOnFace)

    def IntermediatePoint(*args) -> "Standard_Real":
        """
        * Compute intermediate value in between [aFirst, aLast] .

        :param aFirst:
        :type aFirst: float
        :param aLast:
        :type aLast: float
        :rtype: float

        * Compute intermediate value of parameter for the edge <anE>.

        :param anE:
        :type anE: TopoDS_Edge &
        :rtype: float

        """
        return _BOPTools.BOPTools_AlgoTools2D_IntermediatePoint(*args)

    IntermediatePoint = staticmethod(IntermediatePoint)

    def BuildPCurveForEdgeOnPlane(*args) -> "void":
        """
        :param theE:
        :type theE: TopoDS_Edge &
        :param theF:
        :type theF: TopoDS_Face &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgeOnPlane(*args)

    BuildPCurveForEdgeOnPlane = staticmethod(BuildPCurveForEdgeOnPlane)

    def BuildPCurveForEdgesOnPlane(*args) -> "void":
        """
        :param theLE:
        :type theLE: BOPCol_ListOfShape &
        :param theF:
        :type theF: TopoDS_Face &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgesOnPlane(*args)

    BuildPCurveForEdgesOnPlane = staticmethod(BuildPCurveForEdgesOnPlane)

    def Make2D(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        * Make P-Curve <aC> for the edge <aE> on surface <aF> . [aFirst, aLast] - range of the P-Curve [aToler] - reached tolerance

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aC:
        :type aC: Handle_Geom2d_Curve &
        :param aFirst:
        :type aFirst: float &
        :param aLast:
        :type aLast: float &
        :param aToler:
        :type aToler: float &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools2D_Make2D(*args)

    Make2D = staticmethod(Make2D)

    def MakePCurveOnFace(*args) -> "Standard_Real &":
        """
        * Make P-Curve <aC> for the 3D-curve <C3D> on surface <aF> . [aToler] - reached tolerance

        :param aF:
        :type aF: TopoDS_Face &
        :param C3D:
        :type C3D: Handle_Geom_Curve &
        :param aC:
        :type aC: Handle_Geom2d_Curve &
        :param aToler:
        :type aToler: float &
        :rtype: void

        * Make P-Curve <aC> for the 3D-curve <C3D> on surface <aF> . [aT1, aT2] - range to build [aToler] - reached tolerance

        :param aF:
        :type aF: TopoDS_Face &
        :param C3D:
        :type C3D: Handle_Geom_Curve &
        :param aT1:
        :type aT1: float
        :param aT2:
        :type aT2: float
        :param aC:
        :type aC: Handle_Geom2d_Curve &
        :param aToler:
        :type aToler: float &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools2D_MakePCurveOnFace(*args)

    MakePCurveOnFace = staticmethod(MakePCurveOnFace)

    def MakePCurveOfType(*args) -> "void":
        """
        * Make empty P-Curve <aC> of relevant to <PC> type

        :param PC:
        :type PC: ProjLib_ProjectedCurve &
        :param aC:
        :type aC: Handle_Geom2d_Curve &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools2D_MakePCurveOfType(*args)

    MakePCurveOfType = staticmethod(MakePCurveOfType)

    __repr__ = _dumps_object


    def __init__(self):
        _BOPTools.BOPTools_AlgoTools2D_swiginit(self, _BOPTools.new_BOPTools_AlgoTools2D())
    __swig_destroy__ = _BOPTools.delete_BOPTools_AlgoTools2D
BOPTools_AlgoTools2D_swigregister = _BOPTools.BOPTools_AlgoTools2D_swigregister
BOPTools_AlgoTools2D_swigregister(BOPTools_AlgoTools2D)

def BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(*args) -> "void":
    """
    * Compute P-Curve for the edge <aE> on the face <aF>

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(*args)

def BOPTools_AlgoTools2D_EdgeTangent(*args) -> "Standard_Boolean":
    """
    * Compute tangent for the edge <aE> [in 3D] at parameter <aT>

    :param anE:
    :type anE: TopoDS_Edge &
    :param aT:
    :type aT: float
    :param Tau:
    :type Tau: gp_Vec
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools2D_EdgeTangent(*args)

def BOPTools_AlgoTools2D_PointOnSurface(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Compute surface parameters <U,V> of the face <aF> for the point from the edge <aE> at parameter <aT>.

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aT:
    :type aT: float
    :param U:
    :type U: float &
    :param V:
    :type V: float &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools2D_PointOnSurface(*args)

def BOPTools_AlgoTools2D_HasCurveOnSurface(*args) -> "Standard_Boolean":
    """
    * Returns True if the edge <aE> has P-Curve <aC> on surface <aF> . [aFirst, aLast] - range of the P-Curve [aToler] - reached tolerance If the P-Curve does not exist, aC.IsNull()=True.

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aC:
    :type aC: Handle_Geom2d_Curve &
    :param aFirst:
    :type aFirst: float &
    :param aLast:
    :type aLast: float &
    :param aToler:
    :type aToler: float &
    :rtype: bool

    * Returns True if the edge <aE> has P-Curve <aC> on surface <aF> . If the P-Curve does not exist, aC.IsNull()=True.

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools2D_HasCurveOnSurface(*args)

def BOPTools_AlgoTools2D_AdjustPCurveOnFace(*args) -> "void":
    """
    * Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> .

    :param aF:
    :type aF: TopoDS_Face &
    :param C3D:
    :type C3D: Handle_Geom_Curve &
    :param aC2D:
    :type aC2D: Handle_Geom2d_Curve &
    :param aC2DA:
    :type aC2DA: Handle_Geom2d_Curve &
    :rtype: void

    * Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> . [aT1, aT2] - range to adjust

    :param aF:
    :type aF: TopoDS_Face &
    :param aT1:
    :type aT1: float
    :param aT2:
    :type aT2: float
    :param aC2D:
    :type aC2D: Handle_Geom2d_Curve &
    :param aC2DA:
    :type aC2DA: Handle_Geom2d_Curve &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnFace(*args)

def BOPTools_AlgoTools2D_IntermediatePoint(*args) -> "Standard_Real":
    """
    * Compute intermediate value in between [aFirst, aLast] .

    :param aFirst:
    :type aFirst: float
    :param aLast:
    :type aLast: float
    :rtype: float

    * Compute intermediate value of parameter for the edge <anE>.

    :param anE:
    :type anE: TopoDS_Edge &
    :rtype: float

    """
    return _BOPTools.BOPTools_AlgoTools2D_IntermediatePoint(*args)

def BOPTools_AlgoTools2D_BuildPCurveForEdgeOnPlane(*args) -> "void":
    """
    :param theE:
    :type theE: TopoDS_Edge &
    :param theF:
    :type theF: TopoDS_Face &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgeOnPlane(*args)

def BOPTools_AlgoTools2D_BuildPCurveForEdgesOnPlane(*args) -> "void":
    """
    :param theLE:
    :type theLE: BOPCol_ListOfShape &
    :param theF:
    :type theF: TopoDS_Face &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgesOnPlane(*args)

def BOPTools_AlgoTools2D_Make2D(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    * Make P-Curve <aC> for the edge <aE> on surface <aF> . [aFirst, aLast] - range of the P-Curve [aToler] - reached tolerance

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aC:
    :type aC: Handle_Geom2d_Curve &
    :param aFirst:
    :type aFirst: float &
    :param aLast:
    :type aLast: float &
    :param aToler:
    :type aToler: float &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools2D_Make2D(*args)

def BOPTools_AlgoTools2D_MakePCurveOnFace(*args) -> "Standard_Real &":
    """
    * Make P-Curve <aC> for the 3D-curve <C3D> on surface <aF> . [aToler] - reached tolerance

    :param aF:
    :type aF: TopoDS_Face &
    :param C3D:
    :type C3D: Handle_Geom_Curve &
    :param aC:
    :type aC: Handle_Geom2d_Curve &
    :param aToler:
    :type aToler: float &
    :rtype: void

    * Make P-Curve <aC> for the 3D-curve <C3D> on surface <aF> . [aT1, aT2] - range to build [aToler] - reached tolerance

    :param aF:
    :type aF: TopoDS_Face &
    :param C3D:
    :type C3D: Handle_Geom_Curve &
    :param aT1:
    :type aT1: float
    :param aT2:
    :type aT2: float
    :param aC:
    :type aC: Handle_Geom2d_Curve &
    :param aToler:
    :type aToler: float &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools2D_MakePCurveOnFace(*args)

def BOPTools_AlgoTools2D_MakePCurveOfType(*args) -> "void":
    """
    * Make empty P-Curve <aC> of relevant to <PC> type

    :param PC:
    :type PC: ProjLib_ProjectedCurve &
    :param aC:
    :type aC: Handle_Geom2d_Curve &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools2D_MakePCurveOfType(*args)

class BOPTools_AlgoTools3D(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DoSplitSEAMOnFace(*args) -> "void":
        """
        * Make the edge <aSp> seam edge for the face <aF>

        :param aSp:
        :type aSp: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools3D_DoSplitSEAMOnFace(*args)

    DoSplitSEAMOnFace = staticmethod(DoSplitSEAMOnFace)

    def GetNormalToFaceOnEdge(*args) -> "void":
        """
        * Computes normal to the face <aF> for the point on the edge <aE> at parameter <aT>

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aT:
        :type aT: float
        :param aD:
        :type aD: gp_Dir
        :rtype: void

        * Computes normal to the face <aF> for the point on the edge <aE> at arbitrary intermediate parameter

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aD:
        :type aD: gp_Dir
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(*args)

    GetNormalToFaceOnEdge = staticmethod(GetNormalToFaceOnEdge)

    def SenseFlag(*args) -> "Standard_Integer":
        """
        * Returns 1 if scalar product aNF1* aNF2>0. Returns 0 if directions aNF1 aNF2 coinside Returns -1 if scalar product aNF1* aNF2<0.

        :param aNF1:
        :type aNF1: gp_Dir
        :param aNF2:
        :type aNF2: gp_Dir
        :rtype: int

        """
        return _BOPTools.BOPTools_AlgoTools3D_SenseFlag(*args)

    SenseFlag = staticmethod(SenseFlag)

    def GetNormalToSurface(*args) -> "Standard_Boolean":
        """
        * Compute normal <aD> to surface <aS> in point (U,V) Returns True if directions aD1U, aD1V coinside

        :param aS:
        :type aS: Handle_Geom_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param aD:
        :type aD: gp_Dir
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools3D_GetNormalToSurface(*args)

    GetNormalToSurface = staticmethod(GetNormalToSurface)

    def GetApproxNormalToFaceOnEdge(*args) -> "void":
        """
        * Computes normal to the face <aF> for the 3D-point that belonds to the edge <aE> at parameter <aT>. Output: aPx - the 3D-point where the normal computed aD - the normal; //! Warning: The normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal)

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aT:
        :type aT: float
        :param aPx:
        :type aPx: gp_Pnt
        :param aD:
        :type aD: gp_Dir
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: void

        :param theE:
        :type theE: TopoDS_Edge &
        :param theF:
        :type theF: TopoDS_Face &
        :param aT:
        :type aT: float
        :param aP:
        :type aP: gp_Pnt
        :param aDNF:
        :type aDNF: gp_Dir
        :param aDt2D:
        :type aDt2D: float
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(*args)

    GetApproxNormalToFaceOnEdge = staticmethod(GetApproxNormalToFaceOnEdge)

    def PointNearEdge(*args) -> "void":
        """
        * Compute the point <aPx>, (<aP2D>) that is near to the edge <aE> at parameter <aT> towards to the material of the face <aF>. The value of shifting in 2D is <aDt2D>

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aT:
        :type aT: float
        :param aDt2D:
        :type aDt2D: float
        :param aP2D:
        :type aP2D: gp_Pnt2d
        :param aPx:
        :type aPx: gp_Pnt
        :rtype: void

        * Computes the point <aPx>, (<aP2D>) that is near to the edge <aE> at parameter <aT> towards to the material of the face <aF>. The value of shifting in 2D is dt2D=BOPTools_AlgoTools3D::MinStepIn2d()

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aT:
        :type aT: float
        :param aP2D:
        :type aP2D: gp_Pnt2d
        :param aPx:
        :type aPx: gp_Pnt
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: void

        * Compute the point <aPx>, (<aP2D>) that is near to the edge <aE> at arbitrary parameter towards to the material of the face <aF>. The value of shifting in 2D is dt2D=BOPTools_AlgoTools3D::MinStepIn2d()

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aP2D:
        :type aP2D: gp_Pnt2d
        :param aPx:
        :type aPx: gp_Pnt
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools3D_PointNearEdge(*args)

    PointNearEdge = staticmethod(PointNearEdge)

    def MinStepIn2d(*args) -> "Standard_Real":
        """
        * Returns simple step value that is used in 2D-computations = 1.e-5

        :rtype: float

        """
        return _BOPTools.BOPTools_AlgoTools3D_MinStepIn2d(*args)

    MinStepIn2d = staticmethod(MinStepIn2d)

    def IsEmptyShape(*args) -> "Standard_Boolean":
        """
        * Returns True if the shape <aS> does not contain geometry information (e.g. empty compound)

        :param aS:
        :type aS: TopoDS_Shape &
        :rtype: bool

        """
        return _BOPTools.BOPTools_AlgoTools3D_IsEmptyShape(*args)

    IsEmptyShape = staticmethod(IsEmptyShape)

    def OrientEdgeOnFace(*args) -> "void":
        """
        * Get the edge <aER> from the face <aF> that is the same as the edge <aE>

        :param aE:
        :type aE: TopoDS_Edge &
        :param aF:
        :type aF: TopoDS_Face &
        :param aER:
        :type aER: TopoDS_Edge &
        :rtype: void

        """
        return _BOPTools.BOPTools_AlgoTools3D_OrientEdgeOnFace(*args)

    OrientEdgeOnFace = staticmethod(OrientEdgeOnFace)

    def PointInFace(*args) -> "Standard_Integer":
        """
        * Computes a point <theP> inside the face <theF>. <theP2D> - 2D representation of <theP> on the surface of <theF> Returns 0 in case of success.

        :param theF:
        :type theF: TopoDS_Face &
        :param theP:
        :type theP: gp_Pnt
        :param theP2D:
        :type theP2D: gp_Pnt2d
        :param theContext:
        :type theContext: Handle_IntTools_Context &
        :rtype: int

        """
        return _BOPTools.BOPTools_AlgoTools3D_PointInFace(*args)

    PointInFace = staticmethod(PointInFace)

    __repr__ = _dumps_object


    def __init__(self):
        _BOPTools.BOPTools_AlgoTools3D_swiginit(self, _BOPTools.new_BOPTools_AlgoTools3D())
    __swig_destroy__ = _BOPTools.delete_BOPTools_AlgoTools3D
BOPTools_AlgoTools3D_swigregister = _BOPTools.BOPTools_AlgoTools3D_swigregister
BOPTools_AlgoTools3D_swigregister(BOPTools_AlgoTools3D)

def BOPTools_AlgoTools3D_DoSplitSEAMOnFace(*args) -> "void":
    """
    * Make the edge <aSp> seam edge for the face <aF>

    :param aSp:
    :type aSp: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools3D_DoSplitSEAMOnFace(*args)

def BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(*args) -> "void":
    """
    * Computes normal to the face <aF> for the point on the edge <aE> at parameter <aT>

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aT:
    :type aT: float
    :param aD:
    :type aD: gp_Dir
    :rtype: void

    * Computes normal to the face <aF> for the point on the edge <aE> at arbitrary intermediate parameter

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aD:
    :type aD: gp_Dir
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(*args)

def BOPTools_AlgoTools3D_SenseFlag(*args) -> "Standard_Integer":
    """
    * Returns 1 if scalar product aNF1* aNF2>0. Returns 0 if directions aNF1 aNF2 coinside Returns -1 if scalar product aNF1* aNF2<0.

    :param aNF1:
    :type aNF1: gp_Dir
    :param aNF2:
    :type aNF2: gp_Dir
    :rtype: int

    """
    return _BOPTools.BOPTools_AlgoTools3D_SenseFlag(*args)

def BOPTools_AlgoTools3D_GetNormalToSurface(*args) -> "Standard_Boolean":
    """
    * Compute normal <aD> to surface <aS> in point (U,V) Returns True if directions aD1U, aD1V coinside

    :param aS:
    :type aS: Handle_Geom_Surface &
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param aD:
    :type aD: gp_Dir
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools3D_GetNormalToSurface(*args)

def BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(*args) -> "void":
    """
    * Computes normal to the face <aF> for the 3D-point that belonds to the edge <aE> at parameter <aT>. Output: aPx - the 3D-point where the normal computed aD - the normal; //! Warning: The normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal)

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aT:
    :type aT: float
    :param aPx:
    :type aPx: gp_Pnt
    :param aD:
    :type aD: gp_Dir
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: void

    :param theE:
    :type theE: TopoDS_Edge &
    :param theF:
    :type theF: TopoDS_Face &
    :param aT:
    :type aT: float
    :param aP:
    :type aP: gp_Pnt
    :param aDNF:
    :type aDNF: gp_Dir
    :param aDt2D:
    :type aDt2D: float
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(*args)

def BOPTools_AlgoTools3D_PointNearEdge(*args) -> "void":
    """
    * Compute the point <aPx>, (<aP2D>) that is near to the edge <aE> at parameter <aT> towards to the material of the face <aF>. The value of shifting in 2D is <aDt2D>

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aT:
    :type aT: float
    :param aDt2D:
    :type aDt2D: float
    :param aP2D:
    :type aP2D: gp_Pnt2d
    :param aPx:
    :type aPx: gp_Pnt
    :rtype: void

    * Computes the point <aPx>, (<aP2D>) that is near to the edge <aE> at parameter <aT> towards to the material of the face <aF>. The value of shifting in 2D is dt2D=BOPTools_AlgoTools3D::MinStepIn2d()

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aT:
    :type aT: float
    :param aP2D:
    :type aP2D: gp_Pnt2d
    :param aPx:
    :type aPx: gp_Pnt
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: void

    * Compute the point <aPx>, (<aP2D>) that is near to the edge <aE> at arbitrary parameter towards to the material of the face <aF>. The value of shifting in 2D is dt2D=BOPTools_AlgoTools3D::MinStepIn2d()

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aP2D:
    :type aP2D: gp_Pnt2d
    :param aPx:
    :type aPx: gp_Pnt
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools3D_PointNearEdge(*args)

def BOPTools_AlgoTools3D_MinStepIn2d(*args) -> "Standard_Real":
    """
    * Returns simple step value that is used in 2D-computations = 1.e-5

    :rtype: float

    """
    return _BOPTools.BOPTools_AlgoTools3D_MinStepIn2d(*args)

def BOPTools_AlgoTools3D_IsEmptyShape(*args) -> "Standard_Boolean":
    """
    * Returns True if the shape <aS> does not contain geometry information (e.g. empty compound)

    :param aS:
    :type aS: TopoDS_Shape &
    :rtype: bool

    """
    return _BOPTools.BOPTools_AlgoTools3D_IsEmptyShape(*args)

def BOPTools_AlgoTools3D_OrientEdgeOnFace(*args) -> "void":
    """
    * Get the edge <aER> from the face <aF> that is the same as the edge <aE>

    :param aE:
    :type aE: TopoDS_Edge &
    :param aF:
    :type aF: TopoDS_Face &
    :param aER:
    :type aER: TopoDS_Edge &
    :rtype: void

    """
    return _BOPTools.BOPTools_AlgoTools3D_OrientEdgeOnFace(*args)

def BOPTools_AlgoTools3D_PointInFace(*args) -> "Standard_Integer":
    """
    * Computes a point <theP> inside the face <theF>. <theP2D> - 2D representation of <theP> on the surface of <theF> Returns 0 in case of success.

    :param theF:
    :type theF: TopoDS_Face &
    :param theP:
    :type theP: gp_Pnt
    :param theP2D:
    :type theP2D: gp_Pnt2d
    :param theContext:
    :type theContext: Handle_IntTools_Context &
    :rtype: int

    """
    return _BOPTools.BOPTools_AlgoTools3D_PointInFace(*args)

class BOPTools_ConnexityBlock(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param theAllocator:
        :type theAllocator: Handle_NCollection_BaseAllocator &
        :rtype: None

        """
        _BOPTools.BOPTools_ConnexityBlock_swiginit(self, _BOPTools.new_BOPTools_ConnexityBlock(*args))

    def Shapes(self, *args) -> "BOPCol_ListOfShape const &":
        """
        :rtype: BOPCol_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_Shapes(self, *args)


    def ChangeShapes(self, *args) -> "BOPCol_ListOfShape &":
        """
        :rtype: BOPCol_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_ChangeShapes(self, *args)


    def SetRegular(self, *args) -> "void":
        """
        :param theFlag:
        :type theFlag: bool
        :rtype: None

        """
        return _BOPTools.BOPTools_ConnexityBlock_SetRegular(self, *args)


    def IsRegular(self, *args) -> "Standard_Boolean":
        """
        :rtype: bool

        """
        return _BOPTools.BOPTools_ConnexityBlock_IsRegular(self, *args)


    def Loops(self, *args) -> "BOPCol_ListOfShape const &":
        """
        :rtype: BOPCol_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_Loops(self, *args)


    def ChangeLoops(self, *args) -> "BOPCol_ListOfShape &":
        """
        :rtype: BOPCol_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_ChangeLoops(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BOPTools.delete_BOPTools_ConnexityBlock
BOPTools_ConnexityBlock.Shapes = new_instancemethod(_BOPTools.BOPTools_ConnexityBlock_Shapes, None, BOPTools_ConnexityBlock)
BOPTools_ConnexityBlock.ChangeShapes = new_instancemethod(_BOPTools.BOPTools_ConnexityBlock_ChangeShapes, None, BOPTools_ConnexityBlock)
BOPTools_ConnexityBlock.SetRegular = new_instancemethod(_BOPTools.BOPTools_ConnexityBlock_SetRegular, None, BOPTools_ConnexityBlock)
BOPTools_ConnexityBlock.IsRegular = new_instancemethod(_BOPTools.BOPTools_ConnexityBlock_IsRegular, None, BOPTools_ConnexityBlock)
BOPTools_ConnexityBlock.Loops = new_instancemethod(_BOPTools.BOPTools_ConnexityBlock_Loops, None, BOPTools_ConnexityBlock)
BOPTools_ConnexityBlock.ChangeLoops = new_instancemethod(_BOPTools.BOPTools_ConnexityBlock_ChangeLoops, None, BOPTools_ConnexityBlock)
BOPTools_ConnexityBlock_swigregister = _BOPTools.BOPTools_ConnexityBlock_swigregister
BOPTools_ConnexityBlock_swigregister(BOPTools_ConnexityBlock)

class BOPTools_CoupleOfShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _BOPTools.BOPTools_CoupleOfShape_swiginit(self, _BOPTools.new_BOPTools_CoupleOfShape(*args))

    def SetShape1(self, *args) -> "void":
        """
        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        """
        return _BOPTools.BOPTools_CoupleOfShape_SetShape1(self, *args)


    def Shape1(self, *args) -> "TopoDS_Shape const":
        """
        :rtype: TopoDS_Shape

        """
        return _BOPTools.BOPTools_CoupleOfShape_Shape1(self, *args)


    def SetShape2(self, *args) -> "void":
        """
        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        """
        return _BOPTools.BOPTools_CoupleOfShape_SetShape2(self, *args)


    def Shape2(self, *args) -> "TopoDS_Shape const":
        """
        :rtype: TopoDS_Shape

        """
        return _BOPTools.BOPTools_CoupleOfShape_Shape2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BOPTools.delete_BOPTools_CoupleOfShape
BOPTools_CoupleOfShape.SetShape1 = new_instancemethod(_BOPTools.BOPTools_CoupleOfShape_SetShape1, None, BOPTools_CoupleOfShape)
BOPTools_CoupleOfShape.Shape1 = new_instancemethod(_BOPTools.BOPTools_CoupleOfShape_Shape1, None, BOPTools_CoupleOfShape)
BOPTools_CoupleOfShape.SetShape2 = new_instancemethod(_BOPTools.BOPTools_CoupleOfShape_SetShape2, None, BOPTools_CoupleOfShape)
BOPTools_CoupleOfShape.Shape2 = new_instancemethod(_BOPTools.BOPTools_CoupleOfShape_Shape2, None, BOPTools_CoupleOfShape)
BOPTools_CoupleOfShape_swigregister = _BOPTools.BOPTools_CoupleOfShape_swigregister
BOPTools_CoupleOfShape_swigregister(BOPTools_CoupleOfShape)

class BOPTools_EdgeSet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param theAllocator:
        :type theAllocator: BOPCol_BaseAllocator &
        :rtype: None

        """
        _BOPTools.BOPTools_EdgeSet_swiginit(self, _BOPTools.new_BOPTools_EdgeSet(*args))

    def SetShape(self, *args) -> "void":
        """
        :param theS:
        :type theS: TopoDS_Shape &
        :rtype: None

        """
        return _BOPTools.BOPTools_EdgeSet_SetShape(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape const":
        """
        :rtype: TopoDS_Shape

        """
        return _BOPTools.BOPTools_EdgeSet_Shape(self, *args)


    def AddEdge(self, *args) -> "void":
        """
        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :rtype: None

        """
        return _BOPTools.BOPTools_EdgeSet_AddEdge(self, *args)


    def AddEdges(self, *args) -> "void":
        """
        :param theLS:
        :type theLS: BOPCol_ListOfShape &
        :rtype: None

        :param theFace:
        :type theFace: TopoDS_Shape &
        :rtype: None

        """
        return _BOPTools.BOPTools_EdgeSet_AddEdges(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _BOPTools.BOPTools_EdgeSet_Clear(self, *args)


    def Get(self, *args) -> "void":
        """
        :param theLS:
        :type theLS: BOPCol_ListOfShape &
        :rtype: None

        """
        return _BOPTools.BOPTools_EdgeSet_Get(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        :param theSet:
        :type theSet: BOPTools_EdgeSet &
        :rtype: bool

        """
        return _BOPTools.BOPTools_EdgeSet_Contains(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BOPTools.delete_BOPTools_EdgeSet
BOPTools_EdgeSet.SetShape = new_instancemethod(_BOPTools.BOPTools_EdgeSet_SetShape, None, BOPTools_EdgeSet)
BOPTools_EdgeSet.Shape = new_instancemethod(_BOPTools.BOPTools_EdgeSet_Shape, None, BOPTools_EdgeSet)
BOPTools_EdgeSet.AddEdge = new_instancemethod(_BOPTools.BOPTools_EdgeSet_AddEdge, None, BOPTools_EdgeSet)
BOPTools_EdgeSet.AddEdges = new_instancemethod(_BOPTools.BOPTools_EdgeSet_AddEdges, None, BOPTools_EdgeSet)
BOPTools_EdgeSet.Clear = new_instancemethod(_BOPTools.BOPTools_EdgeSet_Clear, None, BOPTools_EdgeSet)
BOPTools_EdgeSet.Get = new_instancemethod(_BOPTools.BOPTools_EdgeSet_Get, None, BOPTools_EdgeSet)
BOPTools_EdgeSet.Contains = new_instancemethod(_BOPTools.BOPTools_EdgeSet_Contains, None, BOPTools_EdgeSet)
BOPTools_EdgeSet_swigregister = _BOPTools.BOPTools_EdgeSet_swigregister
BOPTools_EdgeSet_swigregister(BOPTools_EdgeSet)

class BOPTools_Set(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param theAllocator:
        :type theAllocator: BOPCol_BaseAllocator &
        :rtype: None

        """
        _BOPTools.BOPTools_Set_swiginit(self, _BOPTools.new_BOPTools_Set(*args))

    def Assign(self, *args) -> "BOPTools_Set &":
        """
        :param Other:
        :type Other: BOPTools_Set &
        :rtype: BOPTools_Set

        """
        return _BOPTools.BOPTools_Set_Assign(self, *args)


    def Set(self, *args) -> "BOPTools_Set &":
        """
        :param Other:
        :type Other: BOPTools_Set &
        :rtype: BOPTools_Set

        """
        return _BOPTools.BOPTools_Set_Set(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape const":
        """
        :rtype: TopoDS_Shape

        """
        return _BOPTools.BOPTools_Set_Shape(self, *args)


    def Add(self, *args) -> "void":
        """
        :param theS:
        :type theS: TopoDS_Shape &
        :param theType:
        :type theType: TopAbs_ShapeEnum
        :rtype: None

        """
        return _BOPTools.BOPTools_Set_Add(self, *args)


    def NbShapes(self, *args) -> "Standard_Integer":
        """
        :rtype: int

        """
        return _BOPTools.BOPTools_Set_NbShapes(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        :param aOther:
        :type aOther: BOPTools_Set &
        :rtype: bool

        """
        return _BOPTools.BOPTools_Set_IsEqual(self, *args)


    def HashCode(self, *args) -> "Standard_Integer":
        """
        :param Upper:
        :type Upper: int
        :rtype: int

        """
        return _BOPTools.BOPTools_Set_HashCode(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BOPTools.delete_BOPTools_Set
BOPTools_Set.Assign = new_instancemethod(_BOPTools.BOPTools_Set_Assign, None, BOPTools_Set)
BOPTools_Set.Set = new_instancemethod(_BOPTools.BOPTools_Set_Set, None, BOPTools_Set)
BOPTools_Set.Shape = new_instancemethod(_BOPTools.BOPTools_Set_Shape, None, BOPTools_Set)
BOPTools_Set.Add = new_instancemethod(_BOPTools.BOPTools_Set_Add, None, BOPTools_Set)
BOPTools_Set.NbShapes = new_instancemethod(_BOPTools.BOPTools_Set_NbShapes, None, BOPTools_Set)
BOPTools_Set.IsEqual = new_instancemethod(_BOPTools.BOPTools_Set_IsEqual, None, BOPTools_Set)
BOPTools_Set.HashCode = new_instancemethod(_BOPTools.BOPTools_Set_HashCode, None, BOPTools_Set)
BOPTools_Set.__hash__ = new_instancemethod(_BOPTools.BOPTools_Set___hash__, None, BOPTools_Set)
BOPTools_Set_swigregister = _BOPTools.BOPTools_Set_swigregister
BOPTools_Set_swigregister(BOPTools_Set)

class BOPTools_SetMapHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args) -> "Standard_Integer":
        """
        :param aSet:
        :type aSet: BOPTools_Set &
        :param Upper:
        :type Upper: int
        :rtype: int

        """
        return _BOPTools.BOPTools_SetMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        :param aSet1:
        :type aSet1: BOPTools_Set &
        :param aSet2:
        :type aSet2: BOPTools_Set &
        :rtype: bool

        """
        return _BOPTools.BOPTools_SetMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object


    def __init__(self):
        _BOPTools.BOPTools_SetMapHasher_swiginit(self, _BOPTools.new_BOPTools_SetMapHasher())
    __swig_destroy__ = _BOPTools.delete_BOPTools_SetMapHasher
BOPTools_SetMapHasher_swigregister = _BOPTools.BOPTools_SetMapHasher_swigregister
BOPTools_SetMapHasher_swigregister(BOPTools_SetMapHasher)

def BOPTools_SetMapHasher_HashCode(*args) -> "Standard_Integer":
    """
    :param aSet:
    :type aSet: BOPTools_Set &
    :param Upper:
    :type Upper: int
    :rtype: int

    """
    return _BOPTools.BOPTools_SetMapHasher_HashCode(*args)

def BOPTools_SetMapHasher_IsEqual(*args) -> "Standard_Boolean":
    """
    :param aSet1:
    :type aSet1: BOPTools_Set &
    :param aSet2:
    :type aSet2: BOPTools_Set &
    :rtype: bool

    """
    return _BOPTools.BOPTools_SetMapHasher_IsEqual(*args)

class BOPTools_ShapeSet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param theAllocator:
        :type theAllocator: BOPCol_BaseAllocator &
        :rtype: None

        """
        _BOPTools.BOPTools_ShapeSet_swiginit(self, _BOPTools.new_BOPTools_ShapeSet(*args))

    def SetShape(self, *args) -> "void":
        """
        :param theS:
        :type theS: TopoDS_Shape &
        :rtype: None

        """
        return _BOPTools.BOPTools_ShapeSet_SetShape(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape const":
        """
        :rtype: TopoDS_Shape

        """
        return _BOPTools.BOPTools_ShapeSet_Shape(self, *args)


    def Add(self, *args) -> "void":
        """
        :param theLS:
        :type theLS: BOPCol_ListOfShape &
        :rtype: None

        :param theShape:
        :type theShape: TopoDS_Shape &
        :rtype: None

        :param theShape:
        :type theShape: TopoDS_Shape &
        :param theType:
        :type theType: TopAbs_ShapeEnum
        :rtype: None

        """
        return _BOPTools.BOPTools_ShapeSet_Add(self, *args)


    def AddEdge(self, *args) -> "void":
        """
        :param theEdge:
        :type theEdge: TopoDS_Edge &
        :rtype: None

        """
        return _BOPTools.BOPTools_ShapeSet_AddEdge(self, *args)


    def AddEdges(self, *args) -> "void":
        """
        :param theLS:
        :type theLS: BOPCol_ListOfShape &
        :rtype: None

        :param theFace:
        :type theFace: TopoDS_Shape &
        :rtype: None

        """
        return _BOPTools.BOPTools_ShapeSet_AddEdges(self, *args)


    def Subtract(self, *args) -> "void":
        """
        :param theSet:
        :type theSet: BOPTools_ShapeSet &
        :rtype: None

        """
        return _BOPTools.BOPTools_ShapeSet_Subtract(self, *args)


    def __isub__(self, *args) -> "void":
        """
        :param theSet:
        :type theSet: BOPTools_ShapeSet &
        :rtype: None

        """
        return _BOPTools.BOPTools_ShapeSet___isub__(self, *args)


    def Clear(self, *args) -> "void":
        """
        :rtype: None

        """
        return _BOPTools.BOPTools_ShapeSet_Clear(self, *args)


    def Get(self, *args) -> "void":
        """
        :param theLS:
        :type theLS: BOPCol_ListOfShape &
        :rtype: None

        """
        return _BOPTools.BOPTools_ShapeSet_Get(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        :param theSet:
        :type theSet: BOPTools_ShapeSet &
        :rtype: bool

        """
        return _BOPTools.BOPTools_ShapeSet_Contains(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BOPTools.delete_BOPTools_ShapeSet
BOPTools_ShapeSet.SetShape = new_instancemethod(_BOPTools.BOPTools_ShapeSet_SetShape, None, BOPTools_ShapeSet)
BOPTools_ShapeSet.Shape = new_instancemethod(_BOPTools.BOPTools_ShapeSet_Shape, None, BOPTools_ShapeSet)
BOPTools_ShapeSet.Add = new_instancemethod(_BOPTools.BOPTools_ShapeSet_Add, None, BOPTools_ShapeSet)
BOPTools_ShapeSet.AddEdge = new_instancemethod(_BOPTools.BOPTools_ShapeSet_AddEdge, None, BOPTools_ShapeSet)
BOPTools_ShapeSet.AddEdges = new_instancemethod(_BOPTools.BOPTools_ShapeSet_AddEdges, None, BOPTools_ShapeSet)
BOPTools_ShapeSet.Subtract = new_instancemethod(_BOPTools.BOPTools_ShapeSet_Subtract, None, BOPTools_ShapeSet)
BOPTools_ShapeSet.__isub__ = new_instancemethod(_BOPTools.BOPTools_ShapeSet___isub__, None, BOPTools_ShapeSet)
BOPTools_ShapeSet.Clear = new_instancemethod(_BOPTools.BOPTools_ShapeSet_Clear, None, BOPTools_ShapeSet)
BOPTools_ShapeSet.Get = new_instancemethod(_BOPTools.BOPTools_ShapeSet_Get, None, BOPTools_ShapeSet)
BOPTools_ShapeSet.Contains = new_instancemethod(_BOPTools.BOPTools_ShapeSet_Contains, None, BOPTools_ShapeSet)
BOPTools_ShapeSet_swigregister = _BOPTools.BOPTools_ShapeSet_swigregister
BOPTools_ShapeSet_swigregister(BOPTools_ShapeSet)



